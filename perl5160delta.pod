мencoding utf8

=head1 ИМЯ

perl5160delta - что нового в perl v5.16.0

=head1 Описание

Этот документ описывает различия между релизом 5.14.0 и релизом
5.16.0

Если вы обновляетесь с более раннего релиза, такого как 5.12.0, сначала
прочтите L<perl5140delta>, который описывает различия между 5.12.0 и
5.14.0

=head1 Уведомление

Как описано в L<perlpolicy>, релиз Perl 5.16.0 приводит к официальному
окончанию поддержки для Perl 5.12.  Пользователи Perl 5.12 или более
ранних версий должны рассмотреть вопрос обновления до более свежего
релиза Perl.

=head1 Улучшения Ядра

=head2 C<use I<VERSION>>

Начиная с этого релиза объявление версии вида C<use v5.16> приводит
к отключению всех функций (features), до тех пор пока явно не
включён пакет новых функций. Это означает, что справедлив следующий
код:

    use 5.016;
    # только функционал 5.16 включен здесь
    use 5.014;
    # только функционал 5.14 включен здесь (а не 5.16)

C<use v5.12> и выше продолжают включать режим strict, но явное указание
C<use strict> и C<no strict> переопределяет режим заданный при
объявлении версии, даже если оно идёт раньше в коде:

    no strict;
    use 5.012;
    # здесь no strict

Появился новый ":default" пакет функционала, который представляет
собой набор функций включённых до момента обнаружения любого
объявления версии или C<use feature>.  Объявление версии ниже 5.10
включает ":default" набор функционала.  Это, на самом деле, не меняет
поведения C<use v5.8>, поскольку функции добавленные в набор
":default" это те, которые традиционно были включены по-умолчанию,
до того как их стало можно отключать.

C<< no feature >> сбрасывает к базовому (default) набору функционала.
Для отключения всех функций (что похоже будет довольно специфическим
запросом, т.к. по-видимому не подошёл ни один именной набор) вы
можете написать C<< no feature ':all' >>.

C<$[> теперь отключается при указании C<use v5.16>.  Это часть
базового (default) набора функционала и может быть явно включено или
отключено с использованием C<use feature 'array_base'>.

=head2 C<__SUB__>

Новая лексема C<__SUB__> доступна при подключении функционала
C<current_sub> (смотрите L<feature>) или C<use v5.16>, возвращает
ссылку на текущую подпрограмму, позволяя проще писать рекурсивные
замыкания.

=head2 Новые и Улучшенные Встроенные Функции

=head3 Более логичный C<eval>

Оператор C<eval> иногда воспринимает аргумент строку как
последовательность символов, а иногда как последовательность байтов,
в зависимости от внутренней кодировки. Предполагалось, что внутренняя
кодировка ни на что не должна влиять, но есть код, который зависит от
данной несообразности.

Новые функционалы C<unicode_eval> и C<evalbytes> (включаются при C<use
5.16.0>) решают эту проблему.  Функционал C<unicode_eval> заставляет
C<eval $string> всегда воспринимать строку как Юникод.  Функционал
C<evalbytes> предоставляет функцию, названную C<evalbytes>, которая
обрабатывает аргумент как байтовую строку.

Этот функционал также исправляет странности с фильтрами исходного кода,
протекающих во внешний динамический контекст.

Смотрите подробности в L<feature>.

=head3 Исправление lvalue в C<substr>

=for comment Должно ли это быть здесь или в разделе Несовместимые Изменения?

Когда C<substr> вызывается в lvalue или потенциально lvalue контексте с 
двумя или тремя аргументами, возвращается специальный lvalue скаляр,
который изменяет оригинальную строку (первый аргумент) во время присвоения
ему значения.

Раньше смещение (второй и третий аргументы), передаваемое в C<substr>,
немедленно преобразовывались относительно текущей строки, отрицательные
смещения транслировались в положительные, а смещения за пределами строки
усекались.

Сейчас смещение записывается без изменений в специальный lvalue скаляр,
который возвращается, а оригинальная строка даже не просматривается в
C<substr>, но только до тех пор пока возвращённый lvalue не
просматривается или меняется.

Эти исправления приводят к несовместимому изменению:

Если оригинальная строка изменяет длину после вызова C<substr>, но
до присвоения к её возвращённому значению, отрицательное смещение
запоминает свою позицию от конца строки, влияя на подобный код:

    my $string = "string";
    my $lvalue = \substr $string, -4, 2;
    print $lvalue, "\n"; # напечатает "ri"
    $string = "bailing twine";
    print $lvalue, "\n"; # напечатает "wi"; раньше печатало "il"

То же самое происходит с опущенным третьим аргументом.  Возвращённое
lvalue всегда будет расширяться до конца строки даже если строка
становится больше.

Так как это изменение также позволяет исправить множество багов (смотри
L</Оператор C<substr>>), и так как такое поведение с отрицательными
смещениями никогда не было задокументировано, то это изменение посчитали
приемлемым.

=head3 Возвращаемое значение C<tied>

Значение, возвращаемое C<tied> на связанной переменной, является
скаляром, который содержит объект, с которым связана переменная. Это
позволяет применять к ней weaken C<Scalar::Util::weaken(tied
$tied_variable)>.

=head2 Поддержка Юникода

=head3 Поддерживается (I<почти>) Юникод 6.1

Помимо добавления целых новых скриптов и новых символов в существующих
скриптах, эта новая версия Юникода, как обычно, делает некоторые
изменения в существующих символах.  Есть изменение, которое может
поставить подножку некоторым приложениям: Общая Категория двух
символов в диапазоне Latin-1, PILCROW SIGN и SECTION SIGN, изменилась
с Other_Symbol на Other_Punctuation.  Такое же изменение было сделано
для символа в Тибетском, Эфиопском и Эгейском.
Коды U+3248..U+324F (CIRCLED NUMBER TEN ON BLACK SQUARE по CIRCLED
NUMBER EIGHTY ON BLACK SQUARE) изменили свою Общую Категорию с
Other_Symbol на Other_Numeric.  Свойство Переноса Строки получило
изменение для Иврита и Японского; и как следствие других изменений в
6.1, конструкция регулярных выражений Perl C<\X> сейчас работает
по другому для некоторых символов Тайского и Лао.

Были определены новые псевдонимы (синонимы) для многих значений свойств;
они, вместе с ранее существовавшими, все проиндексированы в разделе
L<perluniprops>.

Возвращаемое значение C<charnames::viacode()> затронуто другими
изменениями:

 Код символа    Старое Имя            Новое Имя
   U+000A    LINE FEED (LF)        LINE FEED
   U+000C    FORM FEED (FF)        FORM FEED
   U+000D    CARRIAGE RETURN (CR)  CARRIAGE RETURN
   U+0085    NEXT LINE (NEL)       NEXT LINE
   U+008E    SINGLE-SHIFT 2        SINGLE-SHIFT-2
   U+008F    SINGLE-SHIFT 3        SINGLE-SHIFT-3
   U+0091    PRIVATE USE 1         PRIVATE USE-1
   U+0092    PRIVATE USE 2         PRIVATE USE-2
   U+2118    SCRIPT CAPITAL P      WEIERSTRASS ELLIPTIC FUNCTION

Perl примет любое из этих имён на входе, но C<charnames::viacode()>
сейчас возвращает новое имя каждой пары.  Изменение для U+2118
рассматривается в Юникоде как коррекция, т.к. предыдущее имя было
ошибкой (повторю снова, старое имя навсегда останется действительным
для использования для обозначения U+2118).  Но большая часть этих
изменений следствие ошибок в Юникоде 6.0 сделанных в именовании
символов, используемых в японских телефонах для обозначения "BELL"
(звонок), которое конфликтует с уже продолжительно используемым в
индустрии (и рекомендуемым Юникодом для использования) этого имени
для обозначения управляющего символа ASCII U+0007.  Как результат,
это имя было признано устаревшим в Perl, начиная с v5.14; и любое
использование приводило к выводу предупреждения (если не отключено).
Имя "ALERT" теперь является предпочтительным для этого кода с
возможностью использования "BEL" как краткой формы.  Имя нового
символа сотового телефона с кодом U+1F514 остаётся неопределённым в
текущей версии Perl (поэтому мы и не можем сказать, что полностью
реализовали весь Юникод 6.1), но начиная с v5.18, BELL будет означать
этот символ, а не U+0007.

Юникод предпринял шаги для того, чтобы быть уверенным, что подобные
ошибки больше не произойдут.  Стандарт сейчас включает все
общепринятые имена и аббревиатуры для управляющих символов, тогда как
раньше он этого не делал (хотя были рекомендуемые имена для
большинства из них, которые использовал Perl).  Это означает, что
большая часть этих рекомендованных имён сейчас официально включены в
Стандарт.  У Юникода не было рекомендаций к именам для четырёх кодов
указанных выше между U+008E и U+008F, и, стандартизируя их, Юникод
изменил имена, которые Perl ранее выбрал для них, заменив финальный
пробел на дефис.  Юникод также официально принял имена, которые Perl
признал устаревшими, такие как FILE SEPARATOR. Сейчас только одно имя
является устаревшим - BELL. Наконец, Perl сейчас использует новые
официальные имена вместо старых (которые считаются вышедшими из
употребления) имён для первых четырёх кодов в списке упомянутом выше
(те которые имели скобки внутри)

Сейчас эти имена попали в стандарт Юникода и подобные изменения больше
не должны происходить, хотя коррекции, как с U+2118, тем не менее
возможны.

Юникод также добавил некоторые аббревиатуры, которые Perl сейчас также
принимает:

SP для SPACE;
TAB для CHARACTER TABULATION;
NEW LINE, END OF LINE, NL, и EOL для LINE FEED;
LOCKING-SHIFT ONE для SHIFT OUT;
LOCKING-SHIFT ZERO для SHIFT IN;
и ZWNBSP для ZERO WIDTH NO-BREAK SPACE.

Детальную информацию об этой версии Юникода можно найти в 
L<http://www.unicode.org/versions/Unicode6.1.0/>.

=head3 C<use charnames> больше не требуется для C<\N{I<name>}>

Когда встречается C<\N{I<name>}>, модуль C<charnames> автоматически
загружается при необходимости с заданными C<:full> и C<:short> опциями.
Смотрите подробности в разделе L<charnames>.

=head3 C<\N{...}> может использовать неточные совпадения имён Юникода

Это описано в разделе C<charnames> в L</Обновлённые Модули и Прагмы>
ниже.

=head3 Юникод в Именах Символов

Сейчас Perl имеет корректную поддержку Юникода для имён символов.
Раньше считалось, что C<*{$foo}> будет игнорировать внутренний UTF8
флаг и использовать байтовое представление для определения символа. Это
означало, что C<*{"\x{100}"}> и C<*{"\xc4\x80"}> возвращали одно и
то же. Все эти части Perl были исправлены для соответствия стандарту
Юникод:

=over

=item *

Имена Методов (включая те, которые передаются в C<use overload>)

=item *

Имена Typeglob (включая имена переменных, подпрограмм и файловых
дескрипторов)

=item *

Имена Модулей

=item *

C<goto>

=item *

Символическое разыменование

=item *

Второй аргумент для C<bless()> и C<tie()>

=item *

Возвращаемое значение C<ref()>

=item *

Прототипов подпрограмм

=item *

Атрибуты

=item *

Различные сообщения предупреждений и ошибок, которые содержат имена
переменных или значения, методы и т.д.

=back

Также был исправлен баг в парсере, который препятствовал неявному
экранирования имени в C<*{é}>, вместо чего интерпретировался как C<*{+é}>,
что приводило к ошибке в режиме strict.

В C<*{"*a::b"}> автоматически удаляется * если за ним следует ASCII
буква. Сейчас это правило распространяется на все буквенные символы
Юникода.

Односимвольные переменные не ASCII и не символы пунктуации (такие
как C<$é>) сейчас могут генерировать предупреждение "Использовалось
только один раз" в соответствующих ситуациях. Ранее они являлись
исключениями, т.к. считались пунктуационными переменными.

Также теперь поддерживаются односимвольные пунктуационные переменные
(такие как C<$‰>) [perl #69032].

=head3 Улучшенная возможность смешивать локали и Юникод, включая UTF-8 локали

Дополнительный параметр добавлен к C<use locale>

 use locale ':not_characters';

который сообщает Perl, что надо использовать все кроме C<LC_CTYPE> и
C<LC_COLLATE> частей текущей локали.  Взамен набор символов предполагается
Юникодом.  Это позволяет локалям и Юникоду быть легко смешанными,
включая всё более часто используемые UTF-8 локали. При использовании
таких гибридных форм локали, может использоваться слой C<:locale> для
прагмы L<open> для взаимодействия с файловой системой, и доступные модули
CPAN для преобразования ARGV и переменных окружения.

Больше деталей в L<perllocale>.

=head3 Новая функция C<fc> и соответствующая экранирующая последовательность C<\F> для Юникод foldcase 

Юникод foldcase это расширение для lowercase, которое даёт лучшие
результаты при регистронезависимом сравнении двух строк. Это давно
использовалось внутренне в регулярных выражениях для поиска совпадений
C</i>.  Сейчас это доступно непосредственно через новый вызов функции
C<fc> (включаемый S<C<"use feature 'fc'">>, или C<use v5.16>, или
явно через вызов C<CORE::fc>) или через новую C<\F> последовательность
в строках с двойными кавычками.

Все подробности в L<perlfunc/fc>.

=head3 Теперь поддерживается свойство Юникод C<Script_Extensions>.

Новое в Юникод 6.0, это улучшенное свойство C<Script>. Детали описаны
в разделе L<perlunicode/Scripts>.

=head2 Изменения в XS

=head3 Улучшенные typemaps для Некоторых Встроенных Типов

Большинство авторов XS в курсе существования давнего бага в OUTPUT
typemap для T_AVREF (C<AV*>), T_HVREF (C<HV*>), T_CVREF (C<CV*>),
и T_SVREF (C<SVREF> илиr C<\$foo>), который требует вручную уменьшать
число ссылок возвращаемого значения вместо того, чтобы typemap сам
позаботился об этом.  Для обратной совместимости это не может быть
изменено в typemap'ах по умолчанию. Но сейчас мы предоставляем
дополнительные typemap'ы C<T_AVREF_REFCOUNT_FIXED> и подобные, которые
не страдают от этого бага.  Использовать их в ваших расширениях также
просто, как иметь дополнительную строку в секции C<TYPEMAP>:

  HV*	T_HVREF_REFCOUNT_FIXED

=head3 C<is_utf8_char()>

Доступная в XS функция C<is_utf8_char()>, при получении на вход специально
сформированной UTF-8 строки, может прочитать на 12 байт за пределы конца
строки.  Это не может быть исправлено без изменения её API.  Функция не
используется на CPAN.  Сейчас в документации описано как безопасно её
использовать.

=head3 Добавлена C<is_utf8_char_buf()>

Эта функция предназначена для замены устаревшей функции
L</is_utf8_char()>. Она включает дополнительный параметр, чтобы быть
уверенным в том, что она не читает за пределами входного буфера.

=head3 Другие C<is_utf8_foo()> функции, так и C<utf8_to_foo()>, т.д..

Большая часть других XS-вызываемых функций, которые получают на вход
UTF-8 кодированную строку предполагают, что UTF-8 полностью корректен
(не искажён) в отношении длины буфера.  Не делайте никаких действий,
таких как изменение регистра символа или проверки является ли он
буквоцифровым символом, без предварительной проверки, что UTF-8 строка
корректна.  Это может быть безопасно выполнено для целых строк при
помощи одной из функций C<is_utf8_string()>, C<is_utf8_string_loc()>,
и C<is_utf8_string_loclen()>.

=head3 Новое Pad API

Много новых функций было добавлено в API для манипуляции с лексическими
панелями.  Смотрите больше информации в L<perlapi/Pad Data Structures>.

=head2 Изменения в Специальных Переменных

=head3 C<$$> можно присваивать значения

C<$$> была сделана доступной только на чтение в Perl 5.8.0.  Но иногда:
C<local $$> делал её доступной для записи снова.  Некоторые CPAN модули
использовали C<local $$> или XS код, чтобы обойти проверку на доступность
только на чтение, поэтому нет никакого смысла оставлять C<$$> доступной
только на чтение.  (Это изменение также позволило исправить баг при
сохранении обратной совместимости)

=head3 C<$^X> преобразуется в абсолютный путь на FreeBSD, OS X и Solaris

Сейчас C<$^X> преобразуется в абсолютный путь на OS X, FreeBSD (без
необходимости монтировать F</proc>) и Solaris 10 и 11. Это улучшает
предыдущий подход по использованию F</proc> on Linux, FreeBSD and NetBSD
(во всех случаях, когда он смонтирован).

Это делает перемещаемые инсталляции perl более полезными на данных
платформах. (Смотри "Перемещаемый @INC" в F<INSTALL>)

=head2 Изменения в Отладчике

=head3 Функции (features) внутри отладчика

Текущий набор L<feature> Perl'а стал доступен для команд вводимых в отладчике
в интерактивном режиме.

=head3 Новая опция для команды отладчика B<t>

Команда отладчика B<t>, которая переключает режим трассировки, сейчас
принимает числовой аргумент, который определяет как много уровней
вызовов подпрограмм надо отслеживать.

=head3 C<enable> и C<disable>

В отладчике появились команды C<disable> и C<enable> для отключения существующих
точек останова и повторного включения их.  Смотрите L<perldebug>.

=head3 Точки останова с именами файлов

Команда отладчика "b" для установки точки останова теперь позволяет
указывать префиксом к номеру строки имя файла. Смотрите
L<perldebug/"b [file]:[line] [condition]">.

=head2 Пространство имён C<CORE>

=head3 Префикс C<CORE::>

Префикс C<CORE::> теперь может быть использован в ключевых словах
подключаемых через L<feature.pm|feature> даже вне контекста C<use feature>.

=head3 Подпрограммы в пространстве имён C<CORE>

Многие ключевые слова Perl теперь доступны как подпрограммы в пространстве
имён CORE. Это позволяет задавать для них псевдонимы:

    BEGIN { *entangle = \&CORE::tie }
    entangle $variable, $package, @args;

и для обхода прототипов:

    sub mytie(\[%$*@]$@) {
	my ($ref, $pack, @args) = @_;
	... do something ...
	goto &CORE::tie;
    }

Некоторые из них не могут быть вызваны через ссылки или через C<&foo>
синтаксис и должны вызываться только как bareword

Смотрите подробности в L<CORE>.

=head2 Другие изменения

=head3 Анонимные дескрипторы

Автоматически генерируемые файловые дескрипторы теперь именуются
__ANONIO__, когда имя переменной не может быть определено лучше
чем $__ANONIO__.

=head3 Автозагружаемые подпрограммы сортировки

Пользовательские подпрограммы сортировки теперь могут быть
автоматически загружены [perl #30661]:

    sub AUTOLOAD { ... }
    @sorted = sort foo @list; # uses AUTOLOAD

=head3 C<continue> больше не требует подключения "switch" функционала

Ключевое слово  C<continue> имеет два смысла. Оно может представлять
C<continue> блок после цикла или может использоваться для выхода из
текущего блока C<when>. До этого момента, последний смысл был
допустимым только при включения функционала "switch", и являлось
синтаксической ошибкой в противном случае.  Поскольку основное
назначение модуля feature.pm - это избежание конфликтов с определёнными
пользователем именами подпрограммам, никаких причин для C<continue>
зависеть от него нет.

=head3 Замеры DTrace при изменении фазы интерпретатора

Замеры C<phase-change> стартуют когда происходит смена фазы
интерпретатора, которая отслеживается в переменной C<${^GLOBAL_PHASE}>.
C<arg0> - это новое имя фазы; C<arg1> - старое имя фазы.  Это полезно
в основном для ограничения набора вашего инструментария одним или
несколькими частями: время компиляции, время работы, время уничтожения.

=head3 Синтаксис C<__FILE__()>

Лексемы C<__FILE__>, C<__LINE__> и C<__PACKAGE__> теперь могут быть
записаны с пустой парой скобок после них.  Это делает возможным парсинг
тем же образом, что и C<time>, C<fork> и другие встроенные функции.

=head3 Прототип C<\$> принимает любое скалярное lvalue

Прототипы подпрограмм C<\$> и C<\[$]> теперь принимают любой скалярный
lvalue аргумент.  Раньше они принимали только скаляры начинающиеся с C<$>
и элементы хэша и массива.  Это изменение согласовывает их поведение с
встроенными C<read> и C<recv> функциями при разборе их аргументов.  Это
означает, что можно переопределить встроенные функции пользовательской
подпрограммой, которая тем же образом разбирает свои аргументы.

=head3 C<_> в прототипах подпрограмм

Символ C<_> в прототипах подпрограмм теперь разрешён перед C<@> или C<%>.

=head1 Безопасность

=head2 Используйте C<is_utf8_char_buf()> вместо C<is_utf8_char()>

Первая функция теперь является устаревшей, поскольку её API недостаточен
для гарантии того, что она не прочитает (до 12 байт в худшем случае) за
пределами входной строки. Смотрите
L<is_utf8_char_buf()|/Added is_utf8_char_buf()>.

=head2 Искажённый UTF-8 ввод может привести к попыткам чтения за пределами буфера

Две новые XS-доступные функции, C<utf8_to_uvchr_buf()> и
C<utf8_to_uvuni_buf()> теперь доступны для предотвращения этого и ядро
Perl уже перешло на их использование.
Смотрите L</Внутренние Изменения>.

=head2 C<File::Glob::bsd_glob()> ошибка памяти с GLOB_ALTDIRFUNC (CVE-2011-2728).

Вызов C<File::Glob::bsd_glob> с не поддерживаемым флагом GLOB_ALTDIRFUNC
может привести нарушению доступа / сегфолту.  Perl программа, которая
получает значение флагов из внешнего источника может быть подвержена атакам
на отказ в обслуживании или выполнения произвольного кода.  Пока не известно
о существовании действующих эксплойтов.  Проблема была исправлена явным
запретом всех не поддерживаемых флагов и установкой незадействованных
указателей функций в null.  О баге сообщил Clément Lecigne.

=head2 Теперь привилегии выставляются коректно при присваивании C<$(>

Был исправлен гипотетический баг (вероятно невозможный для применения
на практике) вследствие некорректной установки ID эффективной группы
при задании C<$(>.  Баг возможен только на системах, которые имеют
C<setresgid()>, но не имеют C<setregid()>, но ни об одной такой системе
нам неизвестно.

=head1 Устаревшее

=head2 Не читайте файлы данных Юникода в F<lib/unicore>

Теперь прямое обращение к файлам данных Юникода не рекомендуется. Они
хранятся в каталоге F<lib/unicore>.  Вместо этого вы должны использовать
новые функции в L<Unicode::UCD>.  Они предоставляют стабильное API и
дают исчерпывающую информацию.

Perl может с какого-то момента в будущем изменить или удалить данные
файлы. Вероятно наиболее используемым файлом был
F<lib/unicore/ToDigit.pl>. Вместо этого можно использовать функцию
L<Unicode::UCD/prop_invmap()> для получения этих данных.

=head2 XS функции C<is_utf8_char()>, C<utf8_to_uvchr()> и
C<utf8_to_uvuni()>

Эта функция не рекомендуется, поскольку она может попытаться прочитать
данные за пределами входной строки.  Используйте вместо них новые функции
L<is_utf8_char_buf()|/Добавлена is_utf8_char_buf()>, C<utf8_to_uvchr_buf()>
и C<utf8_to_uvuni_buf()>.

=head1 Устаревающий Функционал

Эта секция служит для уведомления о функционале, который I<вероятно> будет
удалён или L<устареет|perlpolicy/deprecated> в следующем релизе perl
(5.18.0).  Если ваш код зависит от этого функционала, вы должны
связаться с Perl 5 Porters через
L<список рассылки|http://lists.perl.org/list/perl5-porters.html> или
L<perlbug> для того, чтобы объяснить ваш конкретный случай и информировать
процесс отказа.

=head2 Базовые Модули

Эти модули могут быть помечены как устаревшие I<из ядра>.  Это всего лишь
означает, что они больше не будут устанавливаться по умолчанию с базовым
дистрибутивом, но по прежнему будут доступны на CPAN.

=over

=item *

CPANPLUS

=item *

Filter::Simple

=item *

PerlIO::mmap

=item *

Pod::Parser, Pod::LaTeX

=item *

SelfLoader

=item *

Text::Soundex

=item *

Thread.pm

=back

=head2 Платформы, для которых нет поддерживающих программистов:

Поддержка сборки для этих платформ вероятно будет удалена в
ветке разработки 5.17.0.

=over

=item *

BeOS

=item *

djgpp

=item *

dgux

=item *

EPOC

=item *

MPE/iX

=item *

Rhapsody

=item *

UTS

=item *

VM/ESA

=back

=head2 Прочий устаревающий Функционал

=over

=item *

Обмен $< и $>

Для большей информации об устаревании этого функционала смотрите
L<относящийся к проблеме баг в RT|https://rt.perl.org/rt3/Ticket/Display.html?id=96212>.

=item *

sfio, stdio

=item *

Не экранированный литерал C<< "{" >> в регулярном выражении.

Запланировано, начиная с v5.20, требовать экранирование литерала  C<"{">,
например, предшествующим символом обратного слэша. В v5.18 будет выводиться
предупреждение для всех подобных случаев.  Следует отметить, что это касается
только случаев когда в шаблоне ищутся совпадения с литералом C<"{">.
Другие виды использования этого символа, такие как часть квантора или
последовательности, приведённые ниже, не затронуты этим изменением:

    /foo{3,5}/
    /\p{Alphabetic}/
    /\N{DIGIT ZERO}

Удаление этого позволит делать расширения для синтаксиса шаблонов и лучше
делать проверки на ошибки в существующем синтаксисе.  Смотрите
L<perlre/Quantifiers> для примера.

=back

=head1 Несовместимые изменения

=head2 Специальные блоки вызываются в пустом контексте

Специальные блоки (C<BEGIN>, C<CHECK>, C<INIT>, C<UNITCHECK>, C<END>) теперь
вызываются в пустом контексте.  Это позволяет избежать расточительного
копирования результатов последнего оператора [perl #108794].

=head2 Прагма C<overloading> и объекты regexp

С C<no overloading>, объекты регулярного выражения возвращаемые C<qr//>
теперь преобразуются к строке вида "Regexp=REGEXP(0xbe600d)" вместо
самого регулярного выражения [perl #108780].

=head2 Удалены две записи XS typemap 

Две, предположительно неиспользуемые, XS typemap записи были удалены
из базовых typemap: T_DATAUNIT и T_CALLBACK. Если вы против изменений,
пользователь этих typemap, пожалуйста смотрите инструкцию о том как
вернуть их в L<perlxstypemap>.

=head2 Юникод 6.1 имеет несовместимости с Юникод 6.0

Они детально описаны в L</Поддержка (почти) Юникода 6.1> выше.
Вы можете скомпилировать эту версию Perl для работы с Юникод 6.0.
Смотрите
L<perluniprops/Unicode character properties that are NOT accepted by Perl>.

=head2 Компилятор Borland

Вся поддержка компилятора Borland была выкинута. В любом случае этот код
не работал уже достаточно долгое время.

=head2 Некоторые устаревшие свойства в Юникоде больше не поддерживается

Perl никогда не раскрывает некоторые свойства Юникода, которые
используются в Юникоде для внутренних целей и не предполагают публичной
доступности.  Использование их приводило к генерации сообщения
предупреждения начиная с Perl 5.12.  Удалены следующие свойства
Other_Alphabetic, Other_Default_Ignorable_Code_Point, Other_Grapheme_Extend,
Other_ID_Continue, Other_ID_Start, Other_Lowercase, Other_Math, и
Other_Uppercase.

Perl может быть пересобран для включения любой из них; инструкции
даны в 
L<perluniprops/Unicode character properties that are NOT accepted by Perl>.

=head2 Разыменование IO сущностей как typeglob'ов

Оператор C<*{...}> при передаче ссылки на IO сущность (как
C<*{*STDIN{IO}}>), создаёт новый typeglob содержащий только это IO объект.
Ранее, он приводил в строковой вид как пустую строку, но некоторые
операторы могли их воспринимать как неопределённое значение, выдавая
предупреждение о не инициализированном значении.
Теперь это приводится к строке вида __ANONIO__ [perl #96326].

=head2 Определённые пользователем операции изменяющие регистр

Этот функционал являлся устаревшим в Perl 5.14 и сейчас был удалён.
Модуль CPAN L<Unicode::Casing> предоставляет лучшую функциональность
без недостатков, которые были свойствены этому функционалу, изложенные
в документации 5.14:
L<http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29>

=head2 XSUB'ы теперь статические

XSUB C функции теперь статические (static), т.е. они не видимы за
пределами скомпилированного модуля.  Пользователи теперь могут
использовать новые макросы C<XS_EXTERNAL(name)> и C<XS_INTERNAL(name)>
для выбора предпочитаемого поведения линкера. Обычная декларация
C<XS(name)> для XSUB по прежнему создаёт нестатические XSUBs для
совместимости, но XS компилятор, C<ExtUtils::ParseXS> (C<xsubpp>)
будет создавать статические XSUB по умолчанию. Поведение
C<ExtUtils::ParseXS> может быть изменено из XS, используя ключевое
слово C<EXPORT_XSUB_SYMBOLS>.  Смотрите детали в L<perlxs>.

=head2 Ослабление (weakening) доступной только на чтение ссылки

Ослабление (weakening) доступной только на чтение ссылки больше не
позволяется.  Это в любом случае не работало, а в некоторых случаях
приводило к краху.

=head2 Связывание скаляров, которые содержат typeglob'ы

Попытка связать скаляр после того, как ему был присвоен typeglob,
вместо этого связывала дескриптор в IO слоте typelglob'а.  Это означало,
что было невозможно связать непосредственно сам скаляр.  Схожие
проблемы затрагивают и C<tied> C<untie>: C<tied $scalar> будет
возвращать ложь на связанные скаляры, если последний возвращённый объект
был typeglob'ом, и C<untie $scalar> на таком связанном скаляре не будет
делать ничего.

Мы исправили эту проблему до Perl 5.14.0, но это вызвало проблемы с
некоторыми модулями CPAN, поэтому мы поместили это изменение в цикл
устаревания.

Теперь статус устаревшего был удален и это баг был окончательно исправлен.
Т.о. C<tie $scalar> теперь всегда связывает сам скаляр, но не
содержащийся в нём дескриптор. Для связывания дескриптора используйте
C<tie *$scalar> (с явным указанием звёздочки).  Тоже самое относится к
C<tied *$scalar> и C<untie *$scalar>.

=head2 IPC::Open3 больше не предоставляет C<xfork()>, C<xclose_on_exec()>
и C<xpipe_anon()>

Все три функции были приватными, недокументированными и неэкспортируемыми.
Они не использовались в каком-либо коде на CPAN. Две из них были встроены
в код, а одна удалена полностью.

=head2 C<$$> больше не кэширует значение PID

Раньше при вызове fork(3) из C, значение C<$$> в Perl приходило в
рассинхронизацию с тем, что возвращал getpid(). Всегда получая значение
C<$$> через вызов getpid(), этот баг был исправлен. Код, который зависел
от кэширующего поведения теперь сломается.  Как описано в
L<Улучшения Ядра|/C<$$> можно присваивать значения>, C<$$> доступна для
записи, но будет сброшена при fork.

=head2 C<$$> и C<getppid()> больше не эмулируют POSIX семантику в LinuxThreads

Эмуляция POSIX C<$$> и C<getppid()> в вышедшей из употребления
реализации LinuxThreads была удалена.
Это касается только пользователей Linux 2.4 и пользователей
Debian GNU/kFreeBSD до версии 6.0 включительно, но не обширное
множество инсталляций Linux, которые используют NPTL нити.

Это означает, что C<getppid()>, как и C<$$>, теперь всегда гарантируют,
что возвращается мнение ОС о текущем состоянии процесса, а не кэшированый
в perl вариант этого мнения.

Смотрите документацию по L<$$|perlvar/$$> для подробностей.

=head2 C<< $< >>, C<< $> >>, C<$(> и C<$)> теперь больше не кэшируются

Схожее с изменениями C<$$> и C<getppid()>, внутреннее кэширование
C<< $< >>, C<< $> >>, C<$(> и C<$)> было удалено.

Когда мы закэшировали эти значения, наше представление о том, чему они
равны, могут разойтись с реальностью, если кто-либо (например,
встраивающий perl) вызовет C<sete?[ug]id()> без обновления
C<PL_e?[ug]id>. Цена учёта такой сложности не сопоставима с дешёвым
системным вызовом C<gete?[ug]id()>.

Это изменение сломает горстку модулей на CPAN, которые используют
переменные XS-уровня C<PL_uid>, C<PL_gid>, C<PL_euid> или C<PL_egid>

Исправлением для этих разломов является использование функции
C<PerlProc_gete?[ug]id()> для получения их значения (например,
C<PerlProc_getuid()>), и не присваивать значение C<PL_e?[ug]id>,
если вы хотите сменить UID/GID/EUID/EGID.  Теперь нет необходимости
делать это, так как perl всегда получает актуальные значения из ОС.

=head2 Изменился список не-ASCII символов, которые квотятся C<quotemeta> и C<\Q>

Это вряд ли приведёт к каким-то реальным проблемам, т.е. Perl не
придаёт специального значения для не-ASCII символов, поэтому не важно
какие из них квотятся, а какие нет.  Это изменение исправляет баг
[perl #77654] и делает поведение Perl более соответствующим рекомендациям
Юникода.
Смотрите L<perlfunc/quotemeta>.

=head1 Увеличение Производительности

=over

=item *

Улучшена производительность для свойств Юникода в регулярных выражениях

=for comment Может ли это быть как-то сокращено? -- rjbs, 2012-02-20

Поиск совпадений для свойств Юникода теперь производится через бинарный
поиск вместо линейного.  Это означает, что например в худшем случае поиск
1000-го свойства потребует 10 проб вместо 1000. Эта неэффективность в
прошлом была скомпенсирована постоянным хранением в хэше результата поиска
плюс результат соседних 64 кодов, в предположении, что чаще ищутся коды
расположенные рядом. Отдельный хэш использовался для каждого упоминания
свойства Юникод в каждом регулярном выражении. Таким образом
C<qr/\p{foo}abc\p{foo}/> создаст два хэша. Любой поиск в каждом случае
будет оставаться неизвестным для других и хэши будут расширяться
независимо до внушительных размеров в случае если регулярное выражение
использовалось для большого количества кодов в широком диапазоне.  В
экстремальных ситуациях это может привести к израсходованию доступной
памяти. Теперь, однако, есть только один хэш доступный всем экземплярам
данного свойства.  Это значит, что если C<\p{foo}> совпадает с "A" в
одном регулярном выражении в нити, результат станет известен немедленно
во всех регулярных выражениях и потребление памяти заметно сократится.

=item *

Определение версии с ключевым словом C<use> (например, C<use 5.012>)
теперь работает быстрее, так как включает функционал без загрузки
F<feature.pm>.

=item *

C<local $_> теперь быстрее, так как больше не проходит через магию,
которая в любом случае не приводит к копированию.

=item *

Perl 5.12.0 ускорил уничтожение объектов, чьи классы задавали пустые
C<DESTROY> методы (для предотвращения автозагрузки), просто не
запуская эти пустые методы.  Этот релиз продвигает эту оптимизацию
на шаг вперёд не вызывая любой C<DESTROY> метод, который начинается с
оператора C<return>. Это может быть полезно для деструкторов, которые
используются только для отладки:

    use constant DEBUG => 1;
    sub DESTROY { return unless DEBUG; ... }

Вычисление константы сократит первый оператор до C<return;> если DEBUG
будет установлен в 0, тем самым приводя к выполнению оптимизации.

=item *

Присвоение переменной, которая содержит typeglob или скаляр
копируемый при записи, теперь происходит гораздо быстрей.  Раньше
typeglob приводился к строке, а скаляр копируемый при записи
копировался перед изменением.

=item *

Присвоение C<substr> в пустом контексте теперь происходит в два раза
быстрее.  Вместо создания и возвращения специального lvalue скаляра,
к которому будет присваиваться результат, C<substr> изменяет саму
оригинальную строку.

=item *

C<substr> больше не вычисляет значение, которое должен вернуть, когда
вызывается в пустом контексте.

=item *

Из-за изменений в L<File::Glob>, функция Perl C<glob> и её C<< <...> >> 
эквивалент теперь значительно быстрее.  Разбитие шаблона на слова было
переписано на C, приведя к 20% ускорению в некоторых случаях.

Это не затрагивает C<glob> на VMS, т.к. там не используется File::Glob.

=item *
Укороченные логические операторы C<&&>, C<||>, и C<//>, при связке в
цепочку (как например C<$a || $b || $c>), теперь работают значительно
быстрее, вследствие укороченного обхода дерева операций.

=item *

Реализация C<s///r> делает ещё одну копию значения скаляра.

=item *

C<study> теперь ни делает ничего (no-op).

=item *

Рекурсивный вызов к lvalue подпрограмме в lvalue скалярном контексте
использует меньше памяти.

=back

=head1 Модули и Прагмы

=head2 Устаревшие Модули

=over

=item L<Version::Requirements>

Version::Requirements теперь устарел, используйте
L<CPAN::Meta::Requirements>, который является подходящей заменой. Он
будет удалён из perl.git blead в версии v5.17.0.

=back

=head2 Новые Модули и Прагмы

=over 4

=item *

L<arybase> -- этот новый модуль является реализация переменной C<$[>.

=item *

C<PerlIO::mmap> 0.010 был добавлен в базовый Perl.

Слой C<mmap> PerlIO больше не предоставляется самим perl, а был вынесен
в новый модуль L<PerlIO::mmap>.

=back

=head2 Обновлённые Модули и Прагмы

=over 4

=item *

L<XXX> был обновлён с версии 0.69 до версии 0.70.

=back

=head2 Удалённые Модули и Прагмы

Как и было обещано в заметках к выпуску Perl 5.14.0, следующие модули
были удалены из базового дистрибутива и при необходимости могут быть
установлены из CPAN.

=over

=item *

C<Devel::DProf> был удалён из базового Perl.  Предыдущая версия была
20110228.00.

=item *

C<Shell> был удалён из базового Perl.  Предыдущая версия была 0.72_01.

=back

=head1 Документация

=head2 Новая Документация

=head3 L<perldtrace>

L<perldtrace> описывает поддержку DTrace в Perl, описывает доступные пробы
и даёт примеры их использования.

=head3 L<perlexperiment>

Этот документ предназначен предоставлять список экспериментального
функционала в Perl.  Работа над ним по-прежнему продолжается.

=head3 L<perlootut>

Новое пособие по ООП.  Оно сфокусировано на базовых концепциях ООП и
позже рекомендует читателям выбрать ООП фреймворка со CPAN.

=head3 L<perlxstypemap>

Новое руководство описывает механизм соответствия типов в XS в
беспрецедентных деталях и комбинирует новую документацию с информацией
извлечённой из L<perlxs> и ранее неофициальный список всех базовых
typemap.

=head2 Изменения в Существующей Документации

=head3 L<perlapi>

=over 4

=item *

HV API давно принимало отрицательную длину для обозначения того, что
ключ в UTF8.  Теперь это задокументировано. 

=item *

Макрос C<boolSV()> теперь задокументирован.

=back

=head3 L<perlfunc>

=over 4

=item *

C<dbmopen> трактует режим 0 как особый случай, который предотвращает
создание несуществующего файла.  Это было так начиная с Perl 5.000, но
нигде не было задокументировано.  Теперь раздел perlfunc упоминает об
этом [perl #90064].

=item *

Совершенно случайно, C<open $fh, "<:", ...> применяет слой по-умолчанию
для платформ (C<:raw> на Unix, C<:crlf> на Windows), игнорируя то, что
было задано в L<open.pm|open>.  Это оказалось настолько полезным, что
было задокументировано в L<perlfunc|perlfunc/open> и L<open>.

=item *

Описание C<split> было переписано.  Теперь оно более внятное чем раньше.

=back

=head3 L<perlguts>

=over 4

=item *

Была добавлена новая секция
L<Автозагрузка с XSUB'ами|perlguts/Autoloading with XSUBs>, которая
объясняет два API для доступа к именам авто-загруженных процедур.

=item *

Некоторые описания функций в L<perlguts> были смущающими, так как не
было ясно относятся ли они к функции выше или ниже описания.  Это
было прояснено [perl #91790].

=back

=head3 L<perlobj>

=over 4

=item *

Этот документ был переписан с нуля, и его охват различных концепций ООП
был расширен.

=back

=head3 L<perlop>

=over 4

=item *

Документация оператора умного сопоставления (smartmatch) была
переработана и перемещена из perlsyn в perlop, которому он принадлежит.

Также была исправлена документация для случая C<undef> с левой стороны.
Список различного поведения умного сопоставления имел раздел не в том
месте.

=item *

Документация оператора многоточия (C<...>) была переработана и
перемещена из perlop в perlsyn.

=item *

Объяснение битовых операторов было расширено на описание того, как они
работают Юникод строками (5.14.1).

=item *

Было добавлено больше примеров для C<m//g> (5.14.1).

=item *

Синтаксис встроенной документации C<<< <<\FOO >>> был
задокументирован (5.14.1)

=back

=head3 L<perlpragma>

=over 4

=item *

Теперь есть стандартное соглашения для именования ключей в C<%^H>,
задокументированное в L<Именование ключей|perlpragma/Key naming>.

=back

=head3 L<perlsec/Laundering and Detecting Tainted Data>

=over 4

=item *

Функция в примере для проверки на taint содержала едва заметную
ошибку.  Для C<$@> требовалось быть локализованной, что избежать
изменения её глобального значения.  Предпочитаемый метод для
проверки для этого остаётся L<Scalar::Util/tainted>.

=back

=head3 L<perllol>

=over

=item *

L<perllol> был расширен примерами использующих новый C<push $scalar>
синтаксис, введённый в Perl 5.14.0 (5.14.1).

=back

=head3 L<perlmod>

=over

=item *

L<perlmod> теперь точно формулирует, что некоторые типы явных манипуляций с
таблицей символов не поддерживаются.  Это систематизирует то, что уже было
фактом [perl #78074].

=back

=head3 L<perlpodstyle>

=over 4

=item *

Были поправлены и широко дополнены советы о том, какие использовать
форматирующие коды.

=item *

Теперь появились несколько примеров однострочников для предпросмотра
POD файлов после того как они были отредактированы.

=back

=head3 L<perlre>

=over

=item *

Директива C<(*COMMIT)> теперь перечислена в нужной секции
(L<Глаголы без аргумента|perlre/Verbs without an argument>).

=back

=head3 L<perlrun>

=over

=item *

L<perlrun> подвергся значительной чистке.  Особенно,
B<-0x...> форма B<-0> флага была пояснена и финальная секция об
переменных окружения была исправлена и расширена (5.14.1).

=back

=head3 L<perlsub>

=over

=item *

Синтаксис прототипа ($;), который существовал достаточно долгое время,
теперь задокументирован в L<perlsub>. Он позволяет унарным функциям
иметь такой же приоритет операции, что и оператор списка.

=back

=head3 L<perltie>

=over

=item *

Требуемый синтаксис для связанных дескрипторов был задокументирован.

=back

=head3 L<perlvar>

=over

=item *

Документация для L<$!|perlvar/$!> была исправлена и разъяснена. Было
сформулировано, что $! может быть C<undef>, что не так. Также было неясно
что устанавливает системный вызов: C<errno> в C или C<$!> в Perl
[perl #91614].

=item *

Документация для L<$$|perlvar/$$> была поправлена с дополнительными
предостережениями, касающиеся изменения ID процесса.

=back

=head3 Другие изменения

=over 4

=item *

L<perlxs> был расширен документаций о встраиваемых typemap'ах.

=item *

L<perlref> получил новую секцию
L<Циклические Ссылки|perlref/Circular References>, которая объясняет
как такие циклы могут не освобождаться и как решать это с помощью
слабых ссылок.

=item *

Части L<perlapi> были прояснены и Perl эквиваленты некоторых
C функций были добавлены как дополнительный способ объяснения.

=item *

Некоторые разделы L<perlre> и L<perlrecharclass> были улучшены.

=back

=head2 Удалённая Документация

=head3 Старая ООП Документация

Вся старые ООП пособия, perltoot, perltooc, и perlboot были удалены.
perlbot (набор рецептов по объектов) также был удалён.

=head3 Дельты Разработки

Файлы perldelta для выпусков для разработчиков больше не пакуются с perl.
Они по-прежнему могут быть найдены в репозитории исходного кода.

=head1 Диагностика

Следующие дополнения или изменения были сделаны с диагностическим
выводом, включая предупреждения и сообщения о фатальных ошибках. Для
полного списка диагностических сообщений смотрите L<perldiag>.

=head2 Новая диагностика

=head3 Новые Ошибки

=over 4

=item *

L<Cannot set tied @DB::args|perldiag/"Cannot set tied @DB::args">

Эта ошибка возникает, когда C<caller> пытается установить C<@DB::args>,
но обнаруживает, что тот связанный.  Раньше, до добавления этой ошибки,
он просто падал.

=item *

L<Cannot tie unreifiable array|perldiag/"Cannot tie unreifiable array">

Эта ошибка часть проверки на безопасность, которую оператор C<tie>
выполняет перед связыванием специальный массивов типа C<@_>.  Вы никогда
не должны увидеть это сообщение.

=item *

L<&CORE::%s cannot be called directly|perldiag/"&CORE::%s cannot be called directly">

Это происходит, когда подпрограмма из пространства имён C<CORE::>
вызывается с использованием синтаксиса C<&foo> или через ссылку.
Некоторые подпрограммы в этом пакете не могут пока вызываться таким
образом и должны вызываться как bareword. Смотрите
L</Подпрограммы в пространстве имён C<CORE>> выше.

=item *

L<Source filters apply only to byte streams|perldiag/"Source filters apply only to byte streams">

Эта новая ошибка возникает, когда вы пытаетесь активировать фильтр
исходного кода (обычно при загрузке модуля фильтра кода) со строкой
переданной в C<eval> во время действия функционала C<unicode_eval>.

=back

=head3 Новые Предупреждения

=over 4

=item *

L<defined(@array) is deprecated|perldiag/"defined(@array) is deprecated">

Давно устаревший C<defined(@array)> теперь также выдаёт предупреждения для
переменных пакета.  Ранее предупреждение выдавалось только для лексических
переменных.

=item *

L<length() used on %s|perldiag/length() used on %s>

Это новое предупреждение возникает, когда C<length> используется на массивах
или хэшах, вместо C<scalar(@array)> или C<scalar(keys %hash)>.

=item *

L<lvalue attribute %s already-defined subroutine|perldiag/"lvalue attribute %s already-defined subroutine">

L<attributes.pm|attributes> теперь выводит предупреждение, когда атрибут
:lvalue применяется к Perl подпрограмме, которая уже была определена и
выполнение этой операции может привести к непредсказуемым побочным эффектам.

=item *

L<overload arg '%s' is invalid|perldiag/"overload arg '%s' is invalid">

This warning, in the "overload" category, is produced when the overload
pragma is given an argument it doesn't recognize, presumably a mistyped
operator.

=item *

L<$[ used in %s (did you mean $] ?)|perldiag/"$[ used in %s (did you mean $] ?)">

Это новое предупреждение предназначено отлавливать ошибочное использование
C<$[> в проверках версии. C<$]>, а не C<$[> содержит значение версии.

=item *

L<Useless assignment to a temporary|perldiag/"Useless assignment to a temporary">

Присвоение временному скаляру, возвращаемому из lvalue подпрограммы,
теперь выводит это предупреждение [perl #31946].

=item *

L<Useless use of \E|perldiag/"Useless use of \E">

C<\E> ни делает ничего, если не предварён C<\Q>, C<\L> или C<\U>.

=back

=head2 Удалённые Ошибки

=over

=item *

"sort is now a reserved word"

Эта ошибка использовалась, когда sort вызывался без аргументов с
последующими символами C<;> или C<)>. (Например, C<sort;> умрёт,
а C<{sort}> нет).  Это сообщение об ошибке было добавлено в Perl 3
для выявления кода, типа C<close(sort)>, который больше не работает.
Два десятка лет спустя, это сообщение больше неуместно. Теперь C<sort>
без аргументов всегда допустим и возвращает пустой список, как он
это и делал в подобных случаях, в которых он уже был разрешён
[perl #90030].

=back

=head2 Изменения в Существующей Диагностике

=over 4

=item *

"Applying pattern match..." или подобные предупреждения вызываемые,
когда массив или хэш находится по левую сторону оператора C<=~>,
теперь упоминают имя переменной.

=item *

В сообщении "Attempt to free non-existent shared string" было
исправлено написание "non-existent" как "nonexistent".  Это было
уже исправлено в описании в L<perldiag>.

=item *

Сообщение об ошибке при использовании C<default> и C<when> вне
блока было стандартизовано для соответствия сообщениям для C<continue>
и управляющих циклом.  Теперь они читаются 'Can't "default" outside a
topicalizer' и 'Can't "when" outside a topicalizer'.  Ранее они оба 
имели вид 'Can't use when() outside a topicalizer' [perl #91514].

=item *

Сообщение "Code point 0x%X is not Unicode, no properties match it;
all inverse properties do" было изменено на "Code point 0x%X is not
Unicode, all \p{} matches fail; all \P{} matches succeed".

=item *

Предупреждения о переопределении для постоянных подпрограмм было
обязательным, и происходили даже при C<no warnings>.  Теперь они
соблюдают требования прагмы L<warnings>. 

=item *

Предупреждение "glob failed" теперь подавляется при C<no warnings>
[perl #111656].

=item *

Сообщение об ошибке
L<Invalid version format|perldiag/"Invalid version format (%s)">
теперь говорит о "negative version number" (отрицательный номер версии)
в скобках, вместо "non-numeric data" (не числовые данные) для
отрицательных чисел.

=item *

Два предупреждения
L<Possible attempt to put comments in qw() list|perldiag/"Possible attempt to put comments in qw() list">
и
L<Possible attempt to separate words with commas|perldiag/"Possible attempt to separate words with commas">
больше не взаимоисключающие: один и тот же C<qw> может вывести оба.

=item *

Предупреждение о не инициализированном значении для C<y///r>, когда C<$_>
используется неявно и неопределенно, теперь упоминает имя переменной,
также как и для вариант оператора без /r .

=item *

Предупреждение 'Use of "foo" without parentheses is ambiguous' (
Использование "foo" без скобок двусмысленно) было расширенно для
случая пользовательских подпрограмм с прототипом (;$), а не только
встроенных функций.

=item *

Предупреждения, в которых упоминаются лексических переменных (C<my>) с
символами Юникода учитывают наличие или отсутствие слоя C<:utf8> на
дескрипторе вывода вместо вывода в UTF8, не обращая на это внимание.
Также правильные имена включаются в строки передаваемые в
дескрипторы C<$SIG{__WARN__}>, вместо необработанных UTF8 байтов.

=back

=head1 Изменения в Утилитах

=head3 L<h2ph>

=over 4

=item *

L<h2ph> генерировал код в следующей форме

  unless(defined(&FOO)) {
    sub FOO () {42;}
  }

Но объявление подпрограмм происходит при компиляции и поэтому условие
на это не влияет.  Теперь это было исправлено заключением подпрограммы
в блок C<eval> [perl #99368].

=back

=head3 L<splain>

=over 4

=item *

F<splain> больше не выводит трассировки с повторяющейся первой строкой.

Было:

    Uncaught exception from user code:
            Cannot fwiddle the fwuddle at -e line 1.
     at -e line 1
            main::baz() called at -e line 1
            main::bar() called at -e line 1
            main::foo() called at -e line 1

Стало:

    Uncaught exception from user code:
            Cannot fwiddle the fwuddle at -e line 1.
            main::baz() called at -e line 1
            main::bar() called at -e line 1
            main::foo() called at -e line 1

=item *

Некоторые сообщения об ошибках состоявшие из нескольких строк
указаны в разных разделах в L<perldiag>. splain пытался найти отельный
раздел, включающий все строки, вместо того, чтобы просто найти
сообщение.

=back

=head3 L<zipdetails>

=over 4

=item *

Это новая утилита, включённая как часть обновления L<IO::Compress::Base>

L<zipdetails> показывает информацию о внутренней структуре записи zip
файла.  Она не имеет отношения к деталям сжатых данных, сохранённых в
zip файле.

=back

=head1 Конфигурация и Компиляция

=over 4

=item *

F<regexp.h> был модифицирован для совместимости с опцией B<-Werror> GCC,
используемый некоторыми проектами, которые включают заголовочные файлы
perl (5.14.1)

=item *

C<USE_LOCALE{,_COLLATE,_CTYPE,_NUMERIC}> были добавлены в вывод perl -V
так как они влияют на поведение исполняемого файла интерпретатора (хотя
только в небольших областях).

=item *

Код и тесты для L<IPC::Open2> были перенесены из F<ext/IPC-Open2> в
F<ext/IPC-Open3>, так как C<IPC::Open2::open2()> реализована как тонкая
обёртка вокруг C<IPC::Open3::_open3()> и следовательно очень тесно связана
с ней.

=item *

Магические типы и магические vtables теперь генерируются из данных в новом
скрипте F<regen/mg_vtable.pl>, вместо того, чтобы сопровождаться в ручную.
Так как различные варианты EBCDIC не согласуются с кодом для '~',
конвертирование символа в код производится во время сборки F<generate_uudmap>
в новые генерируемые заголовок F<mg_data.h>. C<PL_vtbl_bm> и C<PL_vtbl_fm>
теперь определены пре-процессором как C<PL_vtbl_regexp>, вместо того, чтобы
быть объявленными явными C переменными. C<PL_vtbl_sig> был удалён.

=item *

Сборка с C<-DPERL_GLOBAL_STRUCT> снова работает.  Эта конфигурация не очень
часто используется.

=item *

Perl, сконфигурированный с I<MAD> теперь корректно освобождает структуры
C<MADPROP>, когда освобождается OPs.  C<MADPROP>'ы теперь расположены с
C<PerlMemShared_malloc()>

=item *

Был переработан F<makedef.pl>.  Это не даст заметных эффектов на любых
платформах, которые используют его как часть сборки (AIX, VMS, Win32).

=item *

C<useperlio> больше не может быть отключён.

=item *

Файл F<global.sym> больше не нужен и был удалён. Он содержал список
всех экспортируемых функций, один из файлов генерируемых
F<regen/embed.pl> из данных в F<embed.fnc> и F<regen/opcodes>.  Код
был переделан так, что только пользователи F<global.sym>, F<makedef.pl>,
теперь читают F<embed.fnc> и F<regen/opcodes> напрямую, устраняя
необходимость хранить список экспортируемых функций в файле посреднике.

Так как F<global.sym> никогда не устанавливался, это изменение не будет
заметно вне сборочного процесса.

=item *

F<pod/buildtoc>, использовавшийся в процессе сборки для сборки
L<perltoc>, был переделан и упрощён.  Теперь он содержит только код для
сборки L<perltoc>; код для регенерации Makefile'ов был перемещён в
F<Porting/pod_rules.pl>.  Это баг, если это изменение может иметь
любые материальные эффекты на сборочный процесс.

=item *

F<pod/roffitall> теперь собирается для F<pod/buildtoc>, вместо того,
чтобы включаться в дистрибутив. Список его man-страниц теперь
генерируется (а значит они актуальны). Смотрите также RT #103202 для
схожей нерешённой проблемы.

=item *

Man-страница для C<XS::Typemap> больше не устанавливается.
C<XS::Typemap> - это тестовый модуль, который не устанавливается, а
значит установка его документации не имеет смысла.

=item *

Опции -Dusesitecustomize и -Duserelocatableinc теперь работают вместе
правильно.

=back

=head1 Поддержка Платформ

=head2 Платформо-специфичные Заметки

=head3 Cygwin

=over 4

=item *

Начиная с версии 1.7, Cygwin поддерживает родные UTF-8 пути. Если Perl
собран в этом окружении, имена директорий и файлов будут кодированные в
UTF-8.

Cygwin не инициализирует все оригинальные переменные окружения Win32.
Смотрите F<README.cygwin> обсуждение новой добавленной функции
C<Cygwin::sync_winenv()> [perl #110190] и дальнейшие ссылки.

=back

=head3 HP-UX

=over 4

=item *

HP-UX PA-RISC/64 теперь поддерживает gcc-4.x

Исправление для исправления socketsize теперь делает прохождение набора
тестов успешным на HP-UX PA-RISC для 64bitall сборок.

=back

=head3 VMS

=over 4

=item *

Удалены ненужные включения, исправлены различные предупреждения
компилятора и закрыты незакрытые комментарии в F<vms/vms.c>.

Из сборки VMS удалён слой sockadapt.

=item *

Явная поддержка для VMS версий до v7.0 и DEC C версий до v6.0
была удалена.

=item *

Начиная с Perl 5.10.1, доморощенная обёртка C<stat> не могла
различить директорию с именем содержащим подчёркивание или же идентичным
файлом, содержащим точку в той позиции (например, t/test_pl как
директория и t/test.pl как файл).  Эта проблема была исправлена.

=item *

Сборка на VMS теперь позволяет иметь имена получаемых символов в C коде
для Perl длиннее чем 31 символ. Символы вида
C<Perl__it_was_the_best_of_times_it_was_the_worst_of_times> теперь могут
быть создано свободно без изменения размера VMS линкером.

=back

=head3 GNU/Hurd

Некоторые ошибки сборки и неудачные тесты на GNU/Hurd были исправлены с
помощью сборки DBM модулей, определения путей поиска библиотек и включения
поддержки больших файлов.

=head3 OpenVOS

Perl теперь собирается с динамической линковкой на OpenVOS, минимальная
поддерживаемая версия которого, теперь стала Релизом 17.1.0.

=head3 SunOS

Теперь определяется CC workshop C++ компилятор и используется на
системах, который поставляются без cc.

=head1 Внутренние Изменения

=over 4

=item *

Скомпилированное представление форматов теперь сохраняется через C<mg_ptr>
их C<PERL_MAGIC_fm>.  Ранее оно сохранялось в строковом буфере за пределами
C<SvLEN()> нормальной длины строки.  C<SvCOMPILED()> и
C<SvCOMPILED_{on,off}()> теперь существуют только для совместимости с
XS кодом.  Первый всегда 0, другие два теперь ни делают ничего (no-op).
(5.14.1)

=item *

Некоторые глобальные переменные были помечены как C<const>, члены в структуре
интерпретатора были пере-упорядочены и коды операций были пере-упорядочены.
Операция C<OP_AELEMFAST> была разделена на C<OP_AELEMFAST> и
C<OP_AELEMFAST_LEX>.

=item *

Когда хэш очищается от своих элементов (например, через undef(%h) или %h=()),
поле HvARRAY больше временно не зануляется.  Любой деструктор, вызванный на
освобождённых элементах, по-прежнему видит оставшиеся элементы. Таким образом,
%h=() становится больше похожим на C<delete $h{$_} for keys %h>.

=item *

Байер-Мур (Boyer-Moore) скомпилированные скаляры теперь PVMG и Байер-Мур
таблицы теперь сохраняются через mg_ptr их C<PERL_MAGIC_bm>. Ранее они были
PVGV с таблицами сохранёнными в строковом буфере за пределами C<SvLEN()>.
Это устраняет последнее место, где базовый perl сохраняет данные за пределами
C<SvLEN()>.

=item *

Упрощённая логика в C<Perl_sv_magic()> вносит небольшое изменение в
поведение в случаях ошибок, включающих неизвестные магические типы.
Ранее, если в C<Perl_sv_magic()> был передан магический тип неизвестный
ему, он

=over

=item 1.

Умирал с сообщением "Modification of a read-only value attempted"
(Произведена попытка изменения значения доступного только на чтение)
если был доступен только на чтение.

=item 2.

Возвращал без ошибки если SV уже имел такой магический тип

=item 3.

в противном случае умирал с сообщением "Don't know how to handle
magic of type \\%o" (Не знаю как обрабатывать магический тип \\%o)

=back

Теперь он всегда умирает с сообщением "Don't know how to handle
magic of type \\%o" (Не знаю как обрабатывать магический тип \\%o),
даже на доступных только на чтение значениях или SV, для которых уже
имеется неизвестный магический тип.

=item *

Экспериментальная функция C<fetch_cop_label> была переименована в
C<cop_fetch_label>.

=item *

Функция C<cop_store_label> была добавлена в API, но она
экспериментальная.

=item *

F<embedvar.h> была упрощена и идин уровень макро определений для PL_*
переменных был удалён для конфигураций по-умолчанию (немногочисленных).
Макрос PERLVAR*() теперь напрямую разворачивает свои аргументы в токены,
такие как C<PL_defgv>, вместо разворачивания в C<PL_Idefgv> с
F<embedvar.h> определением макроса соответствия C<PL_Idefgv> в C<PL_defgv>.
Для XS кода, который водил незаконную дружбу с этим представлением,
потребуется обновление.

=item *

Было добавлено API для явного выбора экспортировать символы XSUB или нет.
Больше деталей может быть найдено в комментариях к коммиту e64345f8.

=item *

Функция C<is_gv_magical_sv> была удалена и объединена с C<gv_fetchpvn_flags>.
Её вызов был предназначен для определения должен ли GV автовивифицирован в 
rvalue контексте. Теперь она была заменена новым флагом C<GV_ADDMG>
(не часть API).

=item *

Padlist'ы теперь помечены C<AvREAL>, то есть подсчитывающими ссылки.
Они всегда подсчитывали ссылки, но не были помечены таковыми, так как
F<pad.c> делал свою очистку, вместо использования обычного кода очистки
из F<sv.c>. Это приводило к проблемам при клонировании нитей. Теперь
флаг C<AvREAL> включается, а выключается в F<pad.c> прямо перед тем как
padlist освободился (после того как F<pad.c> выполнил свои процедуры
освобождения pad'ов)

=item *

Все C файлы, которые состовляют ядро Perl теперь были сконвертированы
в UTF-8.

=item *

Эти новые функции были добавлены как часть работы над символами Юникода:

    HvNAMELEN
    HvNAMEUTF8
    HvENAMELEN
    HvENAMEUTF8
    gv_init_pv
    gv_init_pvn
    gv_init_pvsv
    gv_fetchmeth_pv
    gv_fetchmeth_pvn
    gv_fetchmeth_sv
    gv_fetchmeth_pv_autoload
    gv_fetchmeth_pvn_autoload
    gv_fetchmeth_sv_autoload
    gv_fetchmethod_pv_flags
    gv_fetchmethod_pvn_flags
    gv_fetchmethod_sv_flags
    gv_autoload_pv
    gv_autoload_pvn
    gv_autoload_sv
    newGVgen_flags
    sv_derived_from_pv
    sv_derived_from_pvn
    sv_derived_from_sv
    sv_does_pv
    sv_does_pvn
    sv_does_sv
    whichsig_pv
    whichsig_pvn
    whichsig_sv
    newCONSTSUB_flags

Функции gv_fetchmethod_*_flags, такие как gv_fetchmethod_flags являются
экспериментальными и могут быть изменены в будущих релизах.

=item *

Следующие функции были добавлены.  Это I<не> является частью API:

    GvNAMEUTF8
    GvENAMELEN
    GvENAME_HEK
    CopSTASH_flags
    CopSTASH_flags_set
    PmopSTASH_flags
    PmopSTASH_flags_set
    sv_sethek
    HEKfARG

Также есть макрос C<HEKf>, соответствующий C<SVf>, для интерполяции
HEK в строках с форматом.

=item *

C<sv_catpvn_flags> теперь понимает несколько новых только-внутренних
флагов, которые сообщают ей является ли массив символов для объединения
UTF8.  Это позволяет более эффективное соединение, чем создание временных
SV для передачи в C<sv_catsv>.

=item *

Для XS AUTOLOAD подпрограмм, $AUTOLOAD выставляется ещё раз, как это было
в 5.6.0.  Это дополнение к установке C<SvPVX(cv)> для совместимости с
5.8 до 5.14.  Смотрите L<perlguts/Autoloading with XSUBs>.

=item *

Perl теперь проверяет начинается ли массив (линейная isa), возвращаемый
MRO плагином, с имени самого класса, для которого массив был создан, вместо
предположения, что это так и есть.  Это предотвращает пропуск первого
элемента при поиске метода.  Это также означает, что C<mro::get_linear_isa>
может вернуть массив на один элемент больше, чем возвращает MRO плагин
[perl #94306].

=item *

C<PL_curstash> теперь подсчитывает ссылки.

=item *

Теперь появились hint'ы набора функционала в C<PL_hints> (C<$^H>),
которые использует объявление версии, для того, чтобы избежать
загрузки F<feature.pm>.  Установка hint бита указывает, что это
пользовательский пакет функционала, который означает, что записи
в C<%^H> по-прежнему применяются.  F<feature.pm> использует это.

Макрос C<HINT_FEATURE_MASK> определён в F<perl.h> наравне с другими
hint'ами.  Другие макросы для установки и тестирования функционалов и
пакетов находятся в новом F<feature.h>.  C<FEATURE_IS_ENABLED>
(который был перемещён в F<feature.h>) больше не используется по всему
коду, в пользу использования более специфичных макросов, например,
C<FEATURE_SAY_IS_ENABLED>, который определён в F<feature.h>.

=item *

F<lib/feature.pm> теперь генерируемый файл, созданный новым скриптом
F<regen/feature.pl>, который также генерирует F<feature.h>.

=item *

Связанные массивы теперь всегда C<AvREAL>. Если C<@_> или C<DB::args>
является связанным, он сначала материализуется, для того чтобы быть
уверенным, что это всегда так.

=item *

Были добавлены две новые функции C<utf8_to_uvchr_buf()> и
C<utf8_to_uvuni_buf()>.  Это тоже самое, что и C<utf8_to_uvchr> и
C<utf8_to_uvuni> (которые теперь устарели), но принимают дополнительный
параметр, который используется для того, чтобы защитить от чтения за
пределами конца входной строки.
Смотрите L<perlapi/utf8_to_uvchr_buf> и L<perlapi/utf8_to_uvuni_buf>.

=item *

Движок регулярных выражений теперь осуществляет TRIE
регистро-независимый поиск совпадений в Юникоде.  Это может привести
к изменению вывода C<< use re 'debug'; >>, и ускорит различные
процедуры.

=item *

Появилась новая функция C<wrap_op_checker()>, которая предоставляет
безопасную для нитей альтернативу для прямой записи в C<PL_check>.

=back

=head1 Выборочные Исправления Багов

=head2 Массив и Хэш

=over

=item *

Был исправлен баг, который вызывал ошибку "Use of freed value in iteration"
(Использование освобождённого значения в итерации), если следующие два
элемента хэша, через которые будет проводится итерация, были удалены
[perl #85026]. (5.14.1)

=item *

Удаление текущего итератора хэша (элемент хэша, который будет возвращён
при следующем вызове C<each>) в пустом контексте не освобождает его
[perl #85026].

=item *

Удаление метода через синтаксис C<delete $Class::{method}> используемое
для обновления кэша методов работает в пустом контексте, но не в
скалярном или списочном контексте.

=item *

Когда элемент хэша удаляется в пустом контексте, внутренний запись хэша
освобождается теперь перед освобождением значения, чтобы вызываемый этим
последним освобождением деструктор, не видел хэш в рассогласованном
состоянии.  Существовала возможность вызвать двойное освобождение, если
деструктор сам освобождал хэш [perl #100340].

=item *

Оптимизация C<keys> в Perl 5.12.0, чтобы сделать его быстрее на пустых
хэшах привела к тому, что C<each> не сбрасывал итератор, если вызывался
после удаления последнего элемента.

=item *

Освобождение глубоко вложенных хэшей больше не приводит к
крахам [perl #44225].

=item *

Существует возможность из XS кода создавать хэши с элементами, которые
не имеют значений.  Раньше доступ к элементу хэша и использование slice
оператора приводили к краху при работе в lvalue контексте.  Теперь они
производят сообщение об ошибке "Modification of non-creatable hash
value attempted" (Предпринята модификация несоздаваемого значения хэша).

=item *

Если списочное присвоение к хэшу или массиву инициирует деструкторы,
которые освобождают сам хэш или массив, то в результате происходит крах.
Теперь это исправлено [perl #107440].

=item *

Раньше было возможно освободить typeglob локализованного массива или хэша
(например, C<local @{"x"}; delete $::{x}>), приводя к краху при выходе из
контекста.

=item *

Были исправлены некоторые баги в ядре, затрагивающие L<Hash::Util>:
блокировка элемента хэша, который является копией glob, больше не приводит
к последующему присвоению, приводящее к повреждению glob'а, и
разблокирование элемента хэша, который содержит копируемый-при-записи
скаляр, больше не приводит к модификации этого скаляра и изменению
других скаляров, которые разделяют тот же буфер строки.

=back

=head2 Исправления в C API

=over

=item *

XS функция C<newHVhv> теперь работает со связанными хэшами, вместо краха или
возвращения пустого хэша.

=item *

C макрос C<SvIsCOW> теперь возвращает ложь для доступных только на чтение
копий typeglob, которые были созданы так:

  $hash{elem} = *foo;
  Hash::Util::lock_value %hash, 'elem';

Раньше возвращалась истина.

=item *

C функция C<SvPVutf8> больше не пытается изменить свой аргумент, приводящее
к ошибкам [perl #108994].

=item *

C<SvPVutf8> теперь работает правильно с магическими переменными.

=item *

C<SvPVbyte> теперь работает правильно с не-PV.

=item *

При вызове с искажённым UTF-8 вводом, XS-запускаемые функции
C<is_utf8_string()>, C<is_utf8_string_loc()> и
C<is_utf8_string_loclen()> могут читать до 12 байтов за пределами конца
входной строки. Этого больше не происходит [perl #32080]. Однако, в
настоящий момент, C<is_utf8_char()> по-прежнему имеет этот дефект,
смотрите L</is_utf8_char()> выше.

=item *

Функция C-уровня C<pregcomp> может быть смущена если шаблон был в UTF8,
если шаблон был перегружен, связан или иной магический скаляр
[perl #101940].

=back

=head2 Hint'ы времени компиляции

=over

=item *

Связывание C<%^H> больше не приводит к краху perl или игнорированию
содержимого C<%^H>, при входе в контекст компиляции [perl #106282].

=item *

C<eval $string> и C<require> раньше не локализовали C<%^H> в ходе
компиляции, если он был пуст во время, когда сам вызов C<eval>
компилировался.  Это приводило к таким жутким сторонним эффектам, как,
например, C<use re "/m"> включал другие флаги, которые окружающий код
пытался включить для вызывающей процедуры [perl #68750].

=item *

C<eval $string> и C<require> больше не локализуют hint'ы (C<$^H> и
C<%^H>) во время работы, а только во время компиляции $string или
подключаемого файла.  Это делает запись C<BEGIN { $^H{foo}=7 }>
эквивалентной C<BEGIN { eval '$^H{foo}=7' }> [perl #70151].

=item *

Создание блока BEGIN из XS кода (через C<newXS> или C<newATTRSUB>) в
завершении сделает hint'ы компилируемого в данный момент кода текущими
hint'ами.  Это может привести к предупреждениям в контексте с подавленными
предупреждениями.

=back

=head2 Скаляры копируемые-при-записи

Копируемые-при-записи или общие скаляры ключа хэша были введены в
5.8.0, но большая часть Perl кода не сталкивается с ними (они
используются в основном для внутренних целей).  Perl 5.10.0
расширил их, так, например, присвоение C<__PACKAGE__> или ключа хэша
скаляру, делает его копируемым-при-записи.  Некоторые части Perl не
были обновлены с учётом их присутствия, теперь это было исправлено.

=over

=item *

В C<utf8::decode> был неприятный баг, который модифицировал на месте
строковой буфер копируемого-при-записи скаляра (т.е. не создавая
промежуточной копии).  Это приводило к появлению двух элементов в хэше
с одинаковым ключом [perl #91834].

=item *

Для Lvalue подпрограмм не позволялось возвращать COW (копируемые-при-записи)
скаляры.  Это было исправлено для lvalue скалярного контекста в perl 5.12.3
и 5.14.0, но для списочного контекста это оставалось не исправленным до этого
релиза.

=item *

Элементы ограниченных хэшей (смотрите прагму L<fields>), содержащие
копируемые-при-записи значения не могут быть удалены и не могут быть
очищены (C<%hash = ()>).

=item *

Локализация связанной переменной раньше делало её доступной только на
чтение, если она содержала копируемую-при-записи строку.

=item *

Присвоение копируемой-при-записи строки к элементу stash больше не
приводит к двойному освобождению.  Несмотря на это изменение, результат
подобного присвоения по-прежнему неопределён.

=item *

Присвоение копируемой-при-записи строки к связанной переменной больше
не препятствует связыванию этой переменной, если она внутренне
представлена как PVMG или PVLV.

=item *

Делая подстановку в связанной переменной, возвращавшей
копируемый-при-записи скаляр, раньше приводило к ошибкам утверждения
(assert) или предупреждениям "Attempt to free nonexistent shared
string" (Попытка освободить несуществующую общую строку).

=item *

Это регрессия по-сравнению с 5.12: в 5.14.0 битовые операторы
присвоения C<|=>, C<^=> и C<&=> оставляли левую часть неопределённой,
в случае если она была строкой копируемая-при-записи [perl #108480].

=item *

L<Storable>, L<Devel::Peek> и L<PerlIO::scalar> имели схожие проблемы.
Смотрите L</Обновлённые Модули и Прагмы> выше.

=back

=head2 Отладчик

=over

=item *

F<dumpvar.pl> и следовательно команда C<x> в отладчике была исправлена
в обработке объектов "благословлённые" (blessed) в классы, чьи имена
содержат "=".  Содержимое таких объектов раньше не выводилось
[perl #101814].

=item *

Команда "R" для перезапуска сессии отладчика была исправлена для работы
в Windows или любой другой операционной системе, где отсутствует константа
C<POSIX::_SC_OPEN_MAX> [perl #87740].

=item *

Директива C<#line 42 foo> раньше не обновляла массивы линий, используемых
отладчиком, если это происходило при eval'е строки.  Это было частично
исправлено в 5.14, но работало только с одним C<#line 42 foo> в каждом
eval.  Теперь это работает и для нескольких директив.

=item *

Когда вызов подпрограммы перехватывается отладчиком, имя подпрограммы или
ссылка на неё сохраняется в C<$DB::sub>, для доступа отладчиком.  В
некоторых случаях (такие как C<$foo = *bar; undef *bar; &$foo>) C<$DB::sub>
будет установлен в значение, которое не может быть использовано для поиска
подпрограммы, и попытка её вызова отладчиком приведёт к отказу. Теперь
проверка на необходимость ссылки более продуманна, поэтому эта проблема
больше не должна происходить [rt.cpan.org #69862].

=item *

Каждая подпрограмма имеет файл ассоциированный с ней, которые используются
отладчиком. Для тех, что ассоциировались с постоянными подпрограммами,
раньше ошибочно выделялась память при клонировании в нитях.  Следовательно
при отладке многопоточных приложений это приводило к порче памяти
[perl #96126].

=back

=head2 Операторы Разыменования

=over

=item *

C<defined(${"..."})>, C<defined(*{"..."})>, и т.д., раньше возвращали
истину для большинства, но не всех встроенных переменных, если они
ещё не были использованы.  Этот баг затрагивал C<${^GLOBAL_PHASE}> и
C<${^UTF8CACHE}>, как и другие.  Также раньше возвращалась ложь, если
передавалось имя пакета (C<${"::!"}>) [perl #97978, #97492].

=item *

В Perl 5.10.0 появился схожий баг: C<defined(*{"foo"})>, где "foo"
представляет собой имя встроенной глобальной переменной, возвращало
ложь, если переменная никогда до этого не использовалась, но только
до I<первого> вызова.  Это также было исправлено.

=item *

Начиная с 5.6.0, C<*{ ... }> был непоследователен в том, как
обрабатывать неопределённые значения.  Он умирал в strict режиме или
в lvalue контексте для большинства неопределённых значений, но
трактовался как пустая строка (с предупреждением) для специфических
скаляров, возвращаемых C<undef()> (C<&PL_sv_undef> внутренне).  Это было
исправлено. C<undef()> теперь воспринимается как и другие неопределённые
скаляры, как и в Perl 5.005.

=back

=head2 Дескриптор файла, последний, к которому было обращение

Perl имеет внутреннюю переменную, которая хранит дескриптор файла,
к которому было последнее обращение.  Это значение используется в C<$.>,
C<tell> и C<eof> без аргумента.

=over

=item *

Раньше было возможно выставить эту внутреннюю переменную в копию glob'а
и затем модифицировать эту копию glob'а во что-то, отличное от glob, и
снова получить последний файловый дескриптор, к которому было обращение,
ассоциированный с переменной после присвоения к ней glob'а опять:

    my $foo = *STDOUT;  # $foo теперь копия glob'а
    <$foo>;             # $foo теперь последний дескриптор, к которому было обращение
    $foo = 3;           # больше не glob
    $foo = *STDERR;     # снова последний дескриптор, к которому было обращение

Теперь присвоение C<$foo = 3> сбрасывает эту внутреннюю переменную, таким
образом больше нет последнего дескриптора, к которому было обращение, как
если бы C<< <$foo> >> никогда не происходило.

Это также не даёт некоторым несвязанным дескрипторам становится
последними, к которым было обращение, если $foo выходит из контекста,
и тот же внутренний SV затем используется для другого дескриптора
[perl #97988].

=item *

Регрессия в 5.14 приводила к тому, что данные операторы не выставляли
внутреннюю переменную:

    my $fh = *STDOUT;
    tell $fh;
    eof  $fh;
    seek $fh, 0,0;
    tell     *$fh;
    eof      *$fh;
    seek     *$fh, 0,0;
    readline *$fh;

Теперь это исправлено, но C<tell *{ *$fh }> по-прежнему имеет проблему,
и непонятно как это исправлять [perl #106536].

=back

=head2 Файловые тесты и C<stat>

Термин "Файловые тесты" относится к операторам, которые состоят из
дефиса и последующей одной буквы: C<-r>, C<-x>, C<-M> и прочие. Термин
"стековые" применяется для файловых тестов следующих за другим оператором
файлового теста с общим операндом, такие как C<-r -x -w $fooo>.

=over

=item *

C<stat> выдаёт более логичные предупреждения. Он больше не предупреждает
для "_" [perl #71002] и больше не пропускает временами предупреждения для
других неоткрытых дескрипторов.  Он больше не предупреждает о неоткрытых
дескрипторах, когда системный вызов C<fstat> завершился неудачно.

=item *

C<stat> мог иногда возвращать отрицательные числа для больших номеров
inode, поскольку использовал неверный внутренний C тип [perl #84590].

=item *

C<lstat> задокументирован, что откатывается на C<stat> (с предупреждением),
когда передан дескриптор файла.  Когда передана IO ссылка, он, фактически,
делал то же самое, что и S<C<stat _>> и игнорировал дескриптор.

=item *

C<-T _> без предшествующего C<stat> раньше выдавал смущающее "uninitialized"
предупреждение, даже если не было видимых неинициализированных значений,
о которых можно было бы говорить.

=item *

C<-T>, C<-B>, C<-l> и C<-t> теперь работают в стеке с другими файловыми
тестами [perl #77388].

=item *

В 5.14.0, операции файловых тестов (C<-r>, C<-x>, и т.д.) вызывали
FETCH на связанных аргументах, принадлежащих предыдущему аргументу
списочного оператора, если вызывались с bareword аргументом или без
аргумента вообще.  Это было исправлено, и  C<push @foo, $tied, -r>
больше не вызывает FETCH на C<$tied>.

=item *

В Perl 5.6, C<-l> с последующим аргументом отличным от bareword,
рассматривал этот аргумент как имя файла.  Это было изменено в 5.8 для
ссылок на glob (C<\*foo>), но не самих glob'ов (C<*foo>).  C<-l> начал
возвращать C<undef> для ссылок на glob без установки последнего stat
буфера, который использовал дескриптор "_", только если были
включены предупреждения.  С отключёнными предупреждениями он вёл себя
как в 5.6.  Другими словами он был глючным и непоследовательным.
Теперь поведение 5.6 было восстановлено.

=item *

C<-l> с последующим bareword больше не проглатывает предыдущий аргумент
списочного оператора, в списке которого он находится. Поэтому
C<print "bar", -l foo> теперь выведет "bar", поскольку C<-l> больше
его не проглатывает.

=item *

Perl поддерживает несколько внутренних переменных, чтобы следить за
последним буфером stat, откуда происходит file(handle), какого типа
он был и был ли успешен последний stat.

Существовали различные случаи, где эти значения выходили из
синхронизации, приводя к противоречивому и ошибочному поведению в
граничных случаях (любое упоминание C<-T> влияло на также на C<-B>):

=over

=item *

C<-T I<HANDLE>>, даже несмотря на то, что он выполнял C<stat>, не
сбрасывал последний тип stat, а значит последующий за ним C<lstat _>
бодро рапортовал неверные результаты. Также он не устанавливал 
успешный статус.

=item *

Освобождение последнего использованного в C<stat> дескриптора или
файлового теста могло приводить к тому, что S<C<-T _>> будет
использовать другой несвязанный дескриптор.

=item *

C<stat> с IO ссылкой не сбрасывает тип stat или не записывает
файловый дескриптор для использования в S<C<-T _>>. 

=item *

Фатальные предупреждения могут привести к тому, что буфер stat не будет
сброшен для операций файловых тестов на неоткрытых файловых дескрипторах
или C<-l> на любых дескрипторах.  Фатальные предупреждения также не
позволяли C<-T> установить C<$!>.

=item *

Когда последний stat происходил на нечитаемом файле,  C<-T _> должен
был возвращать C<undef>, оставляя последний буфер stat нетронутым.  Но
он устанавливал тип stat, приводя к тому, что C<lstat _> не работал.

=item *

C<-T I<FILENAME>> не сбрасывал внутренний буфер stat для нечитаемых
файлов.

=back

Это всё было исправлено.

=back

=head2 Форматы

=over

=item *

Несколько граничных случаев было исправлено в форматах и C<formline>;
в частности, где форматы сами потенциально изменчивы (такие как
связанные или перегруженные), и где формат и данные отличаются
кодировкой.  В обоих этих случаях раньше было возможно искажение вывода
[perl #91032].

=item *

C<formline> больше не конвертирует свой аргумент в строку на месте. Таким
образом передача ссылки в C<formline> больше не уничтожает ссылку
[perl #79532].

=item *

Присвоение C<$^A> (аккумулятор вывода формата) теперь пересчитывает
число линий вывода.

=back

=head2 C<given> и C<when>

=over

=item *

C<given> не достаточно изолировал неявный $_, что приводило к утечкам
памяти или предупреждения "Variable is not available" (Переменная
недоступна) [perl #94682].

=item *

C<given> не вызывал set-magic на неявную лексическую C<$_>, которую он
использовал.  Это означало, например, что C<pos> запоминался из одного
выполнения блока C<given> до следующего выполнения, даже если на входе
была другая переменная [perl #84526].

=item *

Блок C<when> теперь способен возвращать переменные описанные внутри
окружающего C<given> блока [perl #93548].

=back

=head2 Оператор C<glob>

=over

=item *

На ОС отличных от VMS, Perl оператор C<glob> (и форма C<< <...> >>)
использует L<File::Glob>.  L<File::Glob> разбивает шаблон на слова перед
передачей каждого слова в свою функцию C<bsd_glob>.

Существовало несколько противоречий в том как происходило это разбитие.
Теперь метки цитирования (' и ") всегда трактуются как слова разделители
в стиле shell (что позволяет использовать пробелы как часть слова) и
обратные слэши всегда сохраняются, если они присутствуют не для
экранирования меток.  Ранее, это иногда случалось, в зависимости от того
содержал ли шаблон пробелы. Также, экранированные пробелы в конце
шаблонов больше не обрезаются [perl #40470].

=item *

C<CORE::glob> теперь является способом запуска функции glob по-умолчанию.
Используется для учёта переопределения, несмотря на C<CORE::> префикс.

=item *

В miniperl (используется для конфигурирования модулей, когда сам perl
собирается), C<glob> теперь очищает %ENV перед запуском csh, так как
последний ругается на некоторых системах, если ему не нравится
содержимое переменной окружения LS_COLORS [perl #98662].

=back

=head2 Lvalue подпрограммы

=over

=item *

Явный return теперь возвращает собственно аргумент переданный в return,
вместо его копирования [perl #72724, #72706].

=item *

Раньше для lvalue подпрограмм принудительно требовалось использовать
lvalue синтаксис (т.е. чтобы ни шло на левой стороне C<=>) для
последнего оператора и аргументам для return. Так как lvalue
подпрограммы не всегда вызываются в lvalue контексте, это ограничение
было снято.

=item *

Lvalue подпрограммы теперь менее ограниченны в том, какие значения могут
быть возвращены.  Раньше подпрограмма вылетала с ошибкой на значения
возвращённые от C<shift>, C<delete> и других подпрограмм, но сейчас больше
так не делает [perl #71172].

=item *

Раньше пустая lvalue подпрограмма (C<sub :lvalue {}>) возвращала C<@_> в
списочном контексте.  В действительности, раньше все подпрограммы делали
тоже самое, но обычные подпрограммы были исправлены в Perl 5.8.2.  Теперь
lvalue подпрограммы также были исправлены.

=item *

Автовивификация теперь работает на значениях возвращаемых из lvalue
подпрограмм [perl #7946], также как и возвращает C<keys> в lvalue
контексте.

=item *

Lvalue подпрограммы ранее копировали свои возвращаемые значения в rvalue
контексте.  Это было не только бесполезным прожиганием циклов ЦПУ, но также
приводило к проблемам. Прототип C<($)> заставит lvalue подпрограмму копировать
своё возвращаемое значение [perl #51408], и цикл
C<while(lvalue_sub() =~ m/.../g) { ... }> будет работать бесконечно
[perl #78680].

=item *

Раньше lvalue подпрограммы, когда вызывались в потенциально lvalue контексте
(например, аргументы подпрограммы или список передан в C<for>), копировали
любое доступное только на чтение значение, которое возвращалось. Например,
C< sub :lvalue { $] } > вернёт не C<$]>, а его копию.

=item *

Lvalue подпрограммы, при вызове в потенциально lvalue контексте,
возвращающие массивы или хэши, раньше привязывали массивы или хэши к
скалярным переменным, приводя к багам.  Это было исправлено в 5.14.0,
в случае если массив был первой сущностью, возвращённой из подпрограммы
(но не для случая, когда возвращается C<$scalar, @array> или хэши).
Теперь было применено более общее исправление [perl #23790].

=item *

Вызов метода, чьи аргументы были окружены C<my()> или C<our()> (как в
C<< $object->method(my($a,$b)) >>) раньше форсировали lvalue контекст в
подпрограмме.  Это помешает lvalue методам возвращать некоторые значения.

=item *

Вызовы lvalue подпрограмм, которые не могут быть определены таковыми на
этапе компиляции (C<&$name> или &{"name"}) больше не избегают проверки
strict refs, если таковые присутствуют в последнем операторе lvalue
подпрограммы [perl #102486].

=item *

Вызовы подпрограмм, которые не видны во время компиляции, если они
происходят в последнем операторе lvalue подпрограммы, отвергнут не
lvalue подпрограммы и аварийно завершаться с сообщением "Can't modify
non-lvalue subroutine call" (Не могу модифицировать вызов не-lvalue
подпрограммы) [perl #102486].

Вызовы не-lvalue подпрограмм, которые I<видимы> во время компиляции
проявят противоположный баг.  Если вызов произошёл в последнем операторе
lvalue подпрограммы, то не произойдёт никакой ошибки, когда lvalue
подпрограмма вызвана в lvalue контексте.  Perl слепо присвоит
во временное значение возвращаемое не-lvalue подпрограммой.

=item *

Ранее процедуры C<AUTOLOAD> могли иметь приоритет над непосредственно
вызовом подпрограммы (т.е., когда автозагрузка и не была нужна), для
вызовов подпрограмм в  lvalue или потенциально lvalue контексте, если
подпрограмма не видна на этапе компиляции.

=item *

Применение атрибута C<:lvalue> для XSUB или для псевдонима заглушки
подпрограммы с синтаксисом C<< sub foo :lvalue; >> перестало работать в
Perl 5.12. Теперь это было исправлено.

=item *

Применение атрибута :lvalue для подпрограммы, которая уже определена
не работает правильно, т.к. атрибут меняет способ компиляции подпрограммы.
Начиная с Perl 5.12, выдаётся предупреждение при попытке применения
атрибута к уже определённой подпрограмме.  В таких случаях атрибут
отбрасывается.

Но в изменении в 5.12 не учитывался случай, когда также существует
пользовательский атрибут: в этом случае атрибут по-прежнему молча
и безрезультатно применяется. Это упущение теперь было исправлено.
C<sub foo :lvalue :Whatever> (когда C<foo> уже определена) теперь
предупреждает о :lvalue атрибуте и не применяет его.

=item *

Баг, затрагивающий распространение lvalue контекста через вызовы
lvalue подпрограмм, был исправлен. Ранее, возвращаемое во
вложенном rvalue контексте, значение рассматривалось в lvalue
контексте во внутреннем вызове подпрограммы, приводя к отказу принятия
некоторых значений (например, значений доступных только на чтение).

=back

=head2 Перегрузка

=over

=item *

Арифметическое присвоение (C<$left += $right>) включающее
перегруженные объекты, которые полагаются на 'безметодную' перегрузку
больше не приводит к ошибке сегментирования, когда левый операнд не
перегружен.

=item *

Ошибки возникающие, когда методы не могут быть найдены при перегрузке
теперь упоминают корректное имя пакета, как они это делали в 5.8.x,
вместо ошибочного упоминания "overload" пакета, как стало происходить
начиная с 5.10.0

=item *

Присвоение неопределённого значения C<%overload::> больше не приводит
к краху.

=back

=head2 Прототипы встроенных ключевых слов

=over

=item *

Функция C<prototype> больше не падает для директив C<__FILE__>,
C<__LINE__> и C<__PACKAGE__>.  Теперь она возвращает прототип пустую
строку для них, поскольку они синтаксически неотличимы от
безаргументных функций типа C<time>.

=item *

C<prototype> теперь возвращает C<undef> для всех переопределяемых
вставочных операторов, таких как C<eq>, которые не могут быть вызваны
подобно функциям.  Раньше функция возвращала некорректный прототип для
некоторых аргументов и аварийно завершалась падала для других
[perl #94984]. 

=item *

Прототипы некоторых встроенных функций--C<getprotobynumber>, C<lock>,
C<not> и C<select>--были исправлены или по крайне мере ближе к реальности,
чем раньше.

=back

=head2 Регулярные Выражения

=for comment Можно ли объединить некоторые из этих пунктов?

=over 4

=item *

C</[[:ascii:]]/> и C</[[:blank:]]/> теперь используют правила локали
при C<use locale>, если платформа поддерживает это.  Ранее, они
использовали родной набор символов платформы.

=item *

C<m/[[:ascii:]]/i> и C</\p{ASCII}/i> теперь сравнивают идентично (когда
не работают под разными локалями).  Это исправление регрессии, появившейся
в 5.14, в которой первое выражение могло искать совпадения с символами за
пределами ASCII, такими как KELVIN SIGN.

=item *

C</.*/g> иногда могло не совпадать в конце строки, которая заканчивается
на "\n". Это было исправлено [perl #109206].

=item *

Начиная с 5.12.0, Perl мог привести свой внутренний учёт в беспорядок
после присвоения C<${ qr// }> элементу хэша, который затем блокировался
с помощью L<Hash::Util>.  Это приводило к двойному освобождению, крахам
или ошибочному поведению.

=item *

Новый (в 5.14.0) модификатор регулярного выражения C</a> при повторении,
вида C</aa>, запрещает символам за пределами диапазона ASCII совпадать
с символами внутри этого диапазона при действии модификатора C</i>.  Это
не работало в некоторых случаях, использующих альтернативы, такие как:

 "\N{KELVIN SIGN}" =~ /k|foo/iaa;

ошибочно вернёт совпадение. Теперь это исправлено.

=item *

В 5.14.0 появились некоторые утечки памяти в классах регулярных выражений,
таких как C<[\w\s]>, которые теперь были исправлены. (5.14.1)

=item *

В крайних случаях регулярные выражения потенциально могут зациклиться.
Это происходит только при модификаторе C</i> для заключённых в скобки
классов символов, которые имеют символы, становящиеся многосимвольным
при смене регистра, а исходная строка, в которой ищется совпадение,
включает начальную порцию символа в этом регистре, с последующим
символом, также становящимся многосимвольным при смене регистра, и
который начинается с фрагмента, на который заканчивается предыдущий
символ, плюс ещё немного.

 "s\N{U+DF}" =~ /[\x{DF}foo]/i

один из таких случае. Изменение регистра для C<\xDF> соответствует
C<"ss">. (5.14.1)

=item *

Несколько символов в шаблонах регулярных выражений не совпадают
корректно в некоторых случаях при использовании модификатора C</i>.
Вот список затронутых символов:
COMBINING GREEK YPOGEGRAMMENI,
GREEK CAPITAL LETTER IOTA,
GREEK CAPITAL LETTER UPSILON,
GREEK PROSGEGRAMMENI,
GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA,
GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS,
GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND OXIA,
GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS,
LATIN SMALL LETTER LONG S,
LATIN SMALL LIGATURE LONG S T,
и
LATIN SMALL LIGATURE ST.

=item *

Регрессия с утечкой памяти при компиляции регулярных выражений в
многопоточных приложениях была исправлено.

=item *

Регрессия, появившаяся в 5.13.6 была исправлена. Это затрагивало, заключённый
в скобки инвертированный класс символов в регулярных выражениях, который
состоял только из свойств Юникода.  Эти свойства не инвертировались за
пределами диапазона Latin1.

=item *

Три проблематичные символы Юникода теперь работают лучше в шаблонах регулярного
выражения при C</i>.

Раньше, три символа Юникода:
LATIN SMALL LETTER SHARP S,
GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS,
и
GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS,
вместе с последовательностями, которыми они становятся при преобразовании
регистра (включая "ss" в случае LATIN SMALL LETTER SHARP S), неправильно
сопоставлялись при C</i>.  В 5.14.0 были исправлены некоторые подобные
случаи, но были внесены другие, включая панику, когда один из символов
или последовательностей были использованы в регулярном выражении с
предикатом C<(?(DEFINE)>.  Известные проблемы, появившиеся в 5.14 теперь
были исправлены, как и некоторые крайние случаи, которые никогда не
работали до этого.  Всё это относится к использованию символов и
последовательностей за пределами, помещённых в скобки классов символов
при модификаторе C</i>. Это исправляет проблему [perl #98546].

По-прежнему остаются известные проблемы с некоторыми символами, с
изменяющимся числом символов при изменении регистра, внутри
помещённых в скобки классов символов, включая такие конструкции, как
C<qr/[\N{LATIN SMALL LETTER SHARP}a-z]/i>.  Эти оставшиеся проблемы
описаны в [perl #89774].

=item *

RT #78266: В движке регулярных выражений имелись утечки памяти при
доступе к именованным захватам, для которых не было совпадений в
части регулярного выражения, начиная с версии 5.10, где они впервые
появились. Т.е. подобный код мог поглотить более сотни Мб памяти:

    for (1..10_000_000) {
        if ("foo" =~ /(foo|(?<capture>bar))?/) {
            my $capture = $+{capture}
        }
    }
    system "ps -o rss $$"'

=item *

В 5.14 C</[[:lower:]]/i> и C</[[:upper:]]/i> больше не совпадали 
с символами в противоположном регистре.  Это было исправлено
[perl #101970].

=item *

Сопоставление регулярного выражения с перегруженным объектом на правой
стороне в некоторых случаях приводило к многократному преобразованию
объекта к строке.

=item *

Была устранена регрессия, появившаяся в 5.14, при C</i> поиске
совпадения, в которых совпадение ошибочно не происходило, если
шаблон был в UTF_8, а целевая строка - нет, и символы Latin-1
предшествовали символам строки, которая должна была совпадать с
шаблоном [perl #101710].

=item *

В регистронезависимых шаблонах регулярного выражения, на UTF-8
кодированных строках не производилось сканирование на начало
соответствия, только до первой возможной позиции, что приводило
к тому, что сравнения C<"f\x{FB00}" =~ /ff/i> завершались
неудачно.

=item *

Оптимизатор регулярных выражений больше не падает на отладочных
сборках, когда объединяет узлы фиксированной строки с неудобным
содержимым.

=item *

Паника, включающая комбинацию модификаторов регулярных выражений C</aa>
и экранирующую последовательность C<\b>, появившаяся в 5.14.0 была
исправлена [perl #95964].

=item *

Комбинация модификаторов регулярных выражений C</aa> и экранирующих
последовательностей C<\b> и C<\B> не работали корректно на UTF-8
кодированных строках.  Все не-ASCII символы при C</aa> должны были
восприниматься как не символы слова, но происходило так, что
правила Юникода тем не менее использовались для определения
символ слова/неслова для не-ASCII символов. Это было исправлено
[perl #95968].

=item *

C<< (?foo: ...) >> больше не теряется при передаче в набор символов.

=item *

Оптимизация trie раньше имела проблемы с альтернативами, содержащие
пустые C<(?:)>, приводя C<< "x" =~ /\A(?>(?:(?:)A|B|C?x))\z/ >> к
отсутствию совпадения, там где оно должно было быть [perl #111842].

=item *

Использование лексических (C<my>) переменных в блоках кода, внедрённых
в регулярные выражения больше не приводит к порче памяти и крахам.

Тем не менее, эти кодовые блоки по-прежнему экспериментальные, поскольку
есть проблемы с неправильными переменными закрытыми там (в циклах,
например), при ненормальном выходе (например, через C<die>) приводящие
к повреждению памяти.

=item *

Метасимволы регулярных выражений C<\h>, C<\H>, C<\v> и C<\V>, раньше
вызывали панические сообщения об ошибке, при попытке сравнения в конце
строки  [perl #96354].

=item *

Аббревиатуры  для четырёх C1 контрольных символов C<MW> C<PM>, C<RI> и
C<ST> раньше не распознавались в C<\N{}>, vianame() и string_vianame().

=item *

Упоминание переменной с названием "&", отличным от C<$&> (например, C<@&>
или C<%&>) больше не останавливает работу  C<$&>.  Тоже относится и к
переменным с именем "'" и and "`" [perl #24237].

=item *

Создание подпрограммы C<UNIVERSAL::AUTOLOAD> больше не прекращает действие
C<%+>, C<%-> и C<%!> [perl #105024].

=back

=head2 Умное сравнение

=over

=item *

C<~~> теперь корректно обрабатывает приоритет Любого~~Объект и не может быть
обманут перегруженными объектами на левой стороне.

=item *

В Perl 5.14.0 C<$tainted ~~ @array> перестало работать правильно. Иногда он
ошибочно неудачен (когда C<$tainted> содержит строку, которая встречается в
массиве I<после> первого элемента) или ошибочно успешен (когда C<undef>
встречается после первого элемента) [perl #93590].

=back

=head2 Оператор C<sort>

=over

=item *

C<sort> не считал C<sub {}> и C<sub {()}> эквивалентными, когда такие
подпрограммы представлены как процедуры сравнения.  Раньше он сообщал об
ошибке на запись C<sub {()}>.

=item *

C<sort> теперь снова работает с XSUB пользовательскими процедурами
сортировки.  Это перестало работать в 5.10.0.

=item *

C<sort> с константной пользовательской процедурой сортировки хоть и
производит неотсортированные результаты, но больше не падает.  Он
начал падать начиная с 5.10.0.

=item *

Предупреждения выдаваемые C<sort>, когда пользовательская процедура
сравнения возвращает нечисловое значение, теперь содержит фразу "in sort"
и показывает номер строки оператора C<sort>, вместо последней строки
сравнивающей процедуры.  Предупреждение также происходит теперь только если
предупреждения включены в контексте, где находится C<sort>.  Ранее
предупреждения выдавались, если были включены в контексте сравнивающей
процедуры.

=item *

C<< sort { $a <=> $b } >>, который внутренне оптимизирован, теперь выдаёт
"uninitialized" предупреждения для NaNs (нечисловые значения), так как
C<< <=> >> возвращает C<undef> для них.  Что ставит их наравне с
S<C<< sort { 1; $a <=> $b } >>> и другими более сложными случаями, которые
не оптимизированы [perl #94390].

=back

=head2 Оператор C<substr>

=over

=item *

Связанные (а значит магические) переменные больше не могут избегать
предупреждения "Attempt to use reference as lvalue in substr" (Попытка
использовать ссылку как lvalue в substr).

=item *

Это предупреждение теперь выводится, когда к возвращаемому lvalue
делается присваивание, а не когда вызывается сам C<substr>.  Это
проявляется, только если к возвращаемому C<substr> значению позже
делают ссылку или присваивание.

=item *

Передача подстроки доступного только на чтение значения или typeglob'а
в функцию (потенциально lvalue контекст) больше не вызывает немедленной
ошибки "Can't coerce" (Не могу принуждать) или "Modification of a
read-only value" (Модификация значения, доступного только на чтение).
Эта ошибка случится, только если к переданному значению произойдёт
присваивание.

Схожее происходит с ошибкой "substr outside of string" (substr вне
строки).  Если lvalue только читается, но не записывается, то теперь
выводится только предупреждение, как и с rvalue C<substr>.

=item *

Присвоение к C<substr> больше не вызывает FETCH дважды, если первый
аргумент это связанная переменная, только один раз.

=back

=head2 Поддержка встроенных нулей

Некоторые части Perl не работают корректно с нулями (C<chr 0>), встроенными
в строки. Это означает, что например, C<< $m = "a\0b"; foo->$m >> вызовет
метод "a", вместо метода содержащегося в $m. Эти части perl были исправлены
для поддержки нулей:

=over

=item *

Имена методов

=item *

Имена typeglob'ов (включая файловые дескрипторы и имена подпрограмм)

=item *

Имена пакетов, включая возвращаемое C<ref()> значение

=item *

Элементы typeglob (C<*foo{"THING\0stuff"}>)

=item *

Имена сигналов

=item *

Различные сообщения ошибок и предупреждений, которые упоминают имена
переменных или значения, методы и т.д.

=back

Побочный эффект этих изменений состоит в том, что "благословение"
(blessing) на "\0" больше не приводит к тому, что C<ref()> возвращает ложь.

=head2 Баги в Нитях (threads)

=over

=item *

Typeglob, возвращаемый из потока исполнения больше не клонируется, если
родительская нить уже имеет glob с таким же именем.  Это означает, что
возвращаемая подпрограмма теперь будет присваивать к правильным
переменным пакета [perl #107366].

=item *

Некоторые случаи крахов нитей, вызванные выделением памяти при клонировании,
были исправлены [perl #90006].

=item *

Слияние нитей иногда выдавало предупреждение "Attempt to free unreferenced scalar"
(Попытка освободить скаляр без ссылки), если C<caller> был использован из
пакета C<DB> до создания нити [perl #98092].

=item *

Блокирование подпрограммы (через C<lock &sub>) больше не является ошибкой
на этапе компиляции для обычных подпрограмм.  Для lvalue подпрограмм больше
не делается попыток вернуть подпрограмму как скаляр, приводящее к странным
побочным эффектам, как возвращение "CODE" из C<ref \$_> в некоторых случаях.

C<lock &sub> теперь становится ошибкой этапа компиляции, только если загружен
L<threads::shared> (в противном случае это пустая операция (no-op)), но это
может быть скорректировано в будущих версиях.

=back

=head2 Связанные переменные

=over

=item *

Различные случаи, в которых FETCH игнорировался или вызывался несколько раз,
были исправлены.

=over

=item *

C<PerlIO::get_layers> [perl #97956]

=item *

C<$tied =~ y/a/b/>, C<chop $tied> и C<chomp $tied>, когда $tied содержит
ссылку

=item *

При вызове C<local $_> [perl #105912]

=item *

Четырёх-аргументный C<select>

=item *

Связанный буфер, переданный в C<sysread>

=item *

C<< $tied .= <> >>

=item *

Трёх-аргументный C<open>, когда третий - это связанный файловый дескриптор
(как например, C<< open $fh, ">&", $tied >>)

=item *

C<sort> с ссылкой на связанный glob для процедуры сравнения.

=item *

C<..> и C<...> в списочном контексте [perl #53554].

=item *

C<${$tied}>, C<@{$tied}>, C<%{$tied}> и C<*{$tied}>, где связанная
переменная возвращает строку (C<&{}> это не затрагивает)

=item *

C<defined ${ $tied_variable }>

=item *

Различные функции, которые принимают аргумент файловый дескриптор в
rvalue контексте (C<close>, C<readline>, и прочие) [perl #97482]

=item *

Некоторые классы разыменования сложных выражений, такие как
C<${ (), $tied } = 1>, раньше вызывали C<FETCH> несколько раз, теперь
вызывают только раз.

=item *

C<$tied-E<gt>method>, где $tied возвращает имя пакета, приводит к
отказу при вызове метода, вследствие повреждения памяти.

=item *

Присвоения вида C<*$tied = \&{"..."}> и C<*glob = $tied>

=item *

C<chdir>, C<chmod>, C<chown>, C<utime>, C<truncate>, C<stat>, C<lstat> и
операции файловых тестов (C<-r>, C<-x>, и другие)

=back

=item *

C<caller> устанавливает C<@DB::args> в аргументы подпрограммы, когда
вызывается из пакета DB.  Раньше происходил крах, если при этом C<@DB::args>
были связанными.  Теперь программа останавливается с ошибкой.

=item *

Связывание элемента %ENV или C<%^H> и последующее удаление этого элемента
приводило к вызову метода DELETE связанного объекта, даже несмотря на то,
что связывание самого элемента, должно быть эквивалентно связыванию скаляра
(элемент, разумеется скаляр) [perl #67490].

=item *

Когда Perl автовивифицирует элемент связанного массива или хэша (что влечёт
за собой вызов STORE с новой ссылкой), то теперь он немедленно вызывает FETCH
после STORE,  вместо предположения, что FETCH вернёт ту же ссылку.  Это
упрощает реализацию связанных объектов [perl #35865, #43011].

=item *

Четырёх-аргументный C<select> больше не выводит предупреждение "Non-string
passed as bitmask" (Передано нестроковое значение как битовая маска) на
связанных или taint переменных, которые являются строками.

=item *

Локализация связанных скаляров, которые возвращают typeglob, больше не
препятствуют им становится связанными до конца контекста.

=item *

Попытка сделать C<goto> вне метода на связанном дескрипторе раньше вызывало
повреждения памяти или крах.  Вместо этого теперь выводится сообщение об
ошибке [perl #8611].

=item *

Был исправлен баг, который происходил, когда связанная переменная
использовалась как ссылка на подпрограмму: если последнее присвоенное
или возвращённое значение переменной было ссылкой или typeglob'ом,
C<\&$tied> будет или падать или возвращать неверную подпрограмму. Случай
с ссылкой - это регрессия появившаяся в Perl 5.10.0.  Для typeglob'ов,
это вероятно не работало до текущего момента.

=back

=head2 Объекты version и строки версий (vstrings)

=over

=item *

Битовый оператор дополнения (и возможно другие операторы тоже), при
передаче vstring, оставит vstring магию привязанной к возвращаемому
значению, даже несмотря на то, что строка была изменена.  Это означает,
что C<< version->new(~v1.2.3) >> создаст версию выглядящей как "v1.2.3",
несмотря на то, что строка переданная в C<< version->new >> являлась
"\376\375\374".  Это также приводит к тому, что  L<B::Deparse> разберёт
C<~v1.2.3> некорректно, без C<~> [perl #29070].

=item *

Присвоение vstring к магической (например, связанной, C<$!>) переменной
и последующее присвоение ей другого значения, раньше выносило всю магию.
Это означает, что связанная переменная становилась недоделанной, C<$!>
переставала получать изменения при ошибках в системных вызовах, C<$|>
переставала управлять autoflush и происходили другие беды.  Это было
исправлено.

=item *

C<< version->new("version") >> и C<printf "%vd", "version"> больше не
падают [perl #102586].

=item *

Сравнение версий, которые происходили неявно при C<use v5.43>, больше
не приводят к изменениям в локали [perl #105784].

=item *

Объекты version больше не вызывают утечки памяти в логическом контексте
[perl #109762].

=back

=head2 Предупреждения, переопределения

=over

=item *

Подпрограммы из пространства имён C<autouse> ещё больше защищены от
предупреждении о переопределении.  Раьше это работало в 5.005, но было
сломано в 5.6 для большниства подпрограмм.  Для подпрограмм, созданных
через XS, которые переопределяют подпрограммы в пакете C<autouse>, это
перестало работать с версии 5.10.

=item *

Новые XSUB теперь выдают предупреждения о переопределении, если они
переписывают существующие подпрограммы, как они это делали в 5.8.x.
(Логика C<autouse> была изменена наоборот в 5.10-14).  Только
подпрограммы из пространства имён C<autouse> могут предупреждать, когда
перезаписываются.

=item *

C<newCONSTSUB> раньше использовала предупреждения на этапе компиляции,
вместо предупреждений этапа исполнения.  Следующий код никогда не сможет
выдать сообщение о переопределении, как раньше, если C<newCONSTSUB>
переопределит существующую подпрограмму:

    use warnings;
    BEGIN {
        no warnings;
        some_XS_function_that_calls_new_CONSTSUB();
    }

=item *

Предупреждения о переопределении для постоянных подпрограмм включены
по-умолчанию (известные из L<perldiag>, как строгие предупреждения). Так
было только в случаях, когда происходило присвоения glob или объявление
Perl подпрограммы, приводившего к предупреждению.  Если создание XSUB
вызывало предупреждение, то это не было предупреждением по-умолчанию.
Это было исправлено.

=item *

Внутренняя проверка, должно ли происходить предупреждение о переопределении,
раньше выдавало предупреждение "uninitialized" в таких случаях:

    use warnings "uninitialized";
    use constant {u => undef, v => undef};
    sub foo(){u}
    sub foo(){v}

=back

=head2 Предупреждения, "Неинициализированное" ("Uninitialized")

=over

=item *

Различные функции, которые принимают аргумент файловый дескриптор в
rvalue контексте (C<close>, C<readline>, и прочие) раньше дважды
предупреждали о неопределённых дескрипторах [perl #97482].

=item *

C<dbmopen> предупреждает только один раз, вместо трёх раз, если аргумент
является C<undef> [perl #90064].

=item *

Оператор C<+=> обычно не предупреждает, когда на левой стороне C<undef>,
но делал так для связанных переменных.  Это было исправлено [perl #44895].

=item *

Исправление бага в Perl 5.14, привело к новому багу, приводящему к тому,
что предупреждение о неинициализированности сообщало о неверной
переменной, если рассматриваемый оператор имел два операнда и один из них
был C<%{...}> или C<@{...}>.  Это было исправлено [perl #103766].

=item *

C<..> и C<...> в списочном контексте теперь упоминает имя переменной в
предупреждениях "uninitialized" для строковых (в противовес численным)
диапазонов.

=back

=head2 Слабые ссылки

=over

=item *

"Ослабление" первого аргумента автоматически вызываемого метода C<DESTROY>
приводит к ошибочному сообщению об ошибке "DESTROY created new reference"
(DESTROY создал новую ссылку) или к краху.  Теперь это ошибка, только для
слабой, доступной только на чтение, ссылки.

=item *

Слабые ссылки лексических хэшей при выходе из контекста не пропадали 
(становились неопределёнными), а продолжали указывать на хэш.

=item *

Слабые ссылки лексических переменных при выходе из контекста теперь
разрушены до вызова любого магического метода (например, DESTROY на
связанном объекте).  Это предотвращает изменения переменных в этих методах,
которые будут видны при следующем вхождении в контекст.

=item *

Создание слабой ссылки на массив @ISA или доступ к индексу массива
(C<$#ISA>) может привести к искажению внутреннего учёта для элементов,
впоследствии добавляемых к массиву @ISA.  Например, создание слабой ссылки
элемента на самого себя, поместит слабую ссылку в @ISA; и элементы,
которые добавляются после использования C<$#ISA>, будут игнорироваться
при поиске методов [perl #85670].

=back

=head2 Other notable fixes

=over

=item *

C<quotemeta> now quotes consistently the same non-ASCII characters under
C<use feature 'unicode_strings'>, regardless of whether the string is
encoded in UTF-8 or not, hence fixing the last vestiges (we hope) of the
infamous L<perlunicode/The "Unicode Bug">.  [perl #77654].

Which of these code points is quoted has changed, based on Unicode's
recommendations.  See L<perlfunc/quotemeta> for details.

=item *

When one writes C<open foo || die>, which used to work in Perl 4, a
"Precedence problem" warning is produced.  This warning used erroneously to
apply to fully-qualified bareword handle names not followed by C<||>.  This
has been corrected.

=item *

After package aliasing (C<*foo:: = *bar::>), C<select> with 0 or 1 argument
would sometimes return a name that could not be used to refer to the
filehandle, or sometimes it would return C<undef> even when a filehandle
was selected.  Now it returns a typeglob reference in such cases.

=item *

C<PerlIO::get_layers> no longer ignores some arguments that it thinks are
numeric, while treating others as filehandle names.  It is now consistent
for flat scalars (i.e., not references).

=item *

Unrecognised switches on C<#!> line

If a switch, such as B<-x>, that cannot occur on the C<#!> line is used
there, perl dies with "Can't emulate...".

It used to produce the same message for switches that perl did not
recognise at all, whether on the command line or the C<#!> line.

Now it produces the "Unrecognized switch" error message [perl #104288].

=item *

C<system> now temporarily blocks the SIGCHLD signal handler, to prevent the
signal handler from stealing the exit status [perl #105700].

=item *

The %n formatting code for C<printf> and C<sprintf>, which causes the number
of characters to be assigned to the next argument, now actually
assigns the number of characters, instead of the number of bytes.

It also works now with special lvalue functions like C<substr> and with
nonexistent hash and array elements [perl #3471, #103492].

=item *

Perl skips copying values returned from a subroutine, for the sake of
speed, if doing so would make no observable difference.  Due to faulty
logic, this would happen with the
result of C<delete>, C<shift> or C<splice>, even if the result was
referenced elsewhere.  It also did so with tied variables about to be freed
[perl #91844, #95548].

=item *

C<utf8::decode> now refuses to modify read-only scalars [perl #91850].

=item *

Freeing $_ inside a C<grep> or C<map> block, a code block embedded in a
regular expression, or an @INC filter (a subroutine returned by a
subroutine in @INC) used to result in double frees or crashes
[perl #91880, #92254, #92256].

=item *

C<eval> returns C<undef> in scalar context or an empty list in list
context when there is a run-time error.  When C<eval> was passed a
string in list context and a syntax error occurred, it used to return a
list containing a single undefined element.  Now it returns an empty
list in list context for all errors [perl #80630].

=item *

C<goto &func> no longer crashes, but produces an error message, when
the unwinding of the current subroutine's scope fires a destructor that
undefines the subroutine being "goneto" [perl #99850].

=item *

Perl now holds an extra reference count on the package that code is
currently compiling in.  This means that the following code no longer
crashes [perl #101486]:

    package Foo;
    BEGIN {*Foo:: = *Bar::}
    sub foo;

=item *

The C<x> repetition operator no longer crashes on 64-bit builds with large
repeat counts [perl #94560].

=item *

Calling C<require> on an implicit C<$_> when C<*CORE::GLOBAL::require> has
been overridden does not segfault anymore, and C<$_> is now passed to the
overriding subroutine [perl #78260].

=item *

C<use> and C<require> are no longer affected by the I/O layers active in
the caller's scope (enabled by L<open.pm|open>) [perl #96008].

=item *

C<our $::é; $é> (which is invalid) no longer produces the "Compilation
error at lib/utf8_heavy.pl..." error message, which it started emitting in
5.10.0 [perl #99984].

=item *

On 64-bit systems, C<read()> now understands large string offsets beyond
the 32-bit range.

=item *

Errors that occur when processing subroutine attributes no longer cause the
subroutine's op tree to leak.

=item *

Passing the same constant subroutine to both C<index> and C<formline> no
longer causes one or the other to fail [perl #89218]. (5.14.1)

=item *

List assignment to lexical variables declared with attributes in the same
statement (C<my ($x,@y) : blimp = (72,94)>) stopped working in Perl 5.8.0.
It has now been fixed.

=item *

Perl 5.10.0 introduced some faulty logic that made "U*" in the middle of
a pack template equivalent to "U0" if the input string was empty.  This has
been fixed [perl #90160].

=item *

Destructors on objects were not called during global destruction on objects
that were not referenced by any scalars.  This could happen if an array
element were blessed (e.g., C<bless \$a[0]>) or if a closure referenced a
blessed variable (C<bless \my @a; sub foo { @a }>).

Now there is an extra pass during global destruction to fire destructors on
any objects that might be left after the usual passes that check for
objects referenced by scalars [perl #36347].

=item *

Fixed a case where it was possible that a freed buffer may have been read
from when parsing a here document [perl #90128]. (5.14.1)

=item *

C<each(I<ARRAY>)> is now wrapped in C<defined(...)>, like C<each(I<HASH>)>,
inside a C<while> condition [perl #90888].

=item *

A problem with context propagation when a C<do> block is an argument to
C<return> has been fixed.  It used to cause C<undef> to be returned in
some cases of a C<return> inside an C<if> block which itself is followed by
another C<return>.

=item *

Calling C<index> with a tainted constant no longer causes constants in
subsequently compiled code to become tainted [perl #64804].

=item *

Infinite loops like C<1 while 1> used to stop C<strict 'subs'> mode from
working for the rest of the block.t

=item *

For list assignments like C<($a,$b) = ($b,$a)>, Perl has to make a copy of
the items on the right-hand side before assignment them to the left.  For
efficiency's sake, it assigns the values on the right straight to the items
on the left if no one variable is mentioned on both sides, as in C<($a,$b) =
($c,$d)>.  The logic for determining when it can cheat was faulty, in that
C<&&> and C<||> on the right-hand side could fool it.  So C<($a,$b) =
$some_true_value && ($b,$a)> would end up assigning the value of C<$b> to
both scalars.

=item *

Perl no longer tries to apply lvalue context to the string in
C<("string", $variable) ||= 1> (which used to be an error).  Since the
left-hand side of C<||=> is evaluated in scalar context, that's a scalar
comma operator, which gives all but the last item void context.  There is
no such thing as void lvalue context, so it was a mistake for Perl to try
to force it [perl #96942].

=item *

C<caller> no longer leaks memory when called from the DB package if
C<@DB::args> was assigned to after the first call to C<caller>.  L<Carp>
was triggering this bug [perl #97010].

=item *

C<close> and similar filehandle functions, when called on built-in global
variables (like C<$+>), used to die if the variable happened to hold the
undefined value, instead of producing the usual "Use of uninitialized
value" warning.

=item *

When autovivified file handles were introduced in Perl 5.6.0, C<readline>
was inadvertently made to autovivify when called as C<readline($foo)> (but
not as C<E<lt>$fooE<gt>>).  It has now been fixed never to autovivify.

=item *

Calling an undefined anonymous subroutine (e.g., what $x holds after
C<undef &{$x = sub{}}>) used to cause a "Not a CODE reference" error, which
has been corrected to "Undefined subroutine called" [perl #71154].

=item *

Causing C<@DB::args> to be freed between uses of C<caller> no longer
results in a crash [perl #93320].

=item *

C<setpgrp($foo)> used to be equivalent to C<($foo, setpgrp)>, because
C<setpgrp> was ignoring its argument if there was just one.  Now it is
equivalent to C<setpgrp($foo,0)>.

=item *

C<shmread> was not setting the scalar flags correctly when reading from
shared memory, causing the existing cached numeric representation in the
scalar to persist [perl #98480].

=item *

C<++> and C<--> now work on copies of globs, instead of dying.

=item *

C<splice()> doesn't warn when truncating

You can now limit the size of an array using C<splice(@a,MAX_LEN)> without
worrying about warnings.

=item *

C<< $$ >> is no longer tainted.  Since this value comes directly from
C<< getpid() >>, it is always safe.

=item *

The parser no longer leaks a filehandle if STDIN was closed before parsing
started [perl #37033].

=item *

C<< die; >> with a non-reference, non-string, or magical (e.g., tainted)
value in $@ now properly propagates that value [perl #111654].

=back

=head1 Known Problems

=over 4

=item *

On Solaris, we have two kinds of failure.

If F<make> is Sun's F<make≥>, we get an error about a badly formed macro
assignment in the F<Makefile>.  That happens when F<./Configure> tries to
make depends.  F<Configure> then exits  0, but further F<make>-ing fails.

If F<make> is F<gmake>, F<Configure> completes, then we get errors related
to F</usr/include/stdbool.h>

=item *

The following CPAN modules have test failures with perl 5.16.  Patches have
been submitted for all of these, so hopefully there will be new releases
soon:

=over

=item *

L<Date::Pcalc> version 6.1

=item *

L<Module::CPANTS::Analyse> version 0.85

This fails due to problems in L<Module::Find> 0.10 and L<File::MMagic>
1.27.

=item *

L<PerlIO::Util> version 0.72

=back

=back

=head1 Acknowledgements

XXX Generate this with:

  perl Porting/acknowledgements.pl v5.14.0..HEAD

=head1 Reporting Bugs

If you find what you think is a bug, you might check the articles
recently posted to the comp.lang.perl.misc newsgroup and the perl
bug database at L<http://rt.perl.org/perlbug/>.  There may also be
information at L<http://www.perl.org/>, the Perl Home Page.

If you believe you have an unreported bug, please run the L<perlbug>
program included with your release.  Be sure to trim your bug down
to a tiny but sufficient test case.  Your bug report, along with the
output of C<perl -V>, will be sent off to perlbug@perl.org to be
analysed by the Perl porting team.

If the bug you are reporting has security implications, which make it
inappropriate to send to a publicly archived mailing list, then please
send it to perl5-security-report@perl.org.  This points to a closed
subscription unarchived mailing list, which includes all the core
committers, who will be able to help assess the impact of issues, figure
out a resolution, and help co-ordinate the release of patches to
mitigate or fix the problem across all platforms on which Perl is
supported.  Please only use this address for security issues in the Perl
core, not for modules independently distributed on CPAN.

=head1 SEE ALSO

The F<Changes> file for an explanation of how to view exhaustive details
on what changed.

The F<INSTALL> file for how to build Perl.

The F<README> file for general stuff.

The F<Artistic> and F<Copying> files for copyright information.

=cut
