=encoding utf8

=head1 Имя

perl5180delta - что нового в perl v5.18.0

=head1 Описание

Этот документ описывает различия между релизом v5.16.0 и релизом v5.18.0.

Если вы обновляетесь с более раннего релиза, такого как v5.14.0, сначала
прочтите L<perl5160delta>, который описывает различия между v5.14.0 и v5.16.0.

=head1 Улучшения ядра

=head2 Новый механизм экспериментальных возможностей

Впервые добавляемые экспериментальные возможности теперь требуют подобного
вызова:

    no warnings "experimental::feature_name";
    use feature "feature_name";  # будет выводить предупреждения без предыдущей
                                 # строки

Появилась новая категория предупреждений, называемых "экспериментальными",
содержащие предупреждения, которые выдаёт прагма L<feature>, когда подключаются
экспериментальные возможности.

Впервые добавляемые экспериментальные возможности также будут содержать
специальные идентификаторы предупреждения, которые состоят из "experimental::" с
последующим названием возможности.  (Есть план для расширения действия этого
механизма в конечном счёте на все предупреждения, позволяя включать или
отключать их персонально, а не только по категориям.)

Указывая

    no warnings "experimental::feature_name";

вы берёте ответственность за любую поломку, которая может возникнуть в связи с
изменением или удалением соответствующей возможности.

Так как некоторые возможности (такие как C<~~> или C<my $_>) теперь выводят
предупреждение об их экспериментальном характере и вам может потребоваться
отключить их в коде, который может также быть запущен под perl, который не
распознаёт этих категорий предупреждений, рассмотрите возможность использования
прагмы C<if> таким образом:

    no if $] >= 5.018, 'warnings', "experimental::feature_name";

Существующие экспериментальные возможности также могут начать выводить эти
предупреждения. Пожалуйста обратитесь к L<perlexperiment> за информацией о тех
возможностях, которые рассматриваются как экспериментальные.

=head2 Пересмотр реализации хэша

Изменения в реализации хэшей в perl v5.18.0 станут наиболее заметными
изменениями в поведении существующего кода.

По умолчанию два различных хэша с идентичными ключами и значениями могут
возвращать их содержимое в различном порядке, тогда как раньше порядок был
одинаковым.

При столкновении с этими изменениями, ключевым моментом для исправления
последствий станет принятие правила, что B<хэши - это беспорядочные коллекции> и
действие в соответствии с ним.

=head3 Рандомизация хэша

Ключ (seed) используемый хэш-функцией Perl теперь является случайным.  Это
означает что порядок, в котором ключи/значения будут возвращены из функций
C<keys()>, C<values()> и C<each()>, будет различаться от запуска к запуску.

Это изменение было сделано, чтобы сделать хэши Perl более устойчивыми к атакам
на алгоритмическую сложность, а также мы обнаружили, что это выявляет ошибки
зависимости от порядка хэша, делая их простыми для обнаружения.

Для разработчиков утилит сборки есть повод вложить силы в дополнительную
инфраструктуру для тестирования подобных вещей.  Запуская тесты несколько раз
подряд и сравнивая результаты, можно легко выявить зависимости от порядка хэша в
коде.  Авторам настойчиво рекомендуется не демонстрировать ключ рандомизации
хэшей Perl для небезопасной публики.

Кроме того, каждый хэш имеет свой собственный порядок итерации, что делает
значительно более сложным определение какой ключ рандомизации хэша используется
в данный момент.

=head3 Новые хэш-функции

Perl v5.18 включает поддержку множества хэш-функций и меняет хэш-функцию по
умолчанию (на ONE_AT_A_TIME_HARD), вы можете выбрать другой алгоритм указывая
параметр при компиляции.  Для просмотра текущего списка обратитесь к документу
F<INSTALL>. Обратите внимание, что начиная с Perl v5.18 мы можем рекомендовать
использовать только хэш-функцию по умолчанию или SIPHASH. Все другие имеют
известные проблемы с безопасностью и могут использоваться только для
исследовательских целей.

=head3 Переменная окружения PERL_HASH_SEED теперь принимает шестнадцатиричное значение

C<PERL_HASH_SEED> больше не принимает целочисленное значение как параметр;
вместо этого ожидается бинарное значение закодированное в шестнадцатиричную
строку, как например, "0xf5867c55039dc724". Это сделано для того, чтобы
поддерживать ключи рандомизации хэша произвольной длины, которые могут превышать
лимит целого числа (int).  (SipHash использует ключ в 16 байт).

=head3 Добавлена переменная окружения PERL_PERTURB_KEYS

Переменная окружения C<PERL_PERTURB_KEYS> позволяет контролировать уровень
случайности, применяемый к C<keys> и подобным.

Когда C<PERL_PERTURB_KEYS> установлен в 0, perl не будет рандомизировать порядок
ключей.  Шанс, что изменения в C<keys> из-за вставки будут такими же как в
предыдущих perl, в основном из-за изменения размера ячейки.


Когда C<PERL_PERTURB_KEYS> установлен в 1, perl будет рандомизировать ключи в
неповторяющемся порядке. Шанс, что вывод C<keys> изменится в результате вставки,
крайне высок.  Это наиболее безопасно и является режимом по умолчанию.

Когда C<PERL_PERTURB_KEYS> установлен в 2, perl будет рандомизировать ключи в
воспроизводимом порядке. Повторные запуски одной и той же программы каждый раз
будут выводить один и тот же результат.

C<PERL_HASH_SEED> подразумевает установку нестандартного C<PERL_PERTURB_KEYS>.
Устанавливая C<PERL_HASH_SEED=0> (именно один 0) устанавливает
C<PERL_PERTURB_KEYS=0> (рандомизация хэша отключена); установка
C<PERL_HASH_SEED> в любое другое значение подразумевает C<PERL_PERTURB_KEYS=2>
(детерминированную и повторяемую рандомизацию хэша). Явное указание
C<PERL_PERTURB_KEYS> в другое значение переопределяет это поведение.

=head3 Hash::Util::hash_seed() теперь возвращает строку

Hash::Util::hash_seed() теперь возвращает строку, вместо целого числа.  Это
необходимо, чтобы сделать инфраструктурную поддержку для ключей рандомизации
хэша произвольной длины, превышающей размер целого числа.  (SipHash использует
ключ размером 16 байт).

=head3 Изменился вывод PERL_HASH_SEED_DEBUG

Переменная окружения PERL_HASH_SEED_DEBUG теперь заставляет perl показывать оба
параметра: хэш-функцию, с которой был собран perl, I<и> ключ рандомизации в
шестнадцатиричном виде, используемый в текущем процессе.  Существующий код,
обрабатывающий этот вывод, должен быть изменён под новый формат.  Пример нового
формата:

    $ PERL_HASH_SEED_DEBUG=1 ./perl -e1
    HASH_FUNCTION = MURMUR3 HASH_SEED = 0x1476bb9f

=head2 Обновление до Юникода 6.2

Perl теперь поддерживает стандарт Юникода версии 6.2.  Список отличий от Юникода
6.1 доступен на L<http://www.unicode.org/versions/Unicode6.2.0>.

=head2 Псевдоним символа теперь может включать символы не из диапазона Latin1

Теперь возможно определить ваши собственные имена для использования в
C<\N{...}>, C<charnames::vianame()> и т.п. Эти имена теперь могут включать
символы из всего диапазона Юникода.  /то позволяет использовать имена на вашем
родном языке, а не только Английском. Некоторые ограничения накладываются на
символы, которые могут быть использованы (вы не можете использовать имена со
знаками пунктуации внутри, например).  Смотрите L<charnames/CUSTOM ALIASES>.

=head2 Новые проверки DTrace

Следующие новые датчики (probes) были добавлены в DTrace:

=over 4

=item *

C<op-entry>

=item *

C<loading-file>

=item *

C<loaded-file>

=back

=head2 C<${^LAST_FH}>

Эта новая переменная даёт доступ к последнему файловому дескриптору, из которого
происходило чтение.  Это дескриптор, который используется в C<$.>, C<tell> и
C<eof> без аргументов.

=head2 Операции со множествами в регулярных выражениях

Это B<экспериментальная> возможность, которая позволяет проверять совпадения в
объединении, пересечении и другими операциями со множествами кодов символов,
подобно модулю L<Unicode::Regex::Set>.  Это также может использоваться для
расширения возможностей обработки в C</x> [заключённых в скобки] классов
символов и как замена свойств, определённых пользователем, позволяя создавать
более сложные выражения, чем это было возможно до этого.  Смотрите
L<perlrecharclass/Extended Bracketed Character Classes>.

=head2 Лексические подпрограммы

Эта возможность по прежнему рассматривается B<экспериментальной>.  Для её
включения необходимо:

    use 5.018;
    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";

Теперь вы можете декларировать подпрограммы с помощью C<state sub foo>, C<my sub
foo> и C<our sub foo>.  (C<state sub> также требует, чтобы возможность "state"
была включена, если только вы не записывает её в виде C<CORE::state sub foo>.)

C<state sub> создаёт подпрограмму видимую внутри лексической области видимости,
в которой она определена.  Подпрограмма является разделяемой между вызовами внешней
подпрограммы.

C<my sub> декларирует лексическую подпрограмму видимую внутри лексической
области видимости, в которой она определена.  C<state sub> в целом работает
немного быстрее, чем C<my sub>.

C<our sub> декларирует лексический псевдоним для подпрограммы пакета с тем же
именем.

Для большей информации обратитесь к L<perlsub/Lexical Subroutines>.

=head2 Вычисляемые метки

Для управления циклом C<next>, C<last> и C<redo>, а также специального
оператора C<dump>, теперь можно использовать произвольное выражение, для
вычисления меток во время работы программы.  Ранее любые аргументы, которые не
являлись константами рассматривались как пустая строка.

=head2 Больше CORE:: подпрограмм

Ещё несколько встроенных функций было добавлено как подпрограммы в пространство
имён CORE::, т.е. те непереопределяемые ключевые слова, которые могут быть
определены без специальных парсеров: C<defined>, C<delete>, C<exists>,
C<glob>, C<pos>, C<protoytpe>, C<scalar>, C<split>, C<study> и C<undef>.

Так как некоторые из них имеют прототипы, C<prototype('CORE::...')> был изменён
таким образом, чтобы не делать различий между переопределяемыми и
непереопределяемыми ключевыми словами.  Это было необходимо, чтобы согласовать
C<prototype('CORE::pos')> с C<prototype(&CORE::pos)>.

=head2 C<kill> с отрицательным именем сигнала

C<kill> всегда допускал использование отрицательного номера сигнала, который
убивал группу процессов, вместо одного процесса.  Также он разрешал использовать
и имена сигналов.  Но вёл себя непоследовательно, поскольку отрицательные имена
сигналов рассматривались как 0.  Теперь отрицательные имена сигналов, как
например, C<-INT> поддерживаются и рассматриваются по аналогии, что и -2
[perl #112990].

=head1 Безопасность

=head2 Смотрите также: пересмотр реализации хэша

Некоторые изменения в L<пересмотре реализации хэша|/"Пересмотр реализации хэша">
были сделаны для улучшения безопасности.  Пожалуйста, прочтите эту секцию.

=head2 Предупреждение о безопасности в документации C<Storable>

Документация C<Storable> теперь включает секцию, которая предупреждает читателя
об опасности принятия данных формата Storable от источников, к которым нет
доверия.  В кратком изложении, десереализация некоторых типов данных может
привести к загрузке модулей и другим вариантам выполнения кода.  Это
задокументированное и ожидаемое поведение, но с другой стороны открывает
вектор атаки для злоумышленников.

=head2 C<Locale::Maketext> позволял включение произвольного кода через специальный темплейт

Если пользователи имеют возможность предоставлять строки переводов для
Locale::Maketext, это может быть использовано для вызова произвольной Perl
подпрограммы, доступной в текущем процессе.

Это было исправлено, но по прежнему доступна возможность вызова любого метода,
предоставляемого самим C<Locale::Maketext> или подклассом, который вы
используете. Один из таких методов в свою очередь выполняет встроенную Perl
подпрограмму C<sprintf>.

В целом, разрешать пользователям делать перевод без аудита их результата
является плохой идеей.

Эта уязвимость задокументирована в CVE-2012-6329.

=head2 Избегайте вызова memset с отрицательным цислом

Плохо написанный perl код, который даёт возможность атакующему указывать число
повторов строки в операторе C<x> уже подвержен атакам на отказ в обслуживании
при исчерпании памяти.  Уязвимость в версиях perl до v5.15.5 позволяет сверх
того привести к переполнение кучи, что в совокупности с использованием glibc
версии до 2.16, позволяет привести к выполнению произвольного кода.

Эта уязвимость получила идентификатор CVE-2012-5195 и была обнаружена Тимом
Брауном (Tim Brown).

=head1 Несовместимые изменения

=head2 Смотрите также: пересмотр реализации хэша

Некоторые изменения в L<пересмотре реализации хэша|/"Пересмотр реализации хэша">
несовместимы с предыдущими версиями perl. Пожалуйста прочтите эту секцию.

=head2 Неизвестное имя символа в C<\N{...}> теперь является синтаксической ошибкой

Ранее выводилось предупреждение и производилось замещение Юникод символом
замещения REPLACEMENT CHARACTER. Стандарт Юникод теперь рекомендует обрабатывать
данную ситуацию как ошибку.  Кроме того, предыдущее поведение приводило к
некоторым сбивающим с толку предупреждениями и действиям, и, так как символ
REPLACEMENT CHARACTER не имеет других применений, кроме как замены для
неизвестного символа, любой код, который имеет такую проблему, - кривой.

=head2 Ранее устаревший символ в C<\N{}> псевдониме символа теперь является ошибкой.

Начиная с v5.12.0 было помечено устаревшим использование некоторых символов в
определённых пользователем C<\N{...}> именах символов.  Теперь это вызывает
синтаксическую ошибку. Например, теперь считается ошибкой начинать имена с цифр,
как в случае

 my $undraftable = "\N{4F}";    # Синтаксическая ошибка!

или иметь запятые где угодно в имени. Смотрите L<charnames/CUSTOM ALIASES>.

=head2 C<\N{BELL}> теперь соответствует коду U+1F514 вместо U+0007

Unicode 6.0 использовал имя "BELL" для другого кода символа, вместо
традиционного значения.  Начиная с Perl 5.14 использование этого имени
по-прежнему ссылалось на код U+0007, но выводило предупреждение об устаревшей
конструкции.  Теперь "BELL" ссылается на код U+1F514, а именем для U+0007 стало
"ALERT".  Все соответствующие функции в L<charnames> были обновлены.

=head2 Новые ограничения в многосимвольном нечувствительном к регистру сравнении в регулярных выражениях для заключённых в скобки классах символов

Юникод теперь убрал свои ранние рекомендации для регулярных выражений для
автоматической обработки случаев, когда один символ может совпадать с
несколькими символами в нечувствительном к регистру сравнении, например, буква
LATIN SMALL LETTER SHARP S и последовательность C<ss>.  Поскольку оказалось, что
это не может быть выполнено корректно во всех случаях.  Так как Perl пытается
сделать сделать всё от него возможное, он продолжит делать так, как раньше. (Мы
рассматриваем вариант опции, для отключения этого поведения). Однако новые
ограничения были добавлены на подобные сравнения, когда они происходят в
[заключённых в скобки] классах символов.  Люди, указывающие вещи на подобии
C</[\0-\xff]/i>, бывают удивлены, когда это совпадает с последовательностью из
двух символов C<ss> (поскольку LATIN SMALL LETTER SHARP S входит в этот
диапазон).  Это поведение также рассогласованно с использованием свойств вместо
диапазонов: C<\p{Block=Latin1}> также включает LATIN SMALL LETTER SHARP S, но
C</[\p{Block=Latin1}]/i> не совпадает с C<ss>.

По новым правилам, чтобы происходило совпадение при регистронезависимом
сравнении с несколькими символами внутри заключённого в скобки класса символов,
требуется, чтобы символ был указан там явно и не являлся конечным символом
диапазона.  Это хорошо соответствует принципу наименьшего удивления.  Смотрите
L<perlrecharclass/Bracketed Character Classes>.  Обратите внимание, что ошибка
[perl #89774] была исправлена, как часть этого изменения, препятствовавшая
работе сравнения в полной мере.

=head2 Ясные правила для имён переменных и идентификаторов

В результате недосмотра, односимвольные имена переменных в v5.16 были полностью
неограниченны.  Это открывало двери для разного рода безумств.  Начиная с v5.18
они теперь следуют правилам других идентификаторов и в дополнении допускающих
использование символов, соответствующих свойству C<\p{POSIX_Punct}>.

Теперь нет никакой разницы в разборе идентификаторов, указанных с использованием
фигурных скобок и без них.  Например, perl допускал использование C<${foo:bar}>
(с одиночным двоеточием), но не допускал C<$foo:bar>.  Теперь оба случая
обрабатываются одним участком кода и оба обрабатываются одинаково: оба
запрещены.  Обратите внимание, что это изменение касается границам допустимого в
задании буквенных идентификаторов, а не других выражений.

=head2 Вертикальная табуляция теперь пробельный символ

Никто не может вспомнить почему C<\s> не совпадает с C<\cK> - вертикальной
табуляцией.  Теперь совпадает.  Учитывая экстремальный раритет данного символа,
ожидается очень небольшой число поломок.  Как было сказано, теперь это означает,
что:

C<\s> в регулярных выражениях всегда совпадает с вертикальной табуляцией при
любых условиях.

Литеральные вертикальные табуляции в регулярных выражениях теперь игнорируются,
когда используется модификатор C</x>.

Лидирующие символы вертикальной табуляции, поодиночке или вперемешку с другими
пробельными символами теперь игнорируются при интерпретации строки как числа.
Например:

  $dec = " \cK \t 123";
  $hex = " \cK \t 0xF";

  say 0 + $dec;   # было 0 с предупреждением, теперь 123
  say int $dec;   # было 0, стало 123
  say oct $hex;   # было 0, стало  15

=head2 C</(?{})/> и C</(??{})/> были сильно переработаны

Реализация этой возможности была практически полностью переписана.  Хотя
основной целью было исправление ошибок, некоторое поведение, особенно связанное
с областью видимости лексических переменных, было изменено.  Это описано более
полно в секции L</Некоторые исправленные ошибки>.

=head2 Более строгий синтаксический разбор подстановки замены

Теперь больше невозможно злоупотреблять особенностью разбора синтаксиса
C<s///e>, как в данном случае:

    %_=(_,"Just another ");
    $_="Perl hacker,\n";
    s//_}->{_/e;print

=head2 C<given> теперь ссылается на глобальную C<$_>

Вместо присвоения явной лексической переменной C<$_>, C<given> теперь делает
глобальную C<$_> псевдонимом для своего аргумента, также как и  C<foreach>.
Однако он по-прежнему использует лексическую C<$_>, если присутствует
лексическая C<$_> в данной области видимости (и снова, также как C<foreach>)
[perl #114020].

=head2 Возможности из семейства умного сравнения теперь являются экспериментальными

Умное сравнение, которое было добавлено в v5.10.0 и значительно пересмотрено в
v5.10.1, постоянно было источником недовольства.  Несмотря на некоторое число
полезных возможностей, оно всё же признавалось проблемным и сбивающим с толку
как для пользователей, так и разработчиков Perl.  Было сделано несколько
предложений по исправлению проблемы.  Стало ясно, что умное сравнение
практически наверняка будет либо изменено или исчезнет в будущем.  Полагаться на
его текущее поведение не рекомендуется.

Теперь будут выдаваться предупреждения, когда парсер будет видеть C<~~>,
C<given> или C<when>.  Для отключения этих предупреждений, вы можете добавить
данную строку в соответствующую область видимости:

  no if $] >= 5.018, "experimental::smartmatch";

Тем не менее рассматривайте замену использования этих возможностей, так как они
могут изменить своё поведение снова перед тем как вновь станут стабильными.

=head2 Лексическая C<$_> теперь является экспериментальной

Начиная со своего появления в Perl v5.10, она вызывала много путаницы без
ясного решения:

=over

=item *

Различные модули (например, List::Util) ожидают, что колбэк-функции используют
глобальную C<$_>.  C<use List::Util 'first'; my $_; first { $_ == 1 } @list> не
будет работать так, как ожидается.

=item *

Объявление C<my $_> ранее в том же файле может вызывать вывод сбивающего с толку
предупреждения замыкания.

=item *

Символ "_" в прототипе подпрограммы позволяет вызываемой подпрограмме иметь
доступ к вашей лексической C<$_>, так что она в итоге не является по-настоящему
приватной.

=item *

Несмотря на это, подпрограммы с прототипом "(@)" или методы не могут получить
доступ к лексической переменной C<$_> вызывающего кода, если только они не
написаны с использованием XS.

=item *

Но даже XS подпрограммы не могут получить доступ к лексической переменной C<$_>,
объявленной не в вызывающей подпрограмме, а во внешней области видимости, если
эта подпрограмма не упоминает C<$_> или не использует операции, которые по
умолчанию взаимодействуют с C<$_>.

=back

Мы надеемся, что лексическая C<$_> может быть реабилитирована, но это может
вызвать изменения в её поведении.  Пожалуйста используйте её с осторожностью,
пока она не станет стабильной.

=head2 readline() в C<$/ = \N> теперь читает N символов, а не N байтов

Ранее при чтении из потока со слоями I/O, такими как C<encoding>, функция
readline() иначе известная как оператор C<< <> >> читало I<N> байт с верхнего
слоя. [perl #79960]

Теперь, вместо этого читается I<N> символов.

Никаких изменений в поведении при чтении из потоков без дополнительных слоёв
нет, так как байты точно соответствуют символам.

=head2 Переопределённый C<glob> теперь передаёт один аргумент

Переопределение C<glob> раньше передавало магический недокументированный второй
аргумент, который идентифицировал вызывающий его код.  Ничего на CPAN не
использовало это, поэтому изменение было внесено как исправление бага и аргумент
был удалён.  Если вам действительно необходимо идентифицировать вызывающую
подпрограмму, смотрите L<Devel::Callsite> на CPAN.

=head2 Синтаксический разбор встроенной документации (here doc)

Тело встроенного документа внутри оператора цитирования теперь всегда начинается
на строке после маркера "<<foo".  Ранее было задокументировано, что оно
начинается на следующей строке, содержащей оператор цитирования, но это было
лишь изредка так [perl #114040].

=head2 Цифробуквенные операторы должны быть теперь отделены от закрывающего ограничителя регулярного выражения

Теперь вы не можете записывать так:

 m/a/and 1

Вместо этого вы должны записать:

 m/a/ and 1

с пробелом отделяющим оператор от закрывающего ограничителя регулярного
выражения.  Отсутствие пробела приведёт к выводу предупреждения об устаревшем
функционале, начиная с Perl v5.14.0.

=head2 qw(...) теперь не может быть использован в качестве скобок

Списки C<qw> раньше заставляли парсер думать, что они всегда заключены в скобки.
Это позволяло использовать удивительные конструкции такие как C<foreach $x qw(a
b c) {...}>, которые на самом деле должны были быть записаны C<foreach $x (qw(a
b c)) {...}>. Это иногда приводило лексический анализатор в неверное состояние,
поэтому они не работали в полной мере, и схожая запись C<foreach qw(a
b c) {...}>, которая ожидалась дозволительной, вообще никогда не работала.

Эти побочные эффекты C<qw> теперь удалены.  Они были помечены устаревшими
начиная с Perl v5.13.11.  Теперь обязательно требуется использовать скобки
везде, где грамматика требует их.

=head2 Взаимодействие лексических и обычных предупреждений

Включение любых лексических предупреждений использовалось раньше для отключения
всех предупреждений по умолчанию, если лексические предупреждения не были ещё
подключены:

    $*; # предупреждение об устаревшей конструкции
    use warnings "void";
    $#; # предупреждение о пустом контексте; нет предупреждения об устаревшей
        # конструкции

Теперь C<debugging>, C<deprecated>, C<glob>, C<inplace> и C<malloc> категории
предупреждений остаются включёнными при включении лексических предупреждений
(разумеется если они не отключены через C<no warnings>).

Это может привести к появлению предупреждений об устаревших конструкциях в коде,
который раньше не выдавал предупреждений.

Это единственные подобные категории, состоящие только из предупреждений по
умолчанию.  Предупреждения по умолчанию в других категориях по прежнему
отключены при использовании C<< use warnings "category" >>, так как у нас пока
нет инфраструктуры за контролем индивидуальных предупреждений.

=head2 C<state sub> и C<our sub>

По случайности, C<state sub> и C<our sub> были эквивалентны обычному C<sub>,
так что была возможность даже создать анонимную подпрограмму с помощью
C<our sub { ... }>.  Теперь это запрещено вне действия возможности
"lexical_subs".  При включении возможности "lexical_subs" они получает новый
смысл, описанный в L<perlsub/Lexical Subroutines>.

=head2 Значения, хранимые в переменных окружения, принудительно переводятся в байтовые строки

Значение, хранимое в переменной окружения всегда приводилось к строке.  В данном
выпуске оно конвертируется в байтовую строку.  Раньше она приводилась только к
строковому виду.  Если строка utf8 и аналог C<utf8::downgrade()> срабатывает, то
используется полученный результат, в противном случае используется эквивалент
C<utf8::encode()> и выводится предупреждение о широком символе
(L</Diagnostics>).

=head2 C<require> умирает на нечитаемых файлах

Когда C<require> обнаруживает нечитаемый файл, он теперь умирает.  Раньше файл
игнорировался и продолжался поиск в директориях в C<@INC> [perl #113422].

=head2 C<gv_fetchmeth_*> и SUPER

Различные XS функции C<gv_fetchmeth_*> раньше рассматривали пакет, чьё имя
заканчивается на C<::SUPER> по особому.  Поиск метода в пакете C<Foo::SUPER>
рассматривался как поиск C<SUPER> метода в пакете C<Foo>.  Больше это не так.
Для поиска метода C<SUPER> передавайте стэш C<Foo> и флаг C<GV_SUPER>.

=head2 Первый аргумент C<split> теперь интерпретируется более согласовано

После некоторых изменений ранее в v5.17, поведение C<split> было упрощено: если
аргумент шаблона вычисляется в строку, содержащую один пробел, то оно
обрабатывается также как и I<литеральная> строка, содержащая один пробел как
было раньше.

=head1 Устаревшие конструкции

=head2 Удаление модулей

Следующие модули будут удалены из базового дистрибутива в будущих релизах и
потребуют в будущем установки со CPAN.  В дистрибутивах на CPAN, требующие эти
модули, потребуется указывать как и как зависимости.

Версии модулей в базовом дистрибутиве теперь будут выдавать предупреждения из
категории C<"устаревшее"> для предупреждения вас об этом факте.  Для отключения
этих предупреждений об устаревании, установите эти модули со CPAN.

Обратите внимание, что (за редким исключением) это прекрасные модули, которые мы
призываем вас продолжать использовать.  Их исключение из базового состава в
основном следствие необходимости предварительной подготовки (bootstrapping)
полнофункциональной, CPAN-совместимой инсталляции Perl, а не обеспокоенность их
дизайном.

=over

=item L<encoding>

Использование этой прагмы теперь крайне не рекомендуется.  Она объединяет
кодирование исходного текста и кодирование данных ввода/вывода, повторно
интерпретирует управляющие последовательности в исходном тексте (сомнительный
выбор) и приводит к UTF-8 багам во всех приложениях, обрабатывающим строки
символов.  Она сломана как и ожидалось и не может быть исправлена.

Для использования не-ASCII литеральных символов в исходном коде, пожалуйста
смотрите L<utf8>.  Для работы с текстовым данными ввода/вывода, пожалуйста
смотрите L<Encode> и L<open>.

=item L<Archive::Extract>

=item L<B::Lint>

=item L<B::Lint::Debug>

=item L<CPANPLUS> и все включенные в C<CPANPLUS::*> модули

=item L<Devel::InnerPackage>

=item L<Log::Message>

=item L<Log::Message::Config>

=item L<Log::Message::Handlers>

=item L<Log::Message::Item>

=item L<Log::Message::Simple>

=item L<Module::Pluggable>

=item L<Module::Pluggable::Object>

=item L<Object::Accessor>

=item L<Pod::LaTeX>

=item L<Term::UI>

=item L<Term::UI::History>

=back

=head2 Устаревшие утилиты

Следующие утилиты будут удалены из базового дистрибутива в будущих релизах, так
как связанные с ними модули устарели.  Они по-прежнему будут доступны в
соответствующем CPAN дистрибутиве.

=over

=item L<cpanp>

=item C<cpanp-run-perl>

=item L<cpan2dist>

Это утилиты часть дистрибутива C<CPANPLUS>.

=item L<pod2latex>

Эта утилита часть дистрибутива C<Pod::LaTeX>.

=back

=head2 PL_sv_objcount

Эта глобальная в интерпретаторе переменная, раньше учитывала общее число Perl
объектов в интерпретаторе.  Она более не сопровождается и будет удалена в Perl
v5.20.

=head2 Пять дополнительных символов должны быть экранированы в шаблонах с C</x>

В шаблонах регулярных выражений, компилируемых с ключом C</x>, Perl игнорирует 6
символов пробельного типа, такие как пробел и табуляция. Однако в стандарте
Юникод рекомендуется рассматривать как пробельные 11 символов. Мы будем
соответствовать этому стандарту в будущей версии Perl.  В данный момент,
использование этих недостающих символов в неэкранированном виде будет приводить
к выводу предупреждений, если предупреждения не отключены. Вот эти 5 символов:

    U+0085 NEXT LINE
    U+200E LEFT-TO-RIGHT MARK
    U+200F RIGHT-TO-LEFT MARK
    U+2028 LINE SEPARATOR
    U+2029 PARAGRAPH SEPARATOR

=head2 Определённые пользователем имена символов с неожиданными пробелами

Определённые пользователем имена символов с завершающими или несколькими подряд
идущими пробелами с большой вероятностью являются опечатками.  Теперь такая
запись выдаёт предупреждение, на основании того, что его использование вряд ли
требует избыток пробелов.

=head2 Различные функции, вызываемые в XS программах теперь устарели

Все функции, использовавшиеся для классификации символов, будут удалены из
будущей версии Perl и не должны использоваться.  При помощи C компилятора
(например, gcc) сборка любого файла, которая использует любую из этих функций
будут выдавать предупреждение.  Они не были предназначены для публичного
использования; существуют эквивалентные более быстрые макросы для большинства из
них.

Смотрите L<perlapi/Character classes>.  Это полный список:

C<is_uni_alnum>, C<is_uni_alnumc>, C<is_uni_alnumc_lc>,
C<is_uni_alnum_lc>, C<is_uni_alpha>, C<is_uni_alpha_lc>,
C<is_uni_ascii>, C<is_uni_ascii_lc>, C<is_uni_blank>,
C<is_uni_blank_lc>, C<is_uni_cntrl>, C<is_uni_cntrl_lc>,
C<is_uni_digit>, C<is_uni_digit_lc>, C<is_uni_graph>,
C<is_uni_graph_lc>, C<is_uni_idfirst>, C<is_uni_idfirst_lc>,
C<is_uni_lower>, C<is_uni_lower_lc>, C<is_uni_print>,
C<is_uni_print_lc>, C<is_uni_punct>, C<is_uni_punct_lc>,
C<is_uni_space>, C<is_uni_space_lc>, C<is_uni_upper>,
C<is_uni_upper_lc>, C<is_uni_xdigit>, C<is_uni_xdigit_lc>,
C<is_utf8_alnum>, C<is_utf8_alnumc>, C<is_utf8_alpha>,
C<is_utf8_ascii>, C<is_utf8_blank>, C<is_utf8_char>,
C<is_utf8_cntrl>, C<is_utf8_digit>, C<is_utf8_graph>,
C<is_utf8_idcont>, C<is_utf8_idfirst>, C<is_utf8_lower>,
C<is_utf8_mark>, C<is_utf8_perl_space>, C<is_utf8_perl_word>,
C<is_utf8_posix_digit>, C<is_utf8_print>, C<is_utf8_punct>,
C<is_utf8_space>, C<is_utf8_upper>, C<is_utf8_xdigit>,
C<is_utf8_xidcont>, C<is_utf8_xidfirst>.

В дополнении к этому три функции, которые никогда не работали правильно теперь
объявлены устаревшими:
C<to_uni_lower_lc>, C<to_uni_title_lc> и C<to_uni_upper_lc>.

=head2 Определённые редкие случаи использования обратной косой черты внутри регулярных выражений теперь являются устаревшими

Существуют три пары символов, которые Perl распознаёт как метасимволы в
шаблонах регулярных выражений: C<{}>, C<[]> и C<()>.  Они могут использоваться
для разделения шаблонов, как например:

  m{foo}
  s(foo)(bar)

Поскольку они являются метасимволами, они имеют специальное значение в шаблонах
регулярных выражений и оказывается, что вы не можете отключить это специальное
значение при обычном использовании предшествующего символа обратной косой, если
вы используете их сдвоенными внутри шаблона, ограниченного ими же. Например:

  m{foo\{1,3\}}

обратная косая черта не изменяет поведение и это совпадает с S<C<"fo">> с
последующим одним или тремя включениями C<"o">.

Подобное использование, где они интерпретируются как метасимволы, крайне редкое;
мы полагаем, что такого нет, например, на всём CPAN.  Следовательно эта
устаревшая конструкция затронет очень немного кода.  Однако будет выдано
уведомление, что любой подобный код должен быть изменён, что в свою очередь даст
нам возможность изменить поведение будущих версий Perl так, что обратная косая
черта будет действовать без страха, что мы молча сломаем чей-то существующий
код.

=head2 Разделение символов C<(?> и C<(*> в регулярных выражениях

Теперь выводится предупреждение об устаревшей конструкции, если C<(> и C<?>
разделены пробелом или комментарием в шаблонах регулярного выражения C<(?...)>.
То же относится к случаю, если C<(> и C<*> разделены в конструкции
C<(*VERB...)>.

=head2 Пред-PerlIO реализации ввода/вывода

В теории вы можете собрать perl без PerlIO.  Вместо него вам придётся
использовать обёртку вокруг stdio и sfio.  На практике это не очень полезно.
Это не так хорошо протестировано, и без какой-либо поддержки для слоёв
ввода/вывода или (таким образом) Юникода это лишь небольшой кусок perl.
Возможность сборки без PerlIO скорее всего будет удалена в следующей версии
perl.

PerlIO поддерживает слой C<stdio>, если желательно использование stdio.  Точно
также слой sfio может быть создан в будущем, если будет нужен.

=head1 Устаревающий функционал

=over

=item *

Платформы без инфраструктурной поддержки

Обе платформы Windows CE и z/OS исторически поддерживались и на данный момент не
собираются успешно и нерегулярно тестируются.  Прилагаются усилия для изменения
ситуации, но не гарантируется, что платформы безопасны и поддерживаемы.  Если
они не начнут собираться и регулярно тестироваться, их поддержка может быть
удалена в будущих релизах.  Если у вас есть интерес к этим платформам и вы
можете потратить своё время, опыт или аппаратное обеспечение для помощи в
поддержке этих платформ, пожалуйста дайте знать разработчикам написав письмо в
C<perl5-porters@perl.org>.

Некоторые платформы, которые похоже окончательно мертвы, также в списке на
удаление к v5.20.0:

=over

=item DG/UX

=item NeXT

=back

Также мы думаем, что вероятно текущие версии Perl больше не собираются на
AmigaOS, DJGPP, NetWare (нативно), OS/2 и Plan 9.  Если вы используете Perl на
этих платформах и имеете интерес к обеспечению будущего Perl на них, пожалуйста
свяжитесь с нами.

Мы уверенны, что Perl уже долго не может быть собран на смешанных endian
архитектурах (такие как PDP-11) и намереваемся удалить весь оставшийся код их
поддержки. Также код поддержки давно неподдерживаемого GNU dld будет скоро
удалён, если никто не заявит о себе, как о заинтересованном пользователе.

=item *

Обмен $< и $>

Perl поддерживал идиому обмена $< и $> (а также $( и $)) для временного сброса
привилегий, начиная с 5.0, как например:

    ($<, $>) = ($>, $<);

Однако такая идиома, изменяющая реальный идентификатор пользователя/группы, и
которая может иметь нежелательные побочные эффекты, больше не является полезной
на любых платформах, поддерживаемых perl, и усложняет реализацию этих переменных
и присвоения списком в целом.

Как альтернатива, рекомендуется присваивать только C<< $> >>:

    local $> = $<;

Смотрите также: L<Setuid Demystified|http://www.cs.berkeley.edu/~daw/papers/setuid-usenix02.pdf>.

=item *

C<microperl> давно сломан и неясно его нынешнее предназначение, будет удалён.

=item *

Поправлена семантика C<< "\Q" >> в строках с двойными кавычками при комбинации с
другими экранирующими последовательностями.

Присутствовало несколько ошибок и противоречий, затрагивающие комбинацию C<\Q> и
экранированных записей C<\x>, C<\L> и т.п. внутри пары C<\Q...\E>.  Это требует
исправления, что это обязательно приведёт к изменению текущего поведения.  Эти
изменения пока ещё не устоялись.

=item *

Использование записи C<$x>, где C<x> представляет собой любой (непечатный)
контрольный символ, будет запрещено в будущей версии Perl.  Используйте вместо
этого C<${x}> (где снова C<x> означает управляющий символ), а ещё лучше, C<$^A>,
где C<^> - это знак вставки (CIRCUMFLEX ACCENT), а C<A> означает любой символ,
указанный в списке в конце L<perlebcdic/OPERATOR DIFFERENCES>.

=back

=head1 Увеличение производительности

=over 4

=item *

Списочное определение лексических переменных (C<my($x, $y)>) теперь
оптимизировано к одной операции и следовательно работает быстрее, чем раньше.

=item *

Была добавлена новая константа для C препроцессора C<NO_TAINT_SUPPORT>, которая,
если установлена, полностью отключает поддержку taint режима.  Использование
флагов -T или -t в командной строке приведёт к фатальной ошибке.  Будьте
осторожны, поскольку и базовые тесты и многие тесты CPAN дистрибутивов будут
провалены с этим изменением.  С другой стороны, предоставляется небольшое
повышение производительности, связанное с уменьшением ветвления кода.

B<Не устанавливайте эту константу, если вы точно не понимаете к чему это вас
приведёт>.


=item *

C<pack> с аргументом константой теперь вычисляется в константу в большинстве
случаев. [perl #113470].

=item *

Ускорение регулярных выражений при поиске совпадений с Юникод свойствами.
Наиболее заметное ускорение получено для C<\X>, "расширенный кластер графем"
Юникода.  Ускорение для него составляет где-то 35% - 40%.  Заключённые в скобки
классы символов, например, C<[0-9\x{100}]>, содержащие свыше 255 кодовых точек,
также стали быстрее.

=item *

На платформах, поддерживающие их, некоторые бывшие макросы теперь были
реализованы как статические встроенные (inline) функции.  Это должно ускорить
их значительно на не-GCC платформах.

=item *

Оптимизация хэшей в логическом контексте было расширенно и на случаи
C<scalar(%hash)>, C<%hash ? ... : ...> и C<sub { %hash || ... }>.

=item *

Операторы файловых тестов управляют стеком немного более эффективным способом.

=item *

Глобы, используемые в числовом контексте, теперь приводятся к числу в
большинстве случаев непосредственно, а не путём предварительного приведения к
строковому виду.

=item *

Оператор повторения C<x> теперь приводится к простой константе на этапе
компиляции, если вызывается в скалярном контексте с постоянным операндом и без
скобок вокруг левого операнда.

=back

=head1 Модули и Прагмы

=head2 Новые модули и прагмы

=over 4

=item *

Был добавлен модуль L<Config::Perl::V> версии 0.16 как "живущий в двух местах"
(dual-lifed) модуль.  Он предоставляет структурированную выборку данных из
вывода C<perl -V>, включая информацию известную только двоичному файлы perl и
недоступную через L<Config>.

=back

=head2 Обновлённые модули и прагмы

Для полного списка обновлений, запустите:

  $ corelist --diff 5.16.0 5.18.0

Вы также можете заменить нужную вам версию взамен C<5.16.0>.

=over

=item *

L<Archive::Extract> был обновлён до 0.68.

Обход проблемы в некоторых случаях на Linux с unzip из Busybox.

=item *

L<Archive::Tar> был обновлён до 1.90.

ptar теперь поддерживает опцию -T также, как и опцию без дефисов
[rt.cpan.org #75473], [rt.cpan.org #75475].

Авто-кодирование имён файлов, помеченных как UTF-8 [rt.cpan.org #75474].

Не используется C<tell> на дескрипторах L<IO::Zlib> [rt.cpan.org #64339].

Не пытается вызывать C<chown> на символических ссылках.

=item *

L<autodie> был обновлён до 2.13.

C<autodie> теперь играет по правилам с прагмой 'open'.

=item *

L<B> был обновлён до 1.42.

Был добавлен метод C<stashoff> для COPs.  Это даёт доступ к внутренним
свойствам, добавленным в perl 5.16 в сборках с поддержкой нитей [perl #113034].


C<B::COP::stashpv> теперь поддерживает UTF-8 имена пакетов и встроенные NUL'и.

Все C<CVf_*> и C<GVf_*>, и другие относящиеся к SV флаги теперь доступны как
константы в пространстве имён C<B::> и доступны для экспортирования.  Список
экспортируемых символов не изменился.

Теперь модуль может работать с новым pad API.

=item *

L<B::Concise> был обновлён до 0.95.

Была исправлена опция C<-nobanner>, а C<format> теперь может быть выведен.
Когда указывается имя подпрограммы для вывода делается также проверка является
ли это именем формата.  Если подпрограмма и формат имеют одно и тоже имя, то они
оба будут выведены.

Также была добавлена поддержка новых флагов C<OpMAYBE_TRUEBOOL> и
C<OPpTRUEBOOL>.

=item *

L<B::Debug> был обновлён до 1.18.

Была добавлена поддержка (экспериментальная) для C<B::PADLIST>, которая была
добавлена в Perl 5.17.4.

=item *

L<B::Deparse> был обновлён до 1.20.

Убраны предупреждения, если запускается под C<perl -w>.

Теперь он разбирает управляющие конструкции циклов в правильном порядке и
множественные операции в C<format> строке теперь также разбираются правильно.

В этом выпуске подавляются точки с запятой в конце записи формата.

В этом выпуске добавлена заглушка для разбора  лексических подпрограмм.

Он больше не падает при разборе C<sort> без аргументов.  Теперь он корректно
опускает запятые в C<system $prog @args> и C<exec $prog @args>.

=item *

L<bignum>, L<bigint> и L<bigrat> были обновлены до 0.33.

Переопределение для C<hex> и C<oct> было переписано, решая несколько проблем и
внося одно несовместимое изменение:

=over

=item *

Прежде, какой бы из модулей C<use bigint> или C<use bigrat> не был скомпилирован
позже, он брал приоритет над другими, приводя к тому, что C<hex> и C<oct> не
учитывали действие других прагм в данной области видимости.

=item *

Использование любых из этих трёх прагм приводило к тому, что C<hex> и C<oct> во
всех других местах программы обрабатывали свои аргументы в списочном контексте и
препятствовали работе с $_, когда вызывались без аргументов.

=item *

Использование любой из этих трёх прагм заставляло C<oct("1234")> возвращать 1234
(для любого числа, не начинающегося с 0) в любом месте программы.  Теперь "1234"
транслируются из восьмеричного к десятичному, независимо находится ли оно в
области видимости прагмы или нет.

=item *

Глобальное переопределение, которое устанавливает лексическое использование
C<hex> и C<oct>, теперь учитывает любые существующие переопределения, которые
действовали до включения нового переопределения, возвращая их вне действия
области действия C<use bignum>.

=item *

C<use bignum "hex">, C<use bignum "oct"> и подобные вызовы для bigint и bigrat
теперь экспортируют функции C<hex> или C<oct>, вместо создания глобального
переопределения.

=back

=item *

L<Carp> был обновлён до 1.29.

Carp больше не приходит в замешательство, если C<caller> возвращает undef для
пакета, который был удалён.

Функции C<longmess()> и C<shortmess()> теперь задокументированы.

=item *

L<CGI> был обновлён до 3.63.

Нераспознаваемые экранирующие последовательности HTML теперь обрабатываются
лучше, проблемные завершающие переводы строк больше не вставляются после тегов
E<lt>formE<gt> функциями C<startform()> или C<start_form()>, и ложное
предупреждение "Insecure Dependency" (небезопасная зависимость) на некоторых
версиях perl теперь обходится.

=item *

L<Class::Struct> был обновлён до 0.64.

Конструктор теперь учитывает переопределённый метод доступа [perl #29230].

=item *

L<Compress::Raw::Bzip2> был обновлён до 2.060.

Неправильное использование "магического" API Perl было исправлено.

=item *

L<Compress::Raw::Zlib> был обновлён до 2.060.

Была обновлена, поставляемый с модулем, библиотека zlib до версии 1.2.7

Были исправлены ошибки сборки на Irix, Solaris и Win32, а также сборка с
использованием C++ [rt.cpan.org #69985], [rt.cpan.org #77030],
[rt.cpan.org #75222].

Неправильное использование "магического" API Perl было исправлено.

C<compress()>, C<uncompress()>, C<memGzip()> и C<memGunzip()> были ускорены за
счёт более эффективной проверки параметров.

=item *

L<CPAN::Meta::Requirements> был обновлён до 2.122.

Обрабатываются undef зависимости в C<from_string_hash> как 0 (с предупреждением).

Добавлен метод C<requirements_for_module>.

=item *

L<CPANPLUS> был обновлён до 0.9135.

Разрешено добавлять F<blib/script> к PATH.

Сохраняется история между запусками командной строки.

Лучше поддерживаются множественные аргументы для C<makemakerargs> и
C<makeflags>.

Исправлены проблемы с SQLite движком.

=item *

L<Data::Dumper> был обновлён до 2.145.

Было оптимизировано создание хэша уже обработанных скаляров только при
необходимости, тем самым существенно повысив скорость сериализации.

Были добавлены дополнительные тесты для улучшения покрытия операторов, веток,
условий и подпрограмм.  По данным анализа покрытия, некоторые внутренности
Dumper.pm были переработаны.  Почти все методы теперь задокументированы.

=item *

L<DB_File> был обновлён до 1.827.

Основной Perl модуль больше не использует конструкцию C<"@_">.

=item *

L<Devel::Peek> был обновлён до 1.11.

Были исправлены возможность сборки компилятором C++ и работы с новым pad API.

=item *

L<Digest::MD5> был обновлён до 2.52.

Исправлен откат на C<Digest::Perl::MD5> в ОО-интерфейсе [rt.cpan.org #66634].

=item *

L<Digest::SHA> был обновлён до 5.84.

Исправлена ошибка с двойным освобождением памяти, которая могла приводить к
уязвимости в некоторых случаях.

=item *

L<DynaLoader> был обновлён до 1.18.

Сделано небольшое исправление в XS для VMS реализации.

Исправлено предупреждение об использовании секции C<CODE> без секции C<OUTPUT>. 

=item *

L<Encode> был обновлён до 2.49.

Был добавлен алиас x-mac-ce для Mac и исправлены ошибки в Encode::Unicode,
Encode::UTF7 и Encode::GSM0338.

=item *

L<Env> был обновлён до 1.04.

Его реализация SPLICE больше не ведёт себя неправильно в списочном контексте.

=item *

L<ExtUtils::CBuilder> был обновлён до 0.280210.

Файлы манифестов теперь корректно встраиваются для тех версий VC++, которые
используют их. [perl #111782, #111798].

Список экспортируемых символов может быть передан в C<link()> на Windows, так же
как и на других ОС [perl #115100].

=item *

L<ExtUtils::ParseXS> был обновлён до 3.18.

Генерируемый C код теперь избегает ненужного увеличения C<PL_amagic_generation>
на версиях Perl, где это делается автоматически (или на текущем Perl, где
переменная больше не существует).

Это устраняет ложное предупреждение об инициализированном XSUB без параметров
[perl #112776].

=item *

L<File::Copy> был обновлён до 2.26.

C<copy()> больше не обнуляет файлы при копировании в тот же каталог и теперь
завершается с ошибкой (как это было давно задокументировано), когда пытается
копировать файл в самого себя.

=item *

L<File::DosGlob> был обновлён до 1.10.

Внутренний кэш имён файлов, который он поддерживает для каждого вызывающего,
теперь освобождается, когда освобождается вызывающий код.  Это означает, что
в C<< use File::DosGlob 'glob'; eval 'scalar <*>' >> больше не утекает память.

=item *

L<File::Fetch> был обновлён до 0.38.

Добавлена опция 'file_default' для URL, которые не имеют файловой составляющей.

Используйте C<File::HomeDir>, если доступно, и выставляйте
C<PERL5_CPANPLUS_HOME> для замены автоопределения.

Всегда запрашивает F<CHECKSUMS>, если установлен C<fetchdir>.

=item *

L<File::Find> был обновлён до 1.23.

Была исправлена несовместимая обработка unix-путей на VMS.

Выборочные файлы теперь могут указываться в списках директорий для поиска
[perl #59750].

=item *

L<File::Glob> был обновлён до 1.20.

В File::Glob сделано то же исправление, что и в File::DosGlob.  Поскольку именно
его использует собственный оператор C<glob> (кроме VMS), это означает, что
в C<< eval 'scalar <*>' >> больше нет утечки.

Список разделённых пробелом шаблонов, возвращающий длинный список результатов
больше не приводит к повреждению памяти или аварийному завершению.  Эта проблема
появилась в Perl 5.16.0.  [perl #114984]

=item *

L<File::Spec::Unix> был обновлён до 3.40.

C<abs2rel> может вывести некорректный результат, если получает два относительных
пути, или две корневых директории [perl #111510].

=item *

L<File::stat> был обновлён до 1.07.

C<File::stat> игнорирует прагму L<filetest> и предупреждает, если используется в
комбинации с ней.  Но предупреждения не выдавалась при использовании C<-r>.  Это
было исправлено [perl #111640].

C<-p> теперь работает и не возвращает ложь для каналов [perl #111638].

Ранее перегруженные операторы C<-x> и C<-X> из C<File::stat> не давали
правильных результатов для директорий или исполнимых файлов, если были запущены
с правами root.  Они рассматривали право исполнения для root также как и для
всех других пользователей, выполняя проверку вхождения в группу, для файлов не
принадлежащих root.  Теперь они следуют правильному поведению в Unix - для
директорий они всегда истинны, а для файла, если любой из трёх битов разрешения
запуска установлен, они сообщают, что root может запустить файл.  Встроенные
операторы C<-x> и C<-X> всегда работали правильно.

=item *

L<File::Temp> был обновлён до 0.23

Исправлены различные ошибки, связанные с удалением директорий.  Откладывается
удаление временных файлов, если первоначальное удаление завершаются неудачей,
это исправляет проблемы на NFS.

=item *

L<GDBM_File> был обновлён до 1.15.

Недокументированный необязательный пятый параметр к C<TIEHASH> был удалён.  Он
задумывался для предоставления контроля над колбэком, используемым функциями
C<gdbm*> в случае фатальных ошибок (такие как проблемы файловой системы), но не
работал (и никогда не работал).  Ни один модуль на CPAN даже не предпринимал
попыток его использования.  Колбэк теперь всегда по умолчанию C<croak>.  Были
решены проблемы с тем, как на некоторых платформах вызывается C<C> функция
C<croak>.

=item *

L<Hash::Util> был обновлён до 0.15.

C<hash_unlocked> и C<hashref_unlocked> теперь возвращают истину, если хэш
разблокирован, вместо того, чтобы постоянно возвращать ложь [perl #112126].

C<hash_unlocked>, C<hashref_unlocked>, C<lock_hash_recurse> и
C<unlock_hash_recurse> теперь доступны для экспорта [perl #112126].

Были добавлены две новые функции: C<hash_locked> и C<hashref_locked>.
Как это ни странно, обе этих функции уже экспортировались, несмотря на то, что
они не существовали [perl #112126].

=item *

L<HTTP::Tiny> был обновлён до 0.025.

Добавлены возможности проверки SSL [github #6], [github #9].

Включается финальный URL в хэш-ссылку ответа.

Добавлена опция C<local_address>.

Улучшена поддержка SSL.

=item *

L<IO> был обновлён до 1.28.

C<sync()> теперь можно вызывать на доступных только на чтение файловых
дескрипторах [perl #64772].

L<IO::Socket> пытается лучше кэшировать или в противном случае получить
информацию из сокета.

=item *

L<IPC::Cmd> был обновлён до 0.80.

Используется C<POSIX::_exit> вместо C<exit> в C<run_forked> [rt.cpan.org #76901].

=item *

L<IPC::Open3> был обновлён до 1.13.

Функция C<open3()> больше не использует C<POSIX::close()> для закрытия файлового
дескриптора, так как это ломает подсчёт ссылок файловых дескрипторов, который
ведёт PerlIO в случаях если файловые дескрипторы разделены потоками PerlIO,
что приводит к попыткам закрытия файлового дескриптора во второй раз, когда
любой из подобных PerlIO потоков закрывается позже.

=item *

L<Locale::Codes> был обновлён до 3.25.

Он включает некоторые новые коды.

=item *

L<Memoize> был обновлён до 1.03.

Исправлена опция кэша C<MERGE>.

=item *

L<Module::Build> был обновлён до 0.4003.

Исправлена проблема, когда модули без C<$VERSION> могли иметь версию '0'
указанную в метаданных 'provides', которая будет отклоняться в PAUSE.

Исправлена проблема в PodParser для разрешения цифр в именах модулей.

Исправлена проблема, когда повторное указание аргументов приводит к тому, что
они становятся массивами, приводящее к тому, что пути установки превращались в
подобное F<ARRAY(0xdeadbeef)/lib/Foo.pm>.

Небольшая проблема была исправлена, позволяя использовать разметку вокруг
начального "Name" в строке POD "abstract", и было сделано несколько улучшений в
документации.

=item *

L<Module::CoreList> был обновлён до 2.90

Информация о версии теперь сохраняются в виде дельт, что значительно уменьшает
размер файла F<CoreList.pm>.

Восстановлена совместимость со старыми версиями perl и подчищены данные списка
базовых пакетов для различных модулей.

=item *

L<Module::Load::Conditional> был обновлён до 0.54.

Исправлено использование C<requires> для perl установленного в пути, содержащем
пробелы.

Различные улучшения, включая использование нового модуля Module::Metadata.

=item *

L<Module::Metadata> был обновлён до 1.000011.

Создание объекта Module::Metadata для типичного файла модуля ускорено примерно
на 40%, и некоторые ложные предупреждения о C<$VERSION> были подавлены.

=item *

L<Module::Pluggable> был обновлён до 4.7.

В ряду других изменений теперь разрешено использование триггеров на событиях,
которое даёт большие возможности по изменению поведения.

=item *

L<Net::Ping> был обновлён до 2.41.

Исправлено несколько падающих тестов на Windows.

=item *

L<Opcode> был обновлён до 1.25.

Отражено удаление опкода boolkeys и добавление опкодов clonecv, introcv и padcv.

=item *

L<overload> был обновлён до 1.22.

C<no overload> теперь предупреждает об ошибочных аргументах, как и
C<use overload>.

=item *

L<PerlIO::encoding> был обновлён до 0.16.

Это модуль, который реализует ":encoding(...)" слой ввода/вывода.  Он больше не
повреждает память и не падает, при кодирующий код повторно выделяет буфер или
возвращает typeglob или разделяемый скалярный ключ хэша.

=item *

L<PerlIO::scalar> был обновлён до 0.16.

Передаваемый скаляр буфера теперь может содержать только кодовые точки 0xFF или
ниже. [perl #109828]

=item *

L<Perl::OSType> был обновлён до 1.003.

Исправлена ошибка определения операционной системы VOS.

=item *

L<Pod::Html> был обновлён до 1.18.

Была восстановлена опция C<--libpods>.  Она устарела и её использование ничего
не делает, кроме выдачи предупреждения, что она не поддерживается.

Так как HTML файлы генерируются с помощью pod2html, который уверяет, что
использует кодировку UTF-8, запись файлов идёт с использованием UTF-8
[perl #111446].

=item *

L<Pod::Simple> был обновлён до 3.28.

Несколько улучшений было сделано в основном в Pod::Simple::XHTML, который также
имеет совместимое изменение: опция C<codes_in_verbatim> отключена по умолчанию.
Смотрите все детали в F<cpan/Pod-Simple/ChangeLog>.

=item *

L<re> был обновлён до 0.23

Односимвольные классы символов, как C</[s]/> или C</[s]/i> теперь
оптимизируются, как если бы они и не имели скобок, т.е. C</s/> или C</s/i>.

Смотрите замечания о C<op_comp> в секции L</Внутренние изменения> ниже.

=item *

L<Safe> был обновлён до 2.35.

Исправлено взаимодействие с C<Devel::Cover>.

Не выполняется eval кода при действии C<no strict>.

=item *

L<Scalar::Util> был обновлён до 1.27.

Исправлена проблема с C<sum>.

C<first> и C<reduce> теперь проверяет сначала колбэк (таким образом C<&first(1)>
теперь не позволяется).

Исправлен C<tainted> на магических значениях [rt.cpan.org #55763].

Исправлен C<sum> на ранее магических значениях [rt.cpan.org #61118].

Исправлено чтение за пределами фиксированного буфера [rt.cpan.org #72700].

=item *

L<Search::Dict> был обновлён до 1.07.

Больше не требуется C<stat> на файловых дескрипторах.

Используйте C<fc> для приведения к одному регистру.

=item *

L<Socket> был обновлён до 2.009.

Были добавлены константы и функции, требуемые для членства в исходных группах IP
мультискаста.

C<unpack_sockaddr_in()> и C<unpack_sockaddr_in6()> теперь возвращает только IP
адрес в скалярном контексте и C<inet_ntop()> теперь защищён от некорректной
длины скаляра, передаваемого ему.

Исправлено чтение неинициализированной памяти.

=item *

L<Storable> был обновлён до 2.41.

Изменяя C<$_[0]> внутри C<STORABLE_freeze> больше не приводит к краху
[perl #112358].

Объект, чей класс реализует C<STORABLE_attach>, теперь размораживается только
один раз, когда присутствуют несколько ссылок на него в структуре, которая
размораживается [perl #111918].

Ограниченные хэши не всегда размораживались корректно [perl #73972].

Storable будет выдавать ошибку при замораживании благословенной ссылки объекта с
методом C<STORABLE_freeze()> [perl #113880].

Теперь он может замораживать и размораживать корректно vstrings.  Это приводит к
незначительному несовместимому изменению в формату хранения, поэтому версия
формата была увеличена до 2.9.

Также содержаться различные исправления, включающие исправления совместимости с
ранними версиями Perl и обработки vstring.

=item *

L<Sys::Syslog> был обновлён до 0.32.

Содержится несколько исправлений ошибок, связанных с C<getservbyname()>,
C<setlogsock()> и уровнями логов в C<syslog()>, совместно с исправлениями для
Windows, Haiku-OS и GNU/kFreeBSD.  Смотрите все детали в
F<cpan/Sys-Syslog/Changes>

=item *

L<Term::ANSIColor> был обновлён до 4.02.

Добавлена поддержка для курсива.

Улучшена обработка ошибок.

=item *

L<Term::ReadLine> был обновлён до 1.10.

Было исправлено использование оболочек B<cpan> и B<cpanp> на Windows в случае,
если текущий диск содержит файл F<\dev\tty> .

=item *

L<Test::Harness> был обновлён до 3.26.

Исправлена семантика glob на Win32 [rt.cpan.org #49732].

Не используется C<Win32::GetShortPathName> при вызове perl [rt.cpan.org #47890].

Игнорируется -T при чтении шебанга [rt.cpan.org #64404].

Более элегантно обрабатывается случай, когда мы не знаем статуса wait теста.

Реализована возможность переопределения строчки отчёта теста 'ok', и изменение
её в плагине, чтобы сделать вывод prove неизменным.

Не запускаются файлы, доступные для записи для всех.

=item *

L<Text::Tabs> и  L<Text::Wrap> были обновлены до 2012.0818.

В оба была добавлена поддержка комбинированных символов Юникода.

=item *

L<threads::shared> был обновлён до 1.31.

Добавлена опция, которая предупреждает или игнорирует попытки клонировать
структуры, которые не могут быть клонированы, вместо безусловного падения в
таких случаях.

Добавлена поддержка переменных с двойным значением, создаваемые с помощью
L<Scalar::Util::dualvar|Scalar::Util/"dualvar NUM, STRING">.

=item *

L<Tie::StdHandle> был обновлён до 4.3.

C<READ> теперь учитывает аргумент отступа в C<read> [perl #112826].

=item *

L<Time::Local> был обновлён до 1.2300.

Значения секунд больше чем 59, но меньше чем 60 больше не приводят к ошибкам в
C<timegm()> и C<timelocal()>.

=item *

L<Unicode::UCD> был обновлён до 0.53.

Была добавлена функция L<all_casefolds()|Unicode::UCD/all_casefolds()>, которая
возвращает все случаи регистрового изменения.

=item *

L<Win32> был обновлён до 0.47.

Новые API были добавлены для получения и установки текущей кодовой страницы.

=back


=head2 Удалённые модули и прагмы

=over

=item *

L<Version::Requirements> был удалён из базового дистрибутива.  Теперь он
доступен под другим именем: L<CPAN::Meta::Requirements>.

=back

=head1 Документация

=head2 Изменения в существующей документации

=head3 L<perlcheat>

=over 4

=item *

L<perlcheat> был реорганизован и было добавлено несколько новых секций.

=back

=head3 L<perldata>

=over 4

=item *

Теперь явно документировано поведение инициализации хэша списком, который
содержит дублирующие ключи.

=back

=head3 L<perldiag>

=over 4

=item *

Объяснение почему символические ссылки запрещены при "strict refs" теперь не
предполагают, что читатель знаком, что представляют из себя символические
ссылки.

=back

=head3 L<perlfaq>

=over 4

=item *

L<perlfaq> было синхронизирован с версией 5.0150040 на CPAN.

=back

=head3 L<perlfunc>

=over 4

=item *

Возвращаемое значение C<pipe> теперь задокументировано.

=item *

Прояснена документация C<our>.

=back

=head3 L<perlop>

=over 4

=item *

Команды управления циклом (C<dump>, C<goto>, C<next>, C<last> и C<redo>) всегда
имели тот же приоритет, что и операторы присвоения, но это не было
задокументировано до этого времени.

=back

=head3 Диагностика

Следующие дополнения или изменения были сделаны в диагностическом выводе,
включая предупреждения или сообщения фатальных ошибок.  Для полного списка
диагностических изменений смотрите в L<perldiag>.

=head2 Новая диагностика

=head3 Новые ошибки

=over 4

=item *

L<Unterminated delimiter for here document|perldiag/"Unterminated delimiter for here document">

Это сообщение теперь появляется, когда метка встроенного документа имеет
начальный символ цитирования, но отсутствует завершающий.

Это замещает некорректное сообщение об ошибке, что не найдена сама метка
[perl #114104].

=item *

L<panic: child pseudo-process was never scheduled|perldiag/"panic: child pseudo-process was never scheduled">

Эта ошибка выводится, когда дочерний псевдо-процесс в ithreads реализации на
Windows не был запланирован за допустимый период времени и таким образом не смог
быть инициализирован корректно [perl #88840].

=item *

L<Group name must start with a non-digit word character in regex; marked by <-- HERE in mE<sol>%sE<sol>|perldiag/"Group name must start with a non-digit word character in regex; marked by <-- HERE in m/%s/">

Эта ошибка была добавлена для C<(?&0)>, которая некорректна. Раньше выводилось
непонятное сообщение об ошибке [perl #101666].

=item *

L<Can't use an undefined value as a subroutine reference|perldiag/"Can't use an undefined value as %s reference">

Вызов неопределённого значения как подпрограммы теперь выводит данное сообщение
об ошибке. Раньше оно присутствовало, но случайно было отключено сначала в Perl
5.004 для немагических переменных, затем в Perl v5.14 для магических (например,
связанных) переменных.  Теперь оно было восстановлено. На протяжении этого
времени undef рассматривался как пустая строка [perl #113576].

=item *

L<Experimental "%s" subs not enabled|perldiag/"Experimental "%s" subs not enabled">

Для использования лексических подпрограмм вы должны сначала включить их:

    no warnings 'experimental::lexical_subs';
    use feature 'lexical_subs';
    my sub foo { ... }

=back

=head3 Новые предупреждения

=over 4

=item *

L<'Strings with code points over 0xFF may not be mapped into in-memory file handles'|perldiag/"Strings with code points over 0xFF may not be mapped into in-memory file handles">

=item *

L<'%s' resolved to '\o{%s}%d'|perldiag/"'%s' resolved to '\o{%s}%d'">

=item *

L<'Trailing white-space in a charnames alias definition is deprecated'|perldiag/"Trailing white-space in a charnames alias definition is deprecated">

=item *

L<'A sequence of multiple spaces in a charnames alias definition is deprecated'|perldiag/"A sequence of multiple spaces in a charnames alias definition is deprecated">

=item *

L<'Passing malformed UTF-8 to "%s" is deprecated'|perldiag/"Passing malformed UTF-8 to "%s" is deprecated">

=item *

L<Subroutine "&%s" is not available|perldiag/"Subroutine "&%s" is not available">

(Категория closure) Во время компиляции внутренняя именованная подпрограмма или
eval пытаются использовать внешнюю лексическую подпрограмму, которая недоступна
в данный момент.  Это может происходить по двум причинам.  Во-первых,
лексическая подпрограмма могла быть объявлена во внешней анонимной подпрограмме,
которая ещё не была создана.  (Помните, что именованные подпрограммы создаются
на этапе компиляции, в то время как анонимные подпрограммы создаются во время
выполнения). Например:

    sub { my sub a {...} sub f { \&a } }

Ко времени, когда создаётся f она не может получить доступ к текущей
подпрограмме "a", так как анонимная подпрограмма ещё не была создана.  И
наоборот, следующее выражение не выдаст предупреждение, так как анонимная
подпрограмма уже была создана и доступна:

    sub { my sub a {...} eval 'sub f { \&a }' }->();

Вторая ситуация вызвана функцией eval, которая обращается к переменной, которая
уже ушла из области видимости, например:

    sub f {
        my sub a {...}
        sub { eval '\&a' }
    }
    f()->();

Здесь, когда '\&a' внутри eval компилируется, f() в данный момент не выполняется
и поэтому его &a не доступна.

=item *

L<"%s" subroutine &%s masks earlier declaration in same %s|perldiag/"%s" subroutine &%s masks earlier declaration in same %s>

(Категория misc) Подпрограмма "my" или "state" была повторно объявлена в текущей
области видимости или операторе, уничтожая доступ к предыдущему экземпляру.  Это
практически всегда опечатка.  Обратите внимание, что ранняя подпрограмма
по-прежнему будет существовать до завершения текущей области видимости или пока
все замыкания, ссылающиеся на неё, не будут уничтожены.

=item *

L<The %s feature is experimental|perldiag/"The %s feature is experimental">

(Категория experimental) Это предупреждение выводится, когда вы подключаете
экспериментальные возможности, с помощью C<use feature>.  Просто подавляйте
предупреждение, если вы хотите использовать эту возможность, но делая так вы
берёте на себя риски использования экспериментальной возможности, которая может
измениться или будет удалена в будущей версии Perl:

    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";

=item *

L<sleep(%u) too large|perldiag/"sleep(%u) too large">

(Категория overflow) Вы вызвали C<sleep> с числом, которое больше, чем он может
надёжно принять и C<sleep> вероятно будет спать меньшее время, чем было
запрошено.

=item *

L<Wide character in setenv|perldiag/"Wide character in %s">

Попытки поместить широкие символы в переменные окружения через C<%ENV> теперь
выдают подобное предупреждение.

=item *

"L<Invalid negative number (%s) in chr|perldiag/"Invalid negative number (%s) in chr">"

C<chr()> теперь предупреждает, когда ему передаётся отрицательное значение
[perl #83048].

=item *

"L<Integer overflow in srand|perldiag/"Integer overflow in srand">"

C<srand()> теперь предупреждает, если переданное значение не помещается в C<UV>
(так как значение будет обрезано и не произойдёт переполнения) [perl #40605].

=item *

"L<-i used with no filenames on the command line, reading from STDIN|perldiag/"-i used with no filenames on the command line, reading from STDIN">"

Запуск perl с ключом C<-i> теперь выводит предупреждение, если не было указано
ни одного входного файла в командной строке [perl #113410].

=back

=head2 Изменения в существующией диагностике

=over 4

=item *

L<$* is no longer supported|perldiag/"$* is no longer supported">

Предупреждение о том, что использование C<$*> и C<$#> больше не поддерживается
теперь выводится для каждого участка кода, который ссылается на них. Раньше оно
не выводилось, если другая переменная, использовавшая такой же typeglob
обнаруживалась раньше (например, C<@*> перед C<$*>), а также не выводилось
второй и последующих записей.  (Достаточно трудно исправить ошибку вывода
предупреждения вообще, без того, чтобы не выводить это предупреждение каждый
раз, и предупреждение каждый раз согласуется с предупреждением, которое
выводится для C<$[>).

=item *

Были добавлены предупреждения для C<\b{> и C<\B{>.  Это предупреждения об
устаревших конструкциях, которые должны отключаться по выключению данной
категории.  Теперь не требуется также выключать предупреждения регулярных
выражений, чтобы добиться их отключения.

=item *

L<Constant(%s): Call to &{$^H{%s}} did not return a defined value|perldiag/Constant(%s): Call to &{$^H{%s}} did not return a defined value>

Перегрузка константы, которая возвращает C<undef> приводит к подобному сообщению
об ошибке.  Для числовых констант раньше выводилось "Constant(undef)".  "undef"
был заменён на само число.

=item *

Ошибка, которая выводится когда модуль не может быть загружен, теперь включает
подсказку какой модуль требуется к установке: "Can't locate hopping.pm in @INC
(you may need to install the hopping module) (@INC contains: ...)"

=item *

L<vector argument not supported with alpha versions|perldiag/vector argument not supported with alpha versions>

Это предупреждение не подавлялось даже при помощи C<no warnings>.  Теперь его
можно подавить и оно было перемещено из категории "internal" в категорию
"printf".

=item *

C<< Can't do {n,m} with n > m in regex; marked by <-- HERE in m/%s/ >>

Эта фатальная ошибка была превращена в предупреждение, которое читается так:

L<< Quantifier {n,m} with n > m can't match in regex | perldiag/Quantifier {n,m} with n > m can't match in regex >>

(Категория regexp) Минимальное значение должно быть меньше или равно
максимальному.  Если вы действительно хотите получить совпадение 0 раз, просто
задайте {0}.

=item *

Предупреждение о "Runaway prototype", которое возникает в редких ситуациях было
удалено из-за бесполезности и противоречивости.

=item *

Ошибка "Not a format reference" была удалена так как единственный случай, в
котором она выводилось являлось внутренней ошибкой.

=item *

Ошибка "Unable to create sub named %s" была удалена по той же причине

=item *

Ошибка 'Can't use "my %s" in sort comparison' была понижена до предупреждения
'"my %s" used in sort comparison' (со 'state' вместо 'my' для случая переменных
состояния).  В дополнении, эвристика для угадывания, какая из лексических $a или
$b были неправильно использованы, была улучшена для снижения количества ложных
срабатываний.  Лексические $a и $b больше не запрещены, если они вне блока sort.
Также именованный унарный или списочный оператор внутри блока sort больше не
приводит к игнорированию $a или $b [perl #86136].

=back

=head1 Изменения в утилитах

=head3 L<h2xs>

=over 4

=item *

F<h2xs> больше не выдаёт неправильный код для пустых определений [perl #20636]

=back

=head1 Конфигурация и компиляция

=over 4

=item *

Добавлена опция C<useversionedarchname> в Configure

Если она установлена, то в 'archname' включается значение 'api_versionstring'.
Например, x86_64-linux-5.13.6-thread-multi.  Она выключена по умолчанию.

Эта возможность была запрошена Тимом Бансом (Tim Bunce), который заметил, что
C<INSTALL_BASE> создаёт структуру библиотеки, которая не зависит от версии perl.
Вместо этого, он помещает архитектурно-зависимые файлы в
"$install_base/lib/perl5/$archname".  Это затрудняет использование общего
C<INSTALL_BASE> пути библиотеки с разными версиями perl.

Устанавливая C<-Duseversionedarchname>, $archname будет отличаться по
архитектуре I<and> по версии API, позволяя смешанное использование
C<INSTALL_BASE>.

=item *

Добавлена опция C<PERL_NO_INLINE_FUNCTIONS>.

Если определена C<PERL_NO_INLINE_FUNCTIONS>, то не включается заголовок
"inline.h".

Это позволяет создавать код, включающий perl заголовки для определений, без
создания зависимости на библиотеку perl при компановке (которая ещё может не
существовать).

=item *

Configure учитывает внешнюю переменную окружения C<MAILDOMAIN>, если она
установлена.

=item *

C<installman> больше не игнорирует опцию тишины

=item *

Оба файла C<META.yml> и C<META.json> теперь включаются в дистрибутив.

=item *

F<Configure> теперь корректно определяет C<isblank()> при сборке с помощтю
компилятора C++.

=item *

Обнаружение утилиты постраничного вывода в F<Configure> было улучшено и
позволяет указывать опции после имени программы, например, B</usr/bin/less -R>,
если пользователь принимает значение по умолчанию.  Это позволяет B<perldoc> при
обработке ANSI экранирования [perl #72156].

=back

=head1 Тестирование

=over 4

=item *

Тестовый набор теперь содержит секцию тестов, которые требуют очень большого
количества памяти.  Эти тесты не запускаются по умолчанию; они могут быть
включены установкой переменной окружения C<PERL_TEST_MEMORY> со значением
количества гибибайт памяти, которое может быть безопасно использовано.

=back

=head1 Поддержка платформ

=head2 Более неподдерживаемые платформы

=over 4

=item BeOS

BeOS была операционной системой для персональных компьютеров, разрабатываемой Be
Inc, первоначально для их аппаратной платформы BeBox.  ОС Haiku была создана как
замена с открытыми исходниками для продолжения развития BeOS и его perl порт на
данный момент активно поддерживается.

=item UTS Global

Поддерживающий код, относящийся к UTS global был удалён.  UTS являлся версией
System V для мейнфреймов, созданной Amdahl, а затем проданной UTS Global.  К
порту не притрагивались начиная с Perl v5.8.0 и UTS Global на текущий момент не
функционирует.

=item VM/ESA

Поддержка для VM/ESA была удалена.  Порт был протестирован на 2.3.0, который
перестал поддерживаться IBM с марта 2002. Для 2.4.0 завершилось обслуживание в
июне 2003 и было заменено на Z/VM.  Текущая версия Z/VM V6.2.0 и запланирована к
окончанию поддержки к 2015/04/30.

=item MPE/IX

Поддержка для MPE/IX была удалена.

=item EPOC

Поддерживающий код для EPOC был удалён.  EPOC являлся семейством операционных
систем, разрабатываемых в Psion для мобильных устройств.  Он являлся
предшественником Symbian.  Порт последний раз был обновлён в апреле 2002.

=item Rhapsody

Поддержка для Rhapsody была удалена.

=back

=head2 Платформо-специфичные замечания

=head3 AIX

Configure теперь всегда добавляет C<-qlanglvl=extc99> в CC флаги на AIX, если
используется xlC.  Это позволяет упростить сборку XS модулей, которые
предполагают C99 [perl #113778].

=head3 clang++

Теперь присутствует обходное решение для ошибки в компиляторе, которая
препятствовала сборке с использованием clang++ начиная с Perl v5.15.7
[perl #112786].

=head3 C++

При сборке ядра Perl как C++ (что лишь частично поддерживается), математические
функции компилируются как C<extern "C">, для гарантированной бинарной
совместимости.  (Однако, бинарная совместимость в общем случае не гарантируется
в любом случае в ситуациях, где бы это имело значение).

=head3 Darwin

Убрано жёстко-заданное выравнивание к 8 байтовым границам для исправления сборки
с использованием -Dusemorebits.

=head3 Haiku

Perl теперь должен работать из коробки на Haiku R1 Alpha 4.

=head3 MidnightBSD

C<libc_r> был удалён в последних версиях MidnightBSD, а поздние версии лучше
работают с C<pthread>.  Многопоточноть теперь включается с использованием
C<pthread>, что исправляет сборочные ошибки при сборке с включённой
многопоточностью на 0.4-CURRENT.

=head3 Solaris

Configure избегает запуска команды sed с флагами, которые не поддерживаются на
Solaris.

=head3 VMS

=over

=item *

Где возможно, регистр имён файлов и аргументов командной строки теперь
сохраняется за счёт включения возможностей CRTL C<DECC$EFS_CASE_PRESERVE> и
C<DECC$ARGV_PARSE_STYLE> при запуске.  Последний действует только если
расширенный разбор включён в процессе из которого запускается Perl.

=item *

Набор символов для Расширенного Файлового Синтаксиса (EFS) теперь включается по
умолчанию на VMS.  Среди прочего это даёт лучшую обработку точек в именах
директорий, нескольких точек в именах файлов и пробелах в файловых именах.
Чтобы получить старое поведение установите логическое имя C<DECC$EFS_CHARSET> в
значение C<DISABLE>.

=item *

Исправлена компоновка на сборках, сконфигурированных с C<-Dusemymalloc=y>.

=item *

Экспериментальная поддержка сборки Perl с помощью компилятора HP C++ доступна
при конфигурации с C<-Dusecxx>.

=item *

Все заголовочные файлы C из верхней директории дистрибутива теперь
устанавливаются на VMS, согласованно с устоявшейся практикой на других
платформах.  Ранее устанавливалась только часть, что ломало сборку внешних
расширений для расширений, которые зависят на потерянные заголовочные файлы.

=item *

Цитирование удалено из командных слов (но не из параметров) для команд,
вызываемых через C<system>, обратные кавычки или C<open> с перенаправлением.
Раньше кавычки на командах пропускались через DCL, который мог не узнать
команду. Также если команда это в действительности путь к образу или командной
процедуре на томе ODS-5, цитирование теперь позволяет использовать пути,
содержащие пробелы.

=item *

Сборка B<a2p> была исправлена для компилятора HP C++ на OpenVMS.

=back

=head3 Win32

=over

=item *

Perl теперь может быть собран с использованием компилятора Visual C++ 2012
Microsoft при указании CCTYPE=MSVC110 (или MSVC110FREE, если вы используете
бесплатную Express версию для десктопа Windows) в F<win32/Makefile>.


=item *

Опция для сборки без C<USE_SOCKETS_AS_HANDLES> была удалена.

=item *

Исправлена проблема, когда perl мог упасть при очистке нитей (включая главную
нить) в сборках с многопоточностью и отладочными символами на Win32 и возможно
на других платформах [perl #114496].

=item *

Редкая ситуация гонки, которая приводит к тому, что L<sleep|perlfunc/sleep>
занимает больше времени, чем запрошено и возможно даже зависает, теперь была
исправлена [perl #33096].

=item *

C<link> на Win32 теперь пытается установить C<$!> более уместное значение,
основанное на коде ошибки Win32 API [perl #112272].

Perl больше не портит блок окружения, например при запуске нового суб-процесса,
когда окружение содержит не-ASCII символы.  Однако,  известные проблемы
по-прежнему остаются, если окружение содержит символы вне текущей кодовой
таблицы ANSI (например, смотрите блок по Юникоду в C<%ENV> в
L<http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/todo.pod>).
[perl #113536]

=item *

Сборка perl некоторыми Windows компиляторами раньше завершалась ошибкой из-за
проблем с оператором C<glob> в miniperl (который использует программу
C<perlglob>), удалявший переменную окружения PATH [perl #113798].

=item *

Была добавлена новая опция для Windows makefile'ов C<USE_64_BIT_INT>.
Установите её в значение "define" при сборке 32-битного perl, если вы хотите,
чтобы он использовал 64-битные целые.

Уменьшение размера машинного кода, которое уже было выполнено для DLL XS модулей
в Perl v5.17.2, теперь было расширенно и на DLL самого perl.

Сборка с помощью VC++ 6.0 была нечаянно сломана в Perl v5.17.2, но теперь была
восстановлена.

=back

=head3 WinCE

Сборка на WinCE теперь снова стала возможна, однако больше работы требуется для
полного восстановления чистой сборки.

=head1 Внутренние изменения

=over

=item *

Были созданы синонимы для вводящего в заблуждения имени C<av_len()>:
C<av_top_index()> и C<av_tindex>.  Все три возвращают самый старший индекс в
массиве, а не число элементов, который он содержит.

=item *

SvUPGRADE() больше не является выражением.  Изначально этот макрос (и
используемая в нём функция sv_upgrade()) был задокументирован как логический,
хотя в реальности они всегда падали на ошибках и никогда не возвращали ложное
значение.  В 2005 документация была обновлена с указанием, что возвращается
пустое значение, но для обратной совместимости SvUPGRADE() всегда возвращал 1.
Теперь это было удалено и SvUPGRADE() теперь является оператором, который не
возвращает никакого значения.

Таким образом это теперь синтаксическая ошибка:

    if (!SvUPGRADE(sv)) { croak(...); }

Если у вас есть подобный код, просто замените его на

    SvUPGRADE(sv);

или для избежания предупреждения компилятора со старыми версиями perl возможно

    (void)SvUPGRADE(sv);

=item *

Perl имеет новый механизм копирование-при-записи, который позволяет любым SvPOK
скалярам быть улучшенным до скаляра копируемого-при-записи.  Число ссылок на
буфер строки сохраняется в самом буфере строки.  Эта возможность не B<включена
по умолчанию>.

Он может быть включён в сборке perl при помощи запуска F<Configure> с флагом
B<-Accflags=-DPERL_NEW_COPY_ON_WRITE>, и мы призываем XS авторов попробовать
свой код на perl, собранным подобном образом, и отправить свои отзывы. К
сожалению, пока нет хорошего руководства для обновления XS кода для работы с
COW.  Пока такой документ недоступен, обращайтесь за консультациями в почтовый
список рассылки perl5-porters.

Он ломает некоторые XS модули, позволяя скалярам копируемым-при-записи
появляться в коде, где никто раньше не ожидал их видеть.

=item *

Копирование-при-записи больше не использует флаги SvFAKE и SvREADONLY.
Следовательно SvREADONLY теперь показывает по-настоящему доступные только на
чтение SV.

Используйте SvIsCOW макрос (как и раньше) для идентификации скаляров
копируемых-при-записи.

=item *

C<PL_glob_index> исчез.

=item *

Приватный Perl_croak_no_modify лишился параметра своего контекста.  Теперь у
него пустой прототип.  Пользователи публичного API croak_no_modify остаются
незатронутыми.

=item *

Копируемый-при-записи (разделяемый ключ хэша) скаляры больше не помечаются как
доступные только для чтения. C<SvREADONLY> возвращает ложь на подобных SV, но
C<SvIsCOW> по-прежнему возвращает истину.

=item *

Появился новый тип операций C<OP_PADRANGE>.  Оптимизатор perl, где возможно,
заменит на одиночную операцию padrange операцию pushmark с последующей одной или
несколькими pad операциями, и, возможно, пропуская операции list и nextstate.  В
дополнении операция может взять задачу, связанную с RHS присвоения C<< my(...) =
@_ >>, чтобы эти операции также могли быть оптимизированы.

=item *

Регистро-независимое сравнение внутри заключённых в скобки символьных классов с
многосимвольной формой больше не исключает одну из возможностей в случаях, когда
оно используется именно для этого [perl #89774].

=item *

C<PL_formfeed> был удалён.

=item *

Движок регулярных выражений больше не читает один байт после конца целевой
строки.  Для всех внутренне корректно сформированных скаляров это никогда не
было проблемой, это изменение упрощает применение хитрых трюков с буферами строк
в CPAN модулях [perl #73542].

=item *

Внутри блока BEGIN, C<PL_compcv> теперь указывает на компилируемую в данный
момент подпрограмму, а не на сам блок BEGIN.

=item *

C<mg_length> устарела.

=item *

C<sv_len> теперь всегда возвращает число байт, а C<sv_len_utf8> число символов.
Ранее C<sv_len> и C<sv_len_utf8> оба были сломанными и иногда возвращали число
байт, а иногда число символов.  C<sv_len_utf8> больше не считает, что её
аргумент в кодировке UTF-8.  Никто из них больше не создаёт UTF-8 кэши для
связанных или перегруженных значений или для не-PV.

=item *

C<sv_mortalcopy> теперь копирует строковые буферы скаляров разделяемых ключей
хэша, когда вызывается из XS модулей [perl #79824].

=item *

C<RXf_SPLIT> и C<RXf_SKIPWHITE> больше не используются. Сейчас они определены
как 0.

=item *

Новый флаг C<RXf_MODIFIES_VARS> может быть установлен в произвольном движке
регулярных выражений для указания, что запуск регулярного выражения может
привести у изменению переменных.  Это позволяет C<s///> знать, когда нужно
пропускать определённые оптимизации.  Собственный движок регулярных выражений
устанавливает этот флаг для специальных команд прохода с возвратом, которые
устанавливают $REGMARK и $REGERROR.

=item *

API для доступа к лексическим pad'ам было существенно изменено.

C<PADLIST> больше не является C<AV>, а имеет свой собственный тип. C<PADLIST>
теперь содержит C<PAD> и C<PADNAMELIST> состоит из C<PADNAME>, а не C<AV> для
pad и списка pad имён.  C<PAD>, C<PADNAMELIST> и C<PADNAME> доступны
соответственно через появившееся новое pad API, вместо прямого C<AV> и C<SV>
API. Смотрите L<perlapi> для подробностей.

=item *

В API регулярных выражений функции-колбэки пронумерованных захватов передают
индекс, указывающий к какой переменной осуществлён доступ.  Существуют
специальные индексные значения для переменных C<$`, $&, $&>.  Раньше такие же
три значения использовались также для получения C<${^PREMATCH}, ${^MATCH},
${^POSTMATCH}>, но они теперь получили три отдельных значения.  Смотрите
L<perlreapi/Numbered capture callbacks>.

=item *

C<PL_sawampersand> раньше был логическим значением, которое указывало, что любые
из C<$`, $&, $&> были видимы; теперь он содержит три однобитных флага,
указывающих на наличие любой из переменных индивидуально.

=item *

C<CV *> typemap теперь поддерживает C<&{}> перегрузку и typeglob'ы, также как и
C<&{...}> [perl #96872].

=item *

Флаг C<SVf_AMAGIC>, указывающий на перегрузку теперь в стэше, а не в объекте.
Теперь он устанавливается автоматически при изменении метода или @ISA, так что
его смысл теперь изменился также.  Теперь он означает "потенциально перегружен".
Когда рассчитывается таблица перегрузок, флаг автоматически выключается, если
отсутствует перегрузка, поэтому заметного замедления нет.

Устаревание таблицы перегрузок теперь проверяется, когда вызывается
перегруженный метод, а не во время C<bless>.

Магический "A" исчез.  Изменения в обработке флага C<SVf_AMAGIC> устранили
необходимость в нём.

C<PL_amagic_generation> был удалён и больше не нужен.  Для XS модулей это теперь
макрос псевдоним к C<PL_na>.

Установка откат перегрузки теперь сохраняется в записи стэша отдельно от самой
перегруженности.

=item *

Код обработки символов был местами подчищен.  Изменения должны быть невидимы на
практике.

=item *

Функция C<study> была сделана бездейственной в v5.16.  Она была попросту
выключена вставкой оператора C<return>; код же оставался на месте.  Теперь
поддерживающий код, который использовался в C<study> полностью был удалён.

=item *

В perl с поддержкой нитей больше нет отдельного PV выделенного для каждого COP
для хранения его имени пакета (C<< cop->stashpv >>).  Вместо этого есть смещение
(C<< cop->stashoff >>) в новый массив C<PL_stashpad>, который хранит указатели
стэша.

=item *

В расширяемом API регулярных выражений структура C<regexp_engine> получила новое
поле C<op_comp>, которое в данный момент используется только для внутренних
целей perl и должно быть инициализировано в NULL другими модулями расширения
регулярных выражений.

=item *

Новая функция C<alloccopstash> была добавлена в API, но она рассматривается как
экспериментальная.  Смотрите L<perlapi>.

=item *

Раньше в Perl было реализовано получение магии способом иногда скрывавшим ошибки
в коде, который мог вызывать mg_get() слишком много раз на магические значения.
Такого сокрытия ошибок больше не происходит, так что давние ошибки теперь могут
стать заметными.  Если вы видите относящиеся к магии ошибки в XS-коде,
проверьте, чтобы быть уверенными, вместе с другими Perl API функциями, которые
его используют, что вызовы mg_get() происходят только один раз на SvGMAGICAL()
значения.

=item *

Выделение OP для CV теперь использует slab выделение.  Это упрощает управление
памятью для OP выделенных для CV, поэтому очистка после ошибок компиляции проще
и более безопасна [perl #111462][perl #112312].

=item *

C<PERL_DEBUG_READONLY_OPS> был переписан для работы с новым slab
распределителем, позволяя захватывать больше нарушений, чем раньше.

=item *

Старый slab распределитель для OP, который только включался для
C<PERL_IMPLICIT_SYS> и C<PERL_DEBUG_READONLY_OPS> был удалён.

=back

=head1 Выборочные исправления ошибок

=over 4

=item *

Ограничители встроенной документации больше не требуют звершающего символа новой
строки, если находятся в конце файла. Это уже было так в конце строки,
выполняемой через eval [perl #65838].

=item *

Сборка с C<-DPERL_GLOBAL_STRUCT> теперь освобождает глобальную структуру
B<после> того, как закончит использовать её.

=item *

Завершающий '/' в путях в @INC больше не дополняется ещё одним '/'.

=item *

Слой C<:crlf> теперь работает, когда возвращаемые данные не вмещаются в свой
собственный буфер [perl #112244].

=item *

C<ungetc()> теперь поддерживает данные, кодированные в UTF-8 [perl #116322].

=item *

Ошибка в базовых typemap привела к тому, что любые C типы, которые соответствуют
базовому T_BOOL typemap элементу не устанавливаются, не обновляются и не
модифицируются, когда T_BOOL переменная используется в OUTPUT: секции с
исключением для RETVAL.  T_BOOL в INPUT: секции не затронут.  Использование
возвращаемого типа T_BOOL в XSUB (RETVAL) не было затронуто.  Побочным эффектом
исправления этой ошибки стало то, что если T_BOOL указан в секции OUTPUT: (что
раньше ничего не меняло для SV) и передаётся доступный только для чтения SV
(литерал) в XSUB, происходит ошибка вида Modification of a read-only value
attempted" [perl #115796].

=item *

На многих платформах указание имени директории как имени скрипта приводило к
тому, что perl ни делал ничего и сообщал об успешном запуске.  Сейчас он всегда
должен сообщать об ошибке и завершаться с ненулевым кодом возврата
[perl #61362].

=item *

C<sort {undef} ...> при действии фатальных предупреждений больше не падает. Он
начал падать в Perl v5.16.

=item *

Стэши благословлённые друг в другу (C<bless \%Foo::, 'Bar'; bless \%Bar::,
'Foo'>) больше не приводят к двойному освобождению.  Эта проблема стала
возникать в Perl v5.16.

=item *

Несколько утечек памяти было исправлено, большая часть затрагивает фатальные
предупреждения и синтаксические ошибки.

=item *

Некоторые несовпавшие регулярные выражения, такие как C<'f' =~ /../g> не
сбрасывали C<pos>.  Кроме того "совпавшие-лишь-раз" шаблоны (C<m?...?g>) не
сбрасывали его также, когда вызывались второй раз [perl #23180].

=item *

Несколько ошибок, включающие C<local *ISA> и C<local *Foo::>, приводившие к
устареванию MRO кэшей, были исправлены.

=item *

Определение подпрограммы, когда для её typeglob был задан псевдоним больше не
приводит к устареванию кэшей методов.  Эта ошибка появилась в Perl v5.10.

=item *

Локализация typeglob'а, содержащего подпрограмму, когда пакет typeglob'а был
удалён из своего родительского стэша больше не приводит к ошибке.  Эта ошибка
появилась в Perl v5.14.

=item *

В некоторых ситуациях C<local *method=...> мог не сбросить кэши методов при
выходе из области видимости.

=item *

C</[.foo.]/> больше не является ошибкой, но выводит предупреждение (как и
раньше) и рассматривается как C</[.fo]/> [perl #115818].

=item *

C<goto $tied_var> теперь вызывает FETCH перед тем как решит какого типа этот
goto (подпрограмма или метка).

=item *

Переименование пакетов через присвоение glob
(C<*Foo:: = *Bar::; *Bar:: = *Baz::>) в комбинации с C<m?...?> и C<reset> больше
не приводит к падению сборки с поддержкой нитей.

=item *

Некоторое число ошибок, относящиеся к присвоению списка хэшу было исправлено.
Многие их них включают списки из повторяющихся ключей вида C<(1, 1, 1, 1)>.

=over 4

=item *

Выражение C<scalar(%h = (1, 1, 1, 1))> теперь возвращает C<4>, а не C<2>.

=item *

Возвращаемое значение C<%h = (1, 1, 1)> в списочном контексте было неправильным.
Раньше возвращало C<(1, undef, 1)>, теперь возвращает C<(1, undef)>.

=item *

Теперь Perl выдаёт такое же предупреждение для C<($s, %h) = (1, {})>, какое он
выдаёт для C<(%h) = ({})>, "Reference found where even-sized list expected"
("Найдена ссылка там, где ожидался список с чётным числом элементов").

=item *

Несколько дополнительных краевых случаев в присвоении списков хэшу было
исправлено.  Для дополнительных деталей смотрите коммит 23b7025ebc.

=back

=item *

С атрибутами, присвоенными лексическим переменным, больше не утекает память
[perl #114764].

=item *

C<dump>, C<goto>, C<last>, C<next>, C<redo> или C<require> с последующим
тривиальным словом (bareword) или версией и далее идущим инфиксным оператором
больше не является синтаксической ошибкой.  Раньше так было для некоторых
инфиксных операторов (вроде C<+>), которые имеют другое понимание где ожидается
элемент [perl #105924].

=item *

C<require a::b . 1> и C<require a::b + 1> больше не выдаёт ошибочное
предупреждение об двусмысленности [perl #107002].

=item *

Вызов метода класса теперь разрешается для любой строки, а не только строки,
начинающейся с буквенно-цифрового символа [perl #105922].

=item *

Пустой шаблон созданный с помощью C<qr//>, используемый в C<m///> больше не
вызывает поведения "пустой шаблон повторно использует последний шаблон"
[perl #96230].

=item *

Связывая хэш во время итерации больше не приводит к утечкам памяти.

=item *

Освобождение связанного хэша во время итерации больше не приводит к утечкам
памяти.

=item *

Присвоение списка связанному массиву или хэшу, который умирает при операции
STORE, больше не приводит к утечке памяти.

=item *

Если хинт-хэш (C<%^H>) является связанным, элемент области видимости во время
компиляции (который копирует хинт-хэш) больше не теряет память если умирает
вызов FETCH [perl #107000].

=item *

Вычисление констант больше не вызывает неуместное специальное поведение
C<split " "> [perl #94490].

=item *

C<defined scalar(@array)>, C<defined do { &foo }> и схожие конструкции теперь
рассматривают аргумент к C<defined> как простой скаляр [perl #97466].

=item *

Запуск отладчика, который не определяет глоб C<*DB::DB> или не предоставляет
подпрограмму заглушку для C<&DB::DB> больше не приводит к краху, а выдаёт
сообщение об ошибке [perl #114990].

=item *

C<reset ""> теперь соответствует своей документации. C<reset> сбрасывает только
шаблон C<m?...?> при запуске без аргумента.  Пустая строка в аргументе теперь ни
делает ничего. (Раньше это рассматривалось как отсутствие аргумента)
[perl #97958].

=item *

C<printf> с аргументом, возвращающий пустой список больше не читает дальше конца
стека, приводившего к ошибочному поведению [perl #77094].

=item *

C<--subname> больше не выдаёт ошибочных неясных предупреждений [perl #77240].

=item *

C<v10> теперь доступна как метка или имя пакета.  Это было нечаянно сломано,
когда v-строки были добавлены в Perl v5.6 [perl #56880].

=item *

C<length>, C<pos>, C<substr> и C<sprintf> могут быть сбиты с толку связываниями,
ссылками и typeglob'ами если привидение их к строковому виду меняет внутреннее
представление в или из UTF-8 [perl #114410].

=item *

utf8::encode теперь вызывает FETCH и STORE на связанных переменных.
utf8::decode теперь вызывает STORE (FETCH уже был вызван).

=item *

C<$tied =~ s/$non_utf8/$utf8/> больше не зацикливается в бесконечный цикл, если
связанная переменная возвращает Latin-1 строку, разделяемый скаляр ключа хэша,
или ссылку, или typeglob, который приводится к строковому виду как ASCII или
Latin-1.  Это была регрессия, начиная с v5.12.

=item *

C<s///> без /e теперь лучше определяет когда необходимо отказаться от
определённых оптимизаций, исправляя некоторые ошибочные ситуации:

=over

=item *

Совпадение с переменными в определённых конструкциях  (C<&&>, C<||>, C<..> и
другие) в части замены; например, C<s/(.)/$l{$a||$1}/g>.  [perl #26986]

=item *

Псевдонимы при поиске соответствия переменным в части замещения.

=item *

C<$REGERROR> или C<$REGMARK> в замещении [perl #49190].

=item *

Пустой шаблон (C<s//$foo/>), который приводит к тому, что используется последний
успешно совпавший шаблон, в случае если шаблон содержит кодовый блок, который
изменяет переменные в замещении.

=back

=item *

Заражённость замещаемой строки больше не влияет на заражённость возвращаемого
значения C<s///e>.

=item *

Переменная автоматического сброса буферов C<$|> создаётся на лету при
необходимости.  Если это происходило (например, если она была упомянута в модуле
или в eval) когда текущий выбранный файловый дескриптор был typeglob с пустым IO
слотом, раньше это приводило к краху [perl #115206].

=item *

Номера строк в конце eval строки больше не удлиняются на единицу [perl #114658].

=item *

Фильтры @INC (подпрограммы возвращаемые подпрограммами в @INC), которые
устанавливают $_ в копируемый-при-записи скаляр, больше не заставляют парсер
модифицировать этот строковой буфер на месте.

=item *

C<length($object)> больше не возвращает неопределённое значение, если объект
имеет перегрузку строки, которая возвращает undef [perl #115260].

=item *

Было восстановлено использование C<PL_stashcache>, кэша стэша используемого для
поиска имён для вызова методов.

Коммит da6b625f78f5f133 в августе 2011 нечаянно сломал код, который получал
значения в C<PL_stashcache>.  Так как это только кэш, всё корректно работало и
без него.

=item *

Ошибка "Can't localize through a reference" ("Не могу локализовать через
ссылку") исчезла в v5.16.0, когда C<local %$ref> появлялось на последней строке
lvalue подпрограммы.  Эта ошибка исчезла для C<\local %$ref> в perl v5.8.1.
Сейчас она была восстановлена,

=item *

Разбор встроенной документации был существенно улучшен, исправляя несколько
ошибок разбора, падений и одной утечки памяти, а также корректируя неверную
последовательность номеров строк при определённых условиях.

=item *

Внутри eval сообщение об ошибке для нетерминированных встроенных документах
больше не имеет переноса строка в середине [perl #70836].

=item *

Замещение внутри замещающего шаблона (C<s/${s|||}//>) больше не смущает парсер.

=item *

Возможно не очень правильное место для разрешения комментариев, но
C<s//"" # hello/e> всегда работало, I<только> если не было null символа перед
первым #.  Теперь это работает даже при наличии null.

=item *

An invalid range in C<tr///> or C<y///> no longer results in a memory leak.

=item *

String eval no longer treats a semicolon-delimited quote-like operator at
the very end (C<eval 'q;;'>) as a syntax error.

=item *

C<< warn {$_ => 1} + 1 >> is no longer a syntax error.  The parser used to
get confused with certain list operators followed by an anonymous hash and
then an infix operator that shares its form with a unary operator.

=item *

C<(caller $n)[6]> (which gives the text of the eval) used to return the
actual parser buffer.  Modifying it could result in crashes.  Now it always
returns a copy.  The string returned no longer has "\n;" tacked on to the
end.  The returned text also includes here-doc bodies, which used to be
omitted.

=item *

The UTF-8 position cache is now reset when accessing magical variables, to
avoid the string buffer and the UTF-8 position cache getting out of sync
[perl #114410].

=item *

Various cases of get magic being called twice for magical UTF-8
strings have been fixed.

=item *

This code (when not in the presence of C<$&> etc)

    $_ = 'x' x 1_000_000;
    1 while /(.)/;

used to skip the buffer copy for performance reasons, but suffered from C<$1>
etc changing if the original string changed.  That's now been fixed.

=item *

Perl doesn't use PerlIO anymore to report out of memory messages, as PerlIO
might attempt to allocate more memory.

=item *

In a regular expression, if something is quantified with C<{n,m}> where
C<S<n E<gt> m>>, it can't possibly match.  Previously this was a fatal
error, but now is merely a warning (and that something won't match).
[perl #82954].

=item *

It used to be possible for formats defined in subroutines that have
subsequently been undefined and redefined to close over variables in the
wrong pad (the newly-defined enclosing sub), resulting in crashes or
"Bizarre copy" errors.

=item *

Redefinition of XSUBs at run time could produce warnings with the wrong
line number.

=item *

The %vd sprintf format does not support version objects for alpha versions.
It used to output the format itself (%vd) when passed an alpha version, and
also emit an "Invalid conversion in printf" warning.  It no longer does,
but produces the empty string in the output.  It also no longer leaks
memory in this case.

=item *

C<< $obj->SUPER::method >> calls in the main package could fail if the
SUPER package had already been accessed by other means.

=item *

Stash aliasing (C<< *foo:: = *bar:: >>) no longer causes SUPER calls to ignore
changes to methods or @ISA or use the wrong package.

=item *

Method calls on packages whose names end in ::SUPER are no longer treated
as SUPER method calls, resulting in failure to find the method.
Furthermore, defining subroutines in such packages no longer causes them to
be found by SUPER method calls on the containing package [perl #114924].

=item *

C<\w> now matches the code points U+200C (ZERO WIDTH NON-JOINER) and U+200D
(ZERO WIDTH JOINER).  C<\W> no longer matches these.  This change is because
Unicode corrected their definition of what C<\w> should match.

=item *

C<dump LABEL> no longer leaks its label.

=item *

Constant folding no longer changes the behaviour of functions like C<stat()>
and C<truncate()> that can take either filenames or handles.
C<stat 1 ? foo : bar> nows treats its argument as a file name (since it is an
arbitrary expression), rather than the handle "foo".

=item *

C<truncate FOO, $len> no longer falls back to treating "FOO" as a file name if
the filehandle has been deleted.  This was broken in Perl v5.16.0.

=item *

Subroutine redefinitions after sub-to-glob and glob-to-glob assignments no
longer cause double frees or panic messages.

=item *

C<s///> now turns vstrings into plain strings when performing a substitution,
even if the resulting string is the same (C<s/a/a/>).

=item *

Prototype mismatch warnings no longer erroneously treat constant subs as having
no prototype when they actually have "".

=item *

Constant subroutines and forward declarations no longer prevent prototype
mismatch warnings from omitting the sub name.

=item *

C<undef> on a subroutine now clears call checkers.

=item *

The C<ref> operator started leaking memory on blessed objects in Perl v5.16.0.
This has been fixed [perl #114340].

=item *

C<use> no longer tries to parse its arguments as a statement, making
C<use constant { () };> a syntax error [perl #114222].

=item *

On debugging builds, "uninitialized" warnings inside formats no longer cause
assertion failures.

=item *

On debugging builds, subroutines nested inside formats no longer cause
assertion failures [perl #78550].

=item *

Formats and C<use> statements are now permitted inside formats.

=item *

C<print $x> and C<sub { print $x }-E<gt>()> now always produce the same output.
It was possible for the latter to refuse to close over $x if the variable was
not active; e.g., if it was defined outside a currently-running named
subroutine.

=item *

Similarly, C<print $x> and C<print eval '$x'> now produce the same output.
This also allows "my $x if 0" variables to be seen in the debugger [perl
#114018].

=item *

Formats called recursively no longer stomp on their own lexical variables, but
each recursive call has its own set of lexicals.

=item *

Attempting to free an active format or the handle associated with it no longer
results in a crash.

=item *

Format parsing no longer gets confused by braces, semicolons and low-precedence
operators.  It used to be possible to use braces as format delimiters (instead
of C<=> and C<.>), but only sometimes.  Semicolons and low-precedence operators
in format argument lines no longer confuse the parser into ignoring the line's
return value.  In format argument lines, braces can now be used for anonymous
hashes, instead of being treated always as C<do> blocks.

=item *

Formats can now be nested inside code blocks in regular expressions and other
quoted constructs (C</(?{...})/> and C<qq/${...}/>) [perl #114040].

=item *

Formats are no longer created after compilation errors.

=item *

Under debugging builds, the B<-DA> command line option started crashing in Perl
v5.16.0.  It has been fixed [perl #114368].

=item *

A potential deadlock scenario involving the premature termination of a pseudo-
forked child in a Windows build with ithreads enabled has been fixed.  This
resolves the common problem of the F<t/op/fork.t> test hanging on Windows [perl
#88840].

=item *

The code which generates errors from C<require()> could potentially read one or
two bytes before the start of the filename for filenames less than three bytes
long and ending C</\.p?\z/>.  This has now been fixed.  Note that it could
never have happened with module names given to C<use()> or C<require()> anyway.

=item *

The handling of pathnames of modules given to C<require()> has been made
thread-safe on VMS.

=item *

Non-blocking sockets have been fixed on VMS.

=item *

Pod can now be nested in code inside a quoted construct outside of a string
eval.  This used to work only within string evals [perl #114040].

=item *

C<goto ''> now looks for an empty label, producing the "goto must have
label" error message, instead of exiting the program [perl #111794].

=item *

C<goto "\0"> now dies with "Can't find label" instead of "goto must have
label".

=item *

The C function C<hv_store> used to result in crashes when used on C<%^H>
[perl #111000].

=item *

A call checker attached to a closure prototype via C<cv_set_call_checker>
is now copied to closures cloned from it.  So C<cv_set_call_checker> now
works inside an attribute handler for a closure.

=item *

Writing to C<$^N> used to have no effect.  Now it croaks with "Modification
of a read-only value" by default, but that can be overridden by a custom
regular expression engine, as with C<$1> [perl #112184].

=item *

C<undef> on a control character glob (C<undef *^H>) no longer emits an
erroneous warning about ambiguity [perl #112456].

=item *

For efficiency's sake, many operators and built-in functions return the
same scalar each time.  Lvalue subroutines and subroutines in the CORE::
namespace were allowing this implementation detail to leak through.
C<print &CORE::uc("a"), &CORE::uc("b")> used to print "BB".  The same thing
would happen with an lvalue subroutine returning the return value of C<uc>.
Now the value is copied in such cases.

=item *

C<method {}> syntax with an empty block or a block returning an empty list
used to crash or use some random value left on the stack as its invocant.
Now it produces an error.

=item *

C<vec> now works with extremely large offsets (E<gt>2 GB) [perl #111730].

=item *

Changes to overload settings now take effect immediately, as do changes to
inheritance that affect overloading.  They used to take effect only after
C<bless>.

Objects that were created before a class had any overloading used to remain
non-overloaded even if the class gained overloading through C<use overload>
or @ISA changes, and even after C<bless>.  This has been fixed
[perl #112708].

=item *

Classes with overloading can now inherit fallback values.

=item *

Overloading was not respecting a fallback value of 0 if there were
overloaded objects on both sides of an assignment operator like C<+=>
[perl #111856].

=item *

C<pos> now croaks with hash and array arguments, instead of producing
erroneous warnings.

=item *

C<while(each %h)> now implies C<while(defined($_ = each %h))>, like
C<readline> and C<readdir>.

=item *

Subs in the CORE:: namespace no longer crash after C<undef *_> when called
with no argument list (C<&CORE::time> with no parentheses).

=item *

C<unpack> no longer produces the "'/' must follow a numeric type in unpack"
error when it is the data that are at fault [perl #60204].

=item *

C<join> and C<"@array"> now call FETCH only once on a tied C<$">
[perl #8931].

=item *

Some subroutine calls generated by compiling core ops affected by a
C<CORE::GLOBAL> override had op checking performed twice.  The checking
is always idempotent for pure Perl code, but the double checking can
matter when custom call checkers are involved.

=item *

A race condition used to exist around fork that could cause a signal sent to
the parent to be handled by both parent and child. Signals are now blocked
briefly around fork to prevent this from happening [perl #82580].

=item *

The implementation of code blocks in regular expressions, such as C<(?{})>
and C<(??{})>, has been heavily reworked to eliminate a whole slew of bugs.
The main user-visible changes are:

=over 4

=item *

Code blocks within patterns are now parsed in the same pass as the
surrounding code; in particular it is no longer necessary to have balanced
braces: this now works:

    /(?{  $x='{'  })/

This means that this error message is no longer generated:

    Sequence (?{...}) not terminated or not {}-balanced in regex

but a new error may be seen:

    Sequence (?{...}) not terminated with ')'

In addition, literal code blocks within run-time patterns are only
compiled once, at perl compile-time:

    for my $p (...) {
        # this 'FOO' block of code is compiled once,
	# at the same time as the surrounding 'for' loop
        /$p{(?{FOO;})/;
    }

=item *

Lexical variables are now sane as regards scope, recursion and closure
behavior. In particular, C</A(?{B})C/> behaves (from a closure viewpoint)
exactly like C</A/ && do { B } && /C/>, while  C<qr/A(?{B})C/> is like
C<sub {/A/ && do { B } && /C/}>. So this code now works how you might
expect, creating three regexes that match 0, 1, and 2:

    for my $i (0..2) {
        push @r, qr/^(??{$i})$/;
    }
    "1" =~ $r[1]; # matches

=item *

The C<use re 'eval'> pragma is now only required for code blocks defined
at runtime; in particular in the following, the text of the C<$r> pattern is
still interpolated into the new pattern and recompiled, but the individual
compiled code-blocks within C<$r> are reused rather than being recompiled,
and C<use re 'eval'> isn't needed any more:

    my $r = qr/abc(?{....})def/;
    /xyz$r/;

=item *

Flow control operators no longer crash. Each code block runs in a new
dynamic scope, so C<next> etc. will not see
any enclosing loops. C<return> returns a value
from the code block, not from any enclosing subroutine.

=item *

Perl normally caches the compilation of run-time patterns, and doesn't
recompile if the pattern hasn't changed, but this is now disabled if
required for the correct behavior of closures. For example:

    my $code = '(??{$x})';
    for my $x (1..3) {
	# recompile to see fresh value of $x each time
        $x =~ /$code/;
    }

=item *

The C</msix> and C<(?msix)> etc. flags are now propagated into the return
value from C<(??{})>; this now works:

    "AB" =~ /a(??{'b'})/i;

=item *

Warnings and errors will appear to come from the surrounding code (or for
run-time code blocks, from an eval) rather than from an C<re_eval>:

    use re 'eval'; $c = '(?{ warn "foo" })'; /$c/;
    /(?{ warn "foo" })/;

formerly gave:

    foo at (re_eval 1) line 1.
    foo at (re_eval 2) line 1.

and now gives:

    foo at (eval 1) line 1.
    foo at /some/prog line 2.

=back

=item *

Perl now can be recompiled to use any Unicode version.  In v5.16, it
worked on Unicodes 6.0 and 6.1, but there were various bugs if earlier
releases were used; the older the release the more problems.

=item *

C<vec> no longer produces "uninitialized" warnings in lvalue context
[perl #9423].

=item *

An optimization involving fixed strings in regular expressions could cause
a severe performance penalty in edge cases.  This has been fixed
[perl #76546].

=item *

In certain cases, including empty subpatterns within a regular expression (such
as C<(?:)> or C<(?:|)>) could disable some optimizations. This has been fixed.

=item *

The "Can't find an opnumber" message that C<prototype> produces when passed
a string like "CORE::nonexistent_keyword" now passes UTF-8 and embedded
NULs through unchanged [perl #97478].

=item *

C<prototype> now treats magical variables like C<$1> the same way as
non-magical variables when checking for the CORE:: prefix, instead of
treating them as subroutine names.

=item *

Under threaded perls, a runtime code block in a regular expression could
corrupt the package name stored in the op tree, resulting in bad reads
in C<caller>, and possibly crashes [perl #113060].

=item *

Referencing a closure prototype (C<\&{$_[1]}> in an attribute handler for a
closure) no longer results in a copy of the subroutine (or assertion
failures on debugging builds).

=item *

C<eval '__PACKAGE__'> now returns the right answer on threaded builds if
the current package has been assigned over (as in
C<*ThisPackage:: = *ThatPackage::>) [perl #78742].

=item *

If a package is deleted by code that it calls, it is possible for C<caller>
to see a stack frame belonging to that deleted package.  C<caller> could
crash if the stash's memory address was reused for a scalar and a
substitution was performed on the same scalar [perl #113486].

=item *

C<UNIVERSAL::can> no longer treats its first argument differently
depending on whether it is a string or number internally.

=item *

C<open> with C<< <& >> for the mode checks to see whether the third argument is
a number, in determining whether to treat it as a file descriptor or a handle
name.  Magical variables like C<$1> were always failing the numeric check and
being treated as handle names.

=item *

C<warn>'s handling of magical variables (C<$1>, ties) has undergone several
fixes.  C<FETCH> is only called once now on a tied argument or a tied C<$@>
[perl #97480].  Tied variables returning objects that stringify as "" are
no longer ignored.  A tied C<$@> that happened to return a reference the
I<previous> time it was used is no longer ignored.

=item *

C<warn ""> now treats C<$@> with a number in it the same way, regardless of
whether it happened via C<$@=3> or C<$@="3">.  It used to ignore the
former.  Now it appends "\t...caught", as it has always done with
C<$@="3">.

=item *

Numeric operators on magical variables (e.g., S<C<$1 + 1>>) used to use
floating point operations even where integer operations were more appropriate,
resulting in loss of accuracy on 64-bit platforms [perl #109542].

=item *

Unary negation no longer treats a string as a number if the string happened
to be used as a number at some point.  So, if C<$x> contains the string "dogs",
C<-$x> returns "-dogs" even if C<$y=0+$x> has happened at some point.

=item *

In Perl v5.14, C<-'-10'> was fixed to return "10", not "+10".  But magical
variables (C<$1>, ties) were not fixed till now [perl #57706].

=item *

Unary negation now treats strings consistently, regardless of the internal
C<UTF8> flag.

=item *

A regression introduced in Perl v5.16.0 involving
C<tr/I<SEARCHLIST>/I<REPLACEMENTLIST>/> has been fixed.  Only the first
instance is supposed to be meaningful if a character appears more than
once in C<I<SEARCHLIST>>.  Under some circumstances, the final instance
was overriding all earlier ones.  [perl #113584]

=item *

Regular expressions like C<qr/\87/> previously silently inserted a NUL
character, thus matching as if it had been written C<qr/\00087/>.  Now it
matches as if it had been written as C<qr/87/>, with a message that the
sequence C<"\8"> is unrecognized.

=item *

C<__SUB__> now works in special blocks (C<BEGIN>, C<END>, etc.).

=item *

Thread creation on Windows could theoretically result in a crash if done
inside a C<BEGIN> block.  It still does not work properly, but it no longer
crashes [perl #111610].

=item *

C<\&{''}> (with the empty string) now autovivifies a stub like any other
sub name, and no longer produces the "Unable to create sub" error
[perl #94476].

=item *

A regression introduced in v5.14.0 has been fixed, in which some calls
to the C<re> module would clobber C<$_> [perl #113750].

=item *

C<do FILE> now always either sets or clears C<$@>, even when the file can't be
read. This ensures that testing C<$@> first (as recommended by the
documentation) always returns the correct result.

=item *

The array iterator used for the C<each @array> construct is now correctly
reset when C<@array> is cleared [perl #75596]. This happens, for example, when
the array is globally assigned to, as in C<@array = (...)>, but not when its
B<values> are assigned to. In terms of the XS API, it means that C<av_clear()>
will now reset the iterator.

This mirrors the behaviour of the hash iterator when the hash is cleared.

=item *

C<< $class->can >>, C<< $class->isa >>, and C<< $class->DOES >> now return
correct results, regardless of whether that package referred to by C<$class>
exists [perl #47113].

=item *

Arriving signals no longer clear C<$@> [perl #45173].

=item *

Allow C<my ()> declarations with an empty variable list [perl #113554].

=item *

During parsing, subs declared after errors no longer leave stubs
[perl #113712].

=item *

Closures containing no string evals no longer hang on to their containing
subroutines, allowing variables closed over by outer subroutines to be
freed when the outer sub is freed, even if the inner sub still exists
[perl #89544].

=item *

Duplication of in-memory filehandles by opening with a "<&=" or ">&=" mode
stopped working properly in v5.16.0.  It was causing the new handle to
reference a different scalar variable.  This has been fixed [perl #113764].

=item *

C<qr//> expressions no longer crash with custom regular expression engines
that do not set C<offs> at regular expression compilation time
[perl #112962].

=item *

C<delete local> no longer crashes with certain magical arrays and hashes
[perl #112966].

=item *

C<local> on elements of certain magical arrays and hashes used not to
arrange to have the element deleted on scope exit, even if the element did
not exist before C<local>.

=item *

C<scalar(write)> no longer returns multiple items [perl #73690].

=item *

String to floating point conversions no longer misparse certain strings under
C<use locale> [perl #109318].

=item *

C<@INC> filters that die no longer leak memory [perl #92252].

=item *

The implementations of overloaded operations are now called in the correct
context. This allows, among other things, being able to properly override
C<< <> >> [perl #47119].

=item *

Specifying only the C<fallback> key when calling C<use overload> now behaves
properly [perl #113010].

=item *

C<< sub foo { my $a = 0; while ($a) { ... } } >> and
C<< sub foo { while (0) { ... } } >> now return the same thing [perl #73618].

=item *

String negation now behaves the same under C<use integer;> as it does
without [perl #113012].

=item *

C<chr> now returns the Unicode replacement character (U+FFFD) for -1,
regardless of the internal representation.  -1 used to wrap if the argument
was tied or a string internally.

=item *

Using a C<format> after its enclosing sub was freed could crash as of
perl v5.12.0, if the format referenced lexical variables from the outer sub.

=item *

Using a C<format> after its enclosing sub was undefined could crash as of
perl v5.10.0, if the format referenced lexical variables from the outer sub.

=item *

Using a C<format> defined inside a closure, which format references
lexical variables from outside, never really worked unless the C<write>
call was directly inside the closure.  In v5.10.0 it even started crashing.
Now the copy of that closure nearest the top of the call stack is used to
find those variables.

=item *

Formats that close over variables in special blocks no longer crash if a
stub exists with the same name as the special block before the special
block is compiled.

=item *

The parser no longer gets confused, treating C<eval foo ()> as a syntax
error if preceded by C<print;> [perl #16249].

=item *

The return value of C<syscall> is no longer truncated on 64-bit platforms
[perl #113980].

=item *

Constant folding no longer causes C<print 1 ? FOO : BAR> to print to the
FOO handle [perl #78064].

=item *

C<do subname> now calls the named subroutine and uses the file name it
returns, instead of opening a file named "subname".

=item *

Subroutines looked up by rv2cv check hooks (registered by XS modules) are
now taken into consideration when determining whether C<foo bar> should be
the sub call C<foo(bar)> or the method call C<< "bar"->foo >>.

=item *

C<CORE::foo::bar> is no longer treated specially, allowing global overrides
to be called directly via C<CORE::GLOBAL::uc(...)> [perl #113016].

=item *

Calling an undefined sub whose typeglob has been undefined now produces the
customary "Undefined subroutine called" error, instead of "Not a CODE
reference".

=item *

Two bugs involving @ISA have been fixed.  C<*ISA = *glob_without_array> and
C<undef *ISA; @{*ISA}> would prevent future modifications to @ISA from
updating the internal caches used to look up methods.  The
*glob_without_array case was a regression from Perl v5.12.

=item *

Regular expression optimisations sometimes caused C<$> with C</m> to
produce failed or incorrect matches [perl #114068].

=item *

C<__SUB__> now works in a C<sort> block when the enclosing subroutine is
predeclared with C<sub foo;> syntax [perl #113710].

=item *

Unicode properties only apply to Unicode code points, which leads to
some subtleties when regular expressions are matched against
above-Unicode code points.  There is a warning generated to draw your
attention to this.  However, this warning was being generated
inappropriately in some cases, such as when a program was being parsed.
Non-Unicode matches such as C<\w> and C<[:word:]> should not generate the
warning, as their definitions don't limit them to apply to only Unicode
code points.  Now the message is only generated when matching against
C<\p{}> and C<\P{}>.  There remains a bug, [perl #114148], for the very
few properties in Unicode that match just a single code point.  The
warning is not generated if they are matched against an above-Unicode
code point.

=item *

Uninitialized warnings mentioning hash elements would only mention the
element name if it was not in the first bucket of the hash, due to an
off-by-one error.

=item *

A regular expression optimizer bug could cause multiline "^" to behave
incorrectly in the presence of line breaks, such that
C<"/\n\n" =~ m#\A(?:^/$)#im> would not match [perl #115242].

=item *

Failed C<fork> in list context no longer corrupts the stack.
C<@a = (1, 2, fork, 3)> used to gobble up the 2 and assign C<(1, undef, 3)>
if the C<fork> call failed.

=item *

Numerous memory leaks have been fixed, mostly involving tied variables that
die, regular expression character classes and code blocks, and syntax
errors.

=item *

Assigning a regular expression (C<${qr//}>) to a variable that happens to
hold a floating point number no longer causes assertion failures on
debugging builds.

=item *

Assigning a regular expression to a scalar containing a number no longer
causes subsequent numification to produce random numbers.

=item *

Assigning a regular expression to a magic variable no longer wipes away the
magic.  This was a regression from v5.10.

=item *

Assigning a regular expression to a blessed scalar no longer results in
crashes.  This was also a regression from v5.10.

=item *

Regular expression can now be assigned to tied hash and array elements with
flattening into strings.

=item *

Numifying a regular expression no longer results in an uninitialized
warning.

=item *

Negative array indices no longer cause EXISTS methods of tied variables to
be ignored.  This was a regression from v5.12.

=item *

Negative array indices no longer result in crashes on arrays tied to
non-objects.

=item *

C<$byte_overload .= $utf8> no longer results in doubly-encoded UTF-8 if the
left-hand scalar happened to have produced a UTF-8 string the last time
overloading was invoked.

=item *

C<goto &sub> now uses the current value of @_, instead of using the array
the subroutine was originally called with.  This means
C<local @_ = (...); goto &sub> now works [perl #43077].

=item *

If a debugger is invoked recursively, it no longer stomps on its own
lexical variables.  Formerly under recursion all calls would share the same
set of lexical variables [perl #115742].

=item *

C<*_{ARRAY}> returned from a subroutine no longer spontaneously
becomes empty.

=back

=head1 Known Problems

=over 4

=item *

UTF8-flagged strings in C<%ENV> on HP-UX 11.00 are buggy

The interaction of UTF8-flagged strings and C<%ENV> on HP-UX 11.00 is
currently dodgy in some not-yet-fully-diagnosed way.  Expect test
failures in F<t/op/magic.t>, followed by unknown behavior when storing
wide characters in the environment.

=back

=head1 Obituary

Hojung Yoon (AMORETTE), 24, of Seoul, South Korea, went to his long rest
on May 8, 2013 with llama figurine and autographed TIMTOADY card.  He
was a brilliant young Perl 5 & 6 hacker and a devoted member of
Seoul.pm.  He programmed Perl, talked Perl, ate Perl, and loved Perl.  We
believe that he is still programming in Perl with his broken IBM laptop
somewhere.  He will be missed.

=head1 Acknowledgements

Perl v5.18.0 represents approximately 12 months of development since
Perl v5.16.0 and contains approximately 400,000 lines of changes across
2,100 files from 113 authors.

Perl continues to flourish into its third decade thanks to a vibrant
community of users and developers. The following people are known to
have contributed the improvements that became Perl v5.18.0:

Aaron Crane, Aaron Trevena, Abhijit Menon-Sen, Adrian M. Enache, Alan
Haggai Alavi, Alexandr Ciornii, Andrew Tam, Andy Dougherty, Anton Nikishaev,
Aristotle Pagaltzis, Augustina Blair, Bob Ernst, Brad Gilbert, Breno G. de
Oliveira, Brian Carlson, Brian Fraser, Charlie Gonzalez, Chip Salzenberg, Chris
'BinGOs' Williams, Christian Hansen, Colin Kuskie, Craig A. Berry, Dagfinn
Ilmari Mannsåker, Daniel Dragan, Daniel Perrett, Darin McBride, Dave Rolsky,
David Golden, David Leadbeater, David Mitchell, David Nicol, Dominic
Hargreaves, E. Choroba, Eric Brine, Evan Miller, Father Chrysostomos, Florian
Ragwitz, François Perrad, George Greer, Goro Fuji, H.Merijn Brand, Herbert
Breunung, Hugo van der Sanden, Igor Zaytsev, James E Keenan, Jan Dubois,
Jasmine Ahuja, Jerry D. Hedden, Jess Robinson, Jesse Luehrs, Joaquin Ferrero,
Joel Berger, John Goodyear, John Peacock, Karen Etheridge, Karl Williamson,
Karthik Rajagopalan, Kent Fredric, Leon Timmermans, Lucas Holt, Lukas Mai,
Marcus Holland-Moritz, Markus Jansen, Martin Hasch, Matthew Horsfall, Max
Maischein, Michael G Schwern, Michael Schroeder, Moritz Lenz, Nicholas Clark,
Niko Tyni, Oleg Nesterov, Patrik Hägglund, Paul Green, Paul Johnson, Paul
Marquess, Peter Martini, Rafael Garcia-Suarez, Reini Urban, Renee Baecker,
Rhesa Rozendaal, Ricardo Signes, Robin Barker, Ronald J. Kimball, Ruslan
Zakirov, Salvador Fandiño, Sawyer X, Scott Lanning, Sergey Alekseev, Shawn M
Moore, Shirakata Kentaro, Shlomi Fish, Sisyphus, Smylers, Steffen Müller,
Steve Hay, Steve Peters, Steven Schubiger, Sullivan Beck, Sven Strickroth,
Sébastien Aperghis-Tramoni, Thomas Sibley, Tobias Leich, Tom Wyant, Tony Cook,
Vadim Konovalov, Vincent Pit, Volker Schatz, Walt Mankowski, Yves Orton,
Zefram.

The list above is almost certainly incomplete as it is automatically generated
from version control history. In particular, it does not include the names of
the (very much appreciated) contributors who reported issues to the Perl bug
tracker.

Many of the changes included in this version originated in the CPAN modules
included in Perl's core. We're grateful to the entire CPAN community for
helping Perl to flourish.

For a more complete list of all of Perl's historical contributors, please see
the F<AUTHORS> file in the Perl source distribution.

=head1 Reporting Bugs

If you find what you think is a bug, you might check the articles recently
posted to the comp.lang.perl.misc newsgroup and the perl bug database at
http://rt.perl.org/perlbug/ .  There may also be information at
http://www.perl.org/ , the Perl Home Page.

If you believe you have an unreported bug, please run the L<perlbug> program
included with your release.  Be sure to trim your bug down to a tiny but
sufficient test case.  Your bug report, along with the output of C<perl -V>,
will be sent off to perlbug@perl.org to be analysed by the Perl porting team.

If the bug you are reporting has security implications, which make it
inappropriate to send to a publicly archived mailing list, then please send it
to perl5-security-report@perl.org.  This points to a closed subscription
unarchived mailing list, which includes all the core committers, who will be
able to help assess the impact of issues, figure out a resolution, and help
co-ordinate the release of patches to mitigate or fix the problem across all
platforms on which Perl is supported.  Please only use this address for
security issues in the Perl core, not for modules independently distributed on
CPAN.

=head1 SEE ALSO

The F<Changes> file for an explanation of how to view exhaustive details on
what changed.

The F<INSTALL> file for how to build Perl.

The F<README> file for general stuff.

The F<Artistic> and F<Copying> files for copyright information.

=cut
