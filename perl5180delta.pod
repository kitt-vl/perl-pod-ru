=encoding utf8

=head1 Имя

perl5180delta - что нового в perl v5.18.0

=head1 Описание

Этот документ описывает различия между релизом v5.16.0 и релизом v5.18.0.

Если вы обновляетесь с более раннего релиза, такого как v5.14.0, сначала
прочтите L<perl5160delta>, который описывает различия между v5.14.0 и v5.16.0.

=head1 Улучшения ядра

=head2 Новый механизм экспериментальных возможностей

Впервые добавляемые экспериментальные возможности теперь требуют подобного
вызова:

    no warnings "experimental::feature_name";
    use feature "feature_name";  # будет выводить предупреждения без предыдущей
                                 # строки

Появилась новая категория предупреждений, называемых "экспериментальными",
содержащие предупреждения, которые выдаёт прагма L<feature>, когда подключаются
экспериментальные возможности.

Впервые добавляемые экспериментальные возможности также будут содержать
специальные идентификаторы предупреждения, которые состоят из "experimental::" с
последующим названием возможности.  (Есть план для расширения действия этого
механизма в конечном счёте на все предупреждения, позволяя включать или
отключать их персонально, а не только по категориям.)

Указывая

    no warnings "experimental::feature_name";

вы берёте ответственность за любую поломку, которая может возникнуть в связи с
изменением или удалением соответствующей возможности.

Так как некоторые возможности (такие как C<~~> или C<my $_>) теперь выводят
предупреждение об их экспериментальном характере и вам может потребоваться
отключить их в коде, который может также быть запущен под perl, который не
распознаёт этих категорий предупреждений, рассмотрите возможность использования
прагмы C<if> таким образом:

    no if $] >= 5.018, 'warnings', "experimental::feature_name";

Существующие экспериментальные возможности также могут начать выводить эти
предупреждения. Пожалуйста обратитесь к L<perlexperiment> за информацией о тех
возможностях, которые рассматриваются как экспериментальные.

=head2 Пересмотр реализации хэша

Изменения в реализации хэшей в perl v5.18.0 станут наиболее заметными
изменениями в поведении существующего кода.

По умолчанию два различных хэша с идентичными ключами и значениями могут
возвращать их содержимое в различном порядке, тогда как раньше порядок был
одинаковым.

При столкновении с этими изменениями, ключевым моментом для исправления
последствий станет принятие правила, что B<хэши - это беспорядочные коллекции> и
действие в соответствии с ним.

=head3 Рандомизация хэша

Ключ (seed) используемый хэш-функцией Perl теперь является случайным.  Это
означает что порядок, в котором ключи/значения будут возвращены из функций
C<keys()>, C<values()> и C<each()>, будет различаться от запуска к запуску.

Это изменение было сделано, чтобы сделать хэши Perl более устойчивыми к атакам
на алгоритмическую сложность, а также мы обнаружили, что это выявляет ошибки
зависимости от порядка хэша, делая их простыми для обнаружения.

Для разработчиков утилит сборки есть повод вложить силы в дополнительную
инфраструктуру для тестирования подобных вещей.  Запуская тесты несколько раз
подряд и сравнивая результаты, можно легко выявить зависимости от порядка хэша в
коде.  Авторам настойчиво рекомендуется не демонстрировать ключ рандомизации
хэшей Perl для небезопасной публики.

Кроме того, каждый хэш имеет свой собственный порядок итерации, что делает
значительно более сложным определение какой ключ рандомизации хэша используется
в данный момент.

=head3 Новые хэш-функции

Perl v5.18 включает поддержку множества хэш-функций и меняет хэш-функцию по
умолчанию (на ONE_AT_A_TIME_HARD), вы можете выбрать другой алгоритм указывая
параметр при компиляции.  Для просмотра текущего списка обратитесь к документу
F<INSTALL>. Обратите внимание, что начиная с Perl v5.18 мы можем рекомендовать
использовать только хэш-функцию по умолчанию или SIPHASH. Все другие имеют
известные проблемы с безопасностью и могут использоваться только для
исследовательских целей.

=head3 Переменная окружения PERL_HASH_SEED теперь принимает шестнадцатиричное значение

C<PERL_HASH_SEED> больше не принимает целочисленное значение как параметр;
вместо этого ожидается бинарное значение закодированное в шестнадцатиричную
строку, как например, "0xf5867c55039dc724". Это сделано для того, чтобы
поддерживать ключи рандомизации хэша произвольной длины, которые могут превышать
лимит целого числа (int).  (SipHash использует ключ в 16 байт).

=head3 Добавлена переменная окружения PERL_PERTURB_KEYS

Переменная окружения C<PERL_PERTURB_KEYS> позволяет контролировать уровень
случайности, применяемый к C<keys> и подобным.

Когда C<PERL_PERTURB_KEYS> установлен в 0, perl не будет рандомизировать порядок
ключей.  Шанс, что изменения в C<keys> из-за вставки будут такими же как в
предыдущих perl, в основном из-за изменения размера ячейки.

Когда C<PERL_PERTURB_KEYS> установлен в 1, perl будет рандомизировать ключи в
неповторяющемся порядке. Шанс, что вывод C<keys> изменится в результате вставки,
крайне высок.  Это наиболее безопасно и является режимом по умолчанию.

Когда C<PERL_PERTURB_KEYS> установлен в 2, perl будет рандомизировать ключи в
воспроизводимом порядке. Повторные запуски одной и той же программы каждый раз
будут выводить один и тот же результат.

C<PERL_HASH_SEED> подразумевает установку нестандартного C<PERL_PERTURB_KEYS>.
Устанавливая C<PERL_HASH_SEED=0> (именно один 0) устанавливает
C<PERL_PERTURB_KEYS=0> (рандомизация хэша отключена); установка
C<PERL_HASH_SEED> в любое другое значение подразумевает C<PERL_PERTURB_KEYS=2>
(детерминированную и повторяемую рандомизацию хэша). Явное указание
C<PERL_PERTURB_KEYS> в другое значение переопределяет это поведение.

=head3 Hash::Util::hash_seed() теперь возвращает строку

Hash::Util::hash_seed() теперь возвращает строку, вместо целого числа.  Это
необходимо, чтобы сделать инфраструктурную поддержку для ключей рандомизации
хэша произвольной длины, превышающей размер целого числа.  (SipHash использует
ключ размером 16 байт).

=head3 Изменился вывод PERL_HASH_SEED_DEBUG

Переменная окружения PERL_HASH_SEED_DEBUG теперь заставляет perl показывать оба
параметра: хэш-функцию, с которой был собран perl, I<и> ключ рандомизации в
шестнадцатиричном виде, используемый в текущем процессе.  Существующий код,
обрабатывающий этот вывод, должен быть изменён под новый формат.  Пример нового
формата:

    $ PERL_HASH_SEED_DEBUG=1 ./perl -e1
    HASH_FUNCTION = MURMUR3 HASH_SEED = 0x1476bb9f

=head2 Обновление до Юникода 6.2

Perl теперь поддерживает стандарт Юникода версии 6.2.  Список отличий от Юникода
6.1 доступен на L<http://www.unicode.org/versions/Unicode6.2.0>.

=head2 Псевдоним символа теперь может включать символы не из диапазона Latin1

Теперь возможно определить ваши собственные имена для использования в
C<\N{...}>, C<charnames::vianame()> и т.п. Эти имена теперь могут включать
символы из всего диапазона Юникода.  /то позволяет использовать имена на вашем
родном языке, а не только Английском. Некоторые ограничения накладываются на
символы, которые могут быть использованы (вы не можете использовать имена со
знаками пунктуации внутри, например).  Смотрите L<charnames/CUSTOM ALIASES>.

=head2 Новые проверки DTrace

Следующие новые датчики (probes) были добавлены в DTrace:

=over 4

=item *

C<op-entry>

=item *

C<loading-file>

=item *

C<loaded-file>

=back

=head2 C<${^LAST_FH}>

Эта новая переменная даёт доступ к последнему файловому дескриптору, из которого
происходило чтение.  Это дескриптор, который используется в C<$.>, C<tell> и
C<eof> без аргументов.

=head2 Операции со множествами в регулярных выражениях

Это B<экспериментальная> возможность, которая позволяет проверять совпадения в
объединении, пересечении и другими операциями со множествами кодов символов,
подобно модулю L<Unicode::Regex::Set>.  Это также может использоваться для
расширения возможностей обработки в C</x> [заключённых в скобки] классов
символов и как замена свойств, определённых пользователем, позволяя создавать
более сложные выражения, чем это было возможно до этого.  Смотрите
L<perlrecharclass/Extended Bracketed Character Classes>.

=head2 Лексические подпрограммы

Эта возможность по прежнему рассматривается B<экспериментальной>.  Для её
включения необходимо:

    use 5.018;
    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";

Теперь вы можете декларировать подпрограммы с помощью C<state sub foo>, C<my sub
foo> и C<our sub foo>.  (C<state sub> также требует, чтобы возможность "state"
была включена, если только вы не записывает её в виде C<CORE::state sub foo>.)

C<state sub> создаёт подпрограмму видимую внутри лексической области видимости,
в которой она определена.  Подпрограмма является разделяемой между вызовами внешней
подпрограммы.

C<my sub> декларирует лексическую подпрограмму видимую внутри лексической
области видимости, в которой она определена.  C<state sub> в целом работает
немного быстрее, чем C<my sub>.

C<our sub> декларирует лексический псевдоним для подпрограммы пакета с тем же
именем.

Для большей информации обратитесь к L<perlsub/Lexical Subroutines>.

=head2 Вычисляемые метки

Для управления циклом C<next>, C<last> и C<redo>, а также специального
оператора C<dump>, теперь можно использовать произвольное выражение, для
вычисления меток во время работы программы.  Ранее любые аргументы, которые не
являлись константами рассматривались как пустая строка.

=head2 Больше CORE:: подпрограмм

Ещё несколько встроенных функций было добавлено как подпрограммы в пространство
имён CORE::, т.е. те непереопределяемые ключевые слова, которые могут быть
определены без специальных парсеров: C<defined>, C<delete>, C<exists>,
C<glob>, C<pos>, C<protoytpe>, C<scalar>, C<split>, C<study> и C<undef>.

Так как некоторые из них имеют прототипы, C<prototype('CORE::...')> был изменён
таким образом, чтобы не делать различий между переопределяемыми и
непереопределяемыми ключевыми словами.  Это было необходимо, чтобы согласовать
C<prototype('CORE::pos')> с C<prototype(&CORE::pos)>.

=head2 C<kill> с отрицательным именем сигнала

C<kill> всегда допускал использование отрицательного номера сигнала, который
убивал группу процессов, вместо одного процесса.  Также он разрешал использовать
и имена сигналов.  Но вёл себя непоследовательно, поскольку отрицательные имена
сигналов рассматривались как 0.  Теперь отрицательные имена сигналов, как
например, C<-INT> поддерживаются и рассматриваются по аналогии, что и -2
[perl #112990].

=head1 Безопасность

=head2 Смотрите также: пересмотр реализации хэша

Некоторые изменения в L<пересмотре реализации хэша|/"Пересмотр реализации хэша">
были сделаны для улучшения безопасности.  Пожалуйста, прочтите эту секцию.

=head2 Предупреждение о безопасности в документации C<Storable>

Документация C<Storable> теперь включает секцию, которая предупреждает читателя
об опасности принятия данных формата Storable от источников, к которым нет
доверия.  В кратком изложении, десереализация некоторых типов данных может
привести к загрузке модулей и другим вариантам выполнения кода.  Это
задокументированное и ожидаемое поведение, но с другой стороны открывает
вектор атаки для злоумышленников.

=head2 C<Locale::Maketext> позволял включение произвольного кода через специальный темплейт

Если пользователи имеют возможность предоставлять строки переводов для
Locale::Maketext, это может быть использовано для вызова произвольной Perl
подпрограммы, доступной в текущем процессе.

Это было исправлено, но по прежнему доступна возможность вызова любого метода,
предоставляемого самим C<Locale::Maketext> или подклассом, который вы
используете. Один из таких методов в свою очередь выполняет встроенную Perl
подпрограмму C<sprintf>.

В целом, разрешать пользователям делать перевод без аудита их результата
является плохой идеей.

Эта уязвимость задокументирована в CVE-2012-6329.

=head2 Избегайте вызова memset с отрицательным цислом

Плохо написанный perl код, который даёт возможность атакующему указывать число
повторов строки в операторе C<x> уже подвержен атакам на отказ в обслуживании
при исчерпании памяти.  Уязвимость в версиях perl до v5.15.5 позволяет сверх
того привести к переполнение кучи, что в совокупности с использованием glibc
версии до 2.16, позволяет привести к выполнению произвольного кода.

Эта уязвимость получила идентификатор CVE-2012-5195 и была обнаружена Тимом
Брауном (Tim Brown).

=head1 Несовместимые изменения

=head2 Смотрите также: пересмотр реализации хэша

Некоторые изменения в L<пересмотре реализации хэша|/"Пересмотр реализации хэша">
несовместимы с предыдущими версиями perl. Пожалуйста прочтите эту секцию.

=head2 Неизвестное имя символа в C<\N{...}> теперь является синтаксической ошибкой

Ранее выводилось предупреждение и производилось замещение Юникод символом
замещения REPLACEMENT CHARACTER. Стандарт Юникод теперь рекомендует обрабатывать
данную ситуацию как ошибку.  Кроме того, предыдущее поведение приводило к
некоторым сбивающим с толку предупреждениями и действиям, и, так как символ
REPLACEMENT CHARACTER не имеет других применений, кроме как замены для
неизвестного символа, любой код, который имеет такую проблему, - кривой.

=head2 Ранее устаревший символ в C<\N{}> псевдониме символа теперь является ошибкой.

Начиная с v5.12.0 было помечено устаревшим использование некоторых символов в
определённых пользователем C<\N{...}> именах символов.  Теперь это вызывает
синтаксическую ошибку. Например, теперь считается ошибкой начинать имена с цифр,
как в случае

 my $undraftable = "\N{4F}";    # Синтаксическая ошибка!

или иметь запятые где угодно в имени. Смотрите L<charnames/CUSTOM ALIASES>.

=head2 C<\N{BELL}> теперь соответствует коду U+1F514 вместо U+0007

Unicode 6.0 использовал имя "BELL" для другого кода символа, вместо
традиционного значения.  Начиная с Perl 5.14 использование этого имени
по-прежнему ссылалось на код U+0007, но выводило предупреждение об устаревшей
конструкции.  Теперь "BELL" ссылается на код U+1F514, а именем для U+0007 стало
"ALERT".  Все соответствующие функции в L<charnames> были обновлены.

=head2 Новые ограничения в многосимвольном нечувствительном к регистру сравнении в регулярных выражениях для заключённых в скобки классах символов

Юникод теперь убрал свои ранние рекомендации для регулярных выражений для
автоматической обработки случаев, когда один символ может совпадать с
несколькими символами в нечувствительном к регистру сравнении, например, буква
LATIN SMALL LETTER SHARP S и последовательность C<ss>.  Поскольку оказалось, что
это не может быть выполнено корректно во всех случаях.  Так как Perl пытается
сделать сделать всё от него возможное, он продолжит делать так, как раньше. (Мы
рассматриваем вариант опции, для отключения этого поведения). Однако новые
ограничения были добавлены на подобные сравнения, когда они происходят в
[заключённых в скобки] классах символов.  Люди, указывающие вещи на подобии
C</[\0-\xff]/i>, бывают удивлены, когда это совпадает с последовательностью из
двух символов C<ss> (поскольку LATIN SMALL LETTER SHARP S входит в этот
диапазон).  Это поведение также рассогласованно с использованием свойств вместо
диапазонов: C<\p{Block=Latin1}> также включает LATIN SMALL LETTER SHARP S, но
C</[\p{Block=Latin1}]/i> не совпадает с C<ss>.

По новым правилам, чтобы происходило совпадение при регистронезависимом
сравнении с несколькими символами внутри заключённого в скобки класса символов,
требуется, чтобы символ был указан там явно и не являлся конечным символом
диапазона.  Это хорошо соответствует принципу наименьшего удивления.  Смотрите
L<perlrecharclass/Bracketed Character Classes>.  Обратите внимание, что ошибка
[perl #89774] была исправлена, как часть этого изменения, препятствовавшая
работе сравнения в полной мере.

=head2 Ясные правила для имён переменных и идентификаторов

В результате недосмотра, односимвольные имена переменных в v5.16 были полностью
неограниченны.  Это открывало двери для разного рода безумств.  Начиная с v5.18
они теперь следуют правилам других идентификаторов и в дополнении допускающих
использование символов, соответствующих свойству C<\p{POSIX_Punct}>.

Теперь нет никакой разницы в разборе идентификаторов, указанных с использованием
фигурных скобок и без них.  Например, perl допускал использование C<${foo:bar}>
(с одиночным двоеточием), но не допускал C<$foo:bar>.  Теперь оба случая
обрабатываются одним участком кода и оба обрабатываются одинаково: оба
запрещены.  Обратите внимание, что это изменение касается границам допустимого в
задании буквенных идентификаторов, а не других выражений.

=head2 Вертикальная табуляция теперь пробельный символ

Никто не может вспомнить почему C<\s> не совпадает с C<\cK> - вертикальной
табуляцией.  Теперь совпадает.  Учитывая экстремальный раритет данного символа,
ожидается очень небольшой число поломок.  Как было сказано, теперь это означает,
что:

C<\s> в регулярных выражениях всегда совпадает с вертикальной табуляцией при
любых условиях.

Литеральные вертикальные табуляции в регулярных выражениях теперь игнорируются,
когда используется модификатор C</x>.

Лидирующие символы вертикальной табуляции, поодиночке или вперемешку с другими
пробельными символами теперь игнорируются при интерпретации строки как числа.
Например:

  $dec = " \cK \t 123";
  $hex = " \cK \t 0xF";

  say 0 + $dec;   # было 0 с предупреждением, теперь 123
  say int $dec;   # было 0, стало 123
  say oct $hex;   # было 0, стало  15

=head2 C</(?{})/> и C</(??{})/> были сильно переработаны

Реализация этой возможности была практически полностью переписана.  Хотя
основной целью было исправление ошибок, некоторое поведение, особенно связанное
с областью видимости лексических переменных, было изменено.  Это описано более
полно в секции L</Некоторые исправленные ошибки>.

=head2 Более строгий синтаксический разбор подстановки замены

Теперь больше невозможно злоупотреблять особенностью разбора синтаксиса
C<s///e>, как в данном случае:

    %_=(_,"Just another ");
    $_="Perl hacker,\n";
    s//_}->{_/e;print

=head2 C<given> теперь ссылается на глобальную C<$_>

Вместо присвоения явной лексической переменной C<$_>, C<given> теперь делает
глобальную C<$_> псевдонимом для своего аргумента, также как и  C<foreach>.
Однако он по-прежнему использует лексическую C<$_>, если присутствует
лексическая C<$_> в данной области видимости (и снова, также как C<foreach>)
[perl #114020].

=head2 Возможности из семейства умного сравнения теперь являются экспериментальными

Умное сравнение, которое было добавлено в v5.10.0 и значительно пересмотрено в
v5.10.1, постоянно было источником недовольства.  Несмотря на некоторое число
полезных возможностей, оно всё же признавалось проблемным и сбивающим с толку
как для пользователей, так и разработчиков Perl.  Было сделано несколько
предложений по исправлению проблемы.  Стало ясно, что умное сравнение
практически наверняка будет либо изменено или исчезнет в будущем.  Полагаться на
его текущее поведение не рекомендуется.

Теперь будут выдаваться предупреждения, когда парсер будет видеть C<~~>,
C<given> или C<when>.  Для отключения этих предупреждений, вы можете добавить
данную строку в соответствующую область видимости:

  no if $] >= 5.018, "experimental::smartmatch";

Тем не менее рассматривайте замену использования этих возможностей, так как они
могут изменить своё поведение снова перед тем как вновь станут стабильными.

=head2 Лексическая C<$_> теперь является экспериментальной

Начиная со своего появления в Perl v5.10, она вызывала много путаницы без
ясного решения:

=over

=item *

Различные модули (например, List::Util) ожидают, что колбэк-функции используют
глобальную C<$_>.  C<use List::Util 'first'; my $_; first { $_ == 1 } @list> не
будет работать так, как ожидается.

=item *

Объявление C<my $_> ранее в том же файле может вызывать вывод сбивающего с толку
предупреждения замыкания.

=item *

Символ "_" в прототипе подпрограммы позволяет вызываемой подпрограмме иметь
доступ к вашей лексической C<$_>, так что она в итоге не является по-настоящему
приватной.

=item *

Несмотря на это, подпрограммы с прототипом "(@)" или методы не могут получить
доступ к лексической переменной C<$_> вызывающего кода, если только они не
написаны с использованием XS.

=item *

Но даже XS подпрограммы не могут получить доступ к лексической переменной C<$_>,
объявленной не в вызывающей подпрограмме, а во внешней области видимости, если
эта подпрограмма не упоминает C<$_> или не использует операции, которые по
умолчанию взаимодействуют с C<$_>.

=back

Мы надеемся, что лексическая C<$_> может быть реабилитирована, но это может
вызвать изменения в её поведении.  Пожалуйста используйте её с осторожностью,
пока она не станет стабильной.

=head2 readline() в C<$/ = \N> теперь читает N символов, а не N байтов

Ранее при чтении из потока со слоями I/O, такими как C<encoding>, функция
readline() иначе известная как оператор C<< <> >> читало I<N> байт с верхнего
слоя. [perl #79960]

Теперь, вместо этого читается I<N> символов.

Никаких изменений в поведении при чтении из потоков без дополнительных слоёв
нет, так как байты точно соответствуют символам.

=head2 Переопределённый C<glob> теперь передаёт один аргумент

Переопределение C<glob> раньше передавало магический недокументированный второй
аргумент, который идентифицировал вызывающий его код.  Ничего на CPAN не
использовало это, поэтому изменение было внесено как исправление бага и аргумент
был удалён.  Если вам действительно необходимо идентифицировать вызывающую
подпрограмму, смотрите L<Devel::Callsite> на CPAN.

=head2 Синтаксический разбор встроенной документации (here doc)

Тело встроенного документа внутри оператора цитирования теперь всегда начинается
на строке после маркера "<<foo".  Ранее было задокументировано, что оно
начинается на следующей строке, содержащей оператор цитирования, но это было
лишь изредка так [perl #114040].

=head2 Цифробуквенные операторы должны быть теперь отделены от закрывающего ограничителя регулярного выражения

Теперь вы не можете записывать так:

 m/a/and 1

Вместо этого вы должны записать:

 m/a/ and 1

с пробелом отделяющим оператор от закрывающего ограничителя регулярного
выражения.  Отсутствие пробела приведёт к выводу предупреждения об устаревшем
функционале, начиная с Perl v5.14.0.

=head2 qw(...) теперь не может быть использован в качестве скобок

Списки C<qw> раньше заставляли парсер думать, что они всегда заключены в скобки.
Это позволяло использовать удивительные конструкции такие как C<foreach $x qw(a
b c) {...}>, которые на самом деле должны были быть записаны C<foreach $x (qw(a
b c)) {...}>. Это иногда приводило лексический анализатор в неверное состояние,
поэтому они не работали в полной мере, и схожая запись C<foreach qw(a
b c) {...}>, которая ожидалась дозволительной, вообще никогда не работала.

Эти побочные эффекты C<qw> теперь удалены.  Они были помечены устаревшими
начиная с Perl v5.13.11.  Теперь обязательно требуется использовать скобки
везде, где грамматика требует их.

=head2 Взаимодействие лексических и обычных предупреждений

Включение любых лексических предупреждений использовалось раньше для отключения
всех предупреждений по умолчанию, если лексические предупреждения не были ещё
подключены:

    $*; # предупреждение об устаревшей конструкции
    use warnings "void";
    $#; # предупреждение о пустом контексте; нет предупреждения об устаревшей
        # конструкции

Теперь C<debugging>, C<deprecated>, C<glob>, C<inplace> и C<malloc> категории
предупреждений остаются включёнными при включении лексических предупреждений
(разумеется если они не отключены через C<no warnings>).

Это может привести к появлению предупреждений об устаревших конструкциях в коде,
который раньше не выдавал предупреждений.

Это единственные подобные категории, состоящие только из предупреждений по
умолчанию.  Предупреждения по умолчанию в других категориях по прежнему
отключены при использовании C<< use warnings "category" >>, так как у нас пока
нет инфраструктуры за контролем индивидуальных предупреждений.

=head2 C<state sub> и C<our sub>

По случайности, C<state sub> и C<our sub> были эквивалентны обычному C<sub>,
так что была возможность даже создать анонимную подпрограмму с помощью
C<our sub { ... }>.  Теперь это запрещено вне действия возможности
"lexical_subs".  При включении возможности "lexical_subs" они получает новый
смысл, описанный в L<perlsub/Lexical Subroutines>.

=head2 Значения, хранимые в переменных окружения, принудительно переводятся в байтовые строки

Значение, хранимое в переменной окружения всегда приводилось к строке.  В данном
выпуске оно конвертируется в байтовую строку.  Раньше она приводилась только к
строковому виду.  Если строка utf8 и аналог C<utf8::downgrade()> срабатывает, то
используется полученный результат, в противном случае используется эквивалент
C<utf8::encode()> и выводится предупреждение о широком символе
(L</Diagnostics>).

=head2 C<require> умирает на нечитаемых файлах

Когда C<require> обнаруживает нечитаемый файл, он теперь умирает.  Раньше файл
игнорировался и продолжался поиск в директориях в C<@INC> [perl #113422].

=head2 C<gv_fetchmeth_*> и SUPER

Различные XS функции C<gv_fetchmeth_*> раньше рассматривали пакет, чьё имя
заканчивается на C<::SUPER> по особому.  Поиск метода в пакете C<Foo::SUPER>
рассматривался как поиск C<SUPER> метода в пакете C<Foo>.  Больше это не так.
Для поиска метода C<SUPER> передавайте стэш C<Foo> и флаг C<GV_SUPER>.

=head2 Первый аргумент C<split> теперь интерпретируется более согласовано

После некоторых изменений ранее в v5.17, поведение C<split> было упрощено: если
аргумент шаблона вычисляется в строку, содержащую один пробел, то оно
обрабатывается также как и I<литеральная> строка, содержащая один пробел как
было раньше.

=head1 Устаревшие конструкции

=head2 Удаление модулей

Следующие модули будут удалены из базового дистрибутива в будущих релизах и
потребуют в будущем установки со CPAN.  В дистрибутивах на CPAN, требующие эти
модули, потребуется указывать как и как зависимости.

Версии модулей в базовом дистрибутиве теперь будут выдавать предупреждения из
категории C<"устаревшее"> для предупреждения вас об этом факте.  Для отключения
этих предупреждений об устаревании, установите эти модули со CPAN.

Обратите внимание, что (за редким исключением) это прекрасные модули, которые мы
призываем вас продолжать использовать.  Их исключение из базового состава в
основном следствие необходимости предварительной подготовки (bootstrapping)
полнофункциональной, CPAN-совместимой инсталляции Perl, а не обеспокоенность их
дизайном.

=over

=item L<encoding>

Использование этой прагмы теперь крайне не рекомендуется.  Она объединяет
кодирование исходного текста и кодирование данных ввода/вывода, повторно
интерпретирует управляющие последовательности в исходном тексте (сомнительный
выбор) и приводит к UTF-8 багам во всех приложениях, обрабатывающим строки
символов.  Она сломана как и ожидалось и не может быть исправлена.

Для использования не-ASCII литеральных символов в исходном коде, пожалуйста
смотрите L<utf8>.  Для работы с текстовым данными ввода/вывода, пожалуйста
смотрите L<Encode> и L<open>.

=item L<Archive::Extract>

=item L<B::Lint>

=item L<B::Lint::Debug>

=item L<CPANPLUS> и все включенные в C<CPANPLUS::*> модули

=item L<Devel::InnerPackage>

=item L<Log::Message>

=item L<Log::Message::Config>

=item L<Log::Message::Handlers>

=item L<Log::Message::Item>

=item L<Log::Message::Simple>

=item L<Module::Pluggable>

=item L<Module::Pluggable::Object>

=item L<Object::Accessor>

=item L<Pod::LaTeX>

=item L<Term::UI>

=item L<Term::UI::History>

=back

=head2 Устаревшие утилиты

Следующие утилиты будут удалены из базового дистрибутива в будущих релизах, так
как связанные с ними модули устарели.  Они по-прежнему будут доступны в
соответствующем CPAN дистрибутиве.

=over

=item L<cpanp>

=item C<cpanp-run-perl>

=item L<cpan2dist>

Это утилиты часть дистрибутива C<CPANPLUS>.

=item L<pod2latex>

Эта утилита часть дистрибутива C<Pod::LaTeX>.

=back

=head2 PL_sv_objcount

Эта глобальная в интерпретаторе переменная, раньше учитывала общее число Perl
объектов в интерпретаторе.  Она более не сопровождается и будет удалена в Perl
v5.20.

=head2 Пять дополнительных символов должны быть экранированы в шаблонах с C</x>

В шаблонах регулярных выражений, компилируемых с ключом C</x>, Perl игнорирует 6
символов пробельного типа, такие как пробел и табуляция. Однако в стандарте
Юникод рекомендуется рассматривать как пробельные 11 символов. Мы будем
соответствовать этому стандарту в будущей версии Perl.  В данный момент,
использование этих недостающих символов в неэкранированном виде будет приводить
к выводу предупреждений, если предупреждения не отключены. Вот эти 5 символов:

    U+0085 NEXT LINE
    U+200E LEFT-TO-RIGHT MARK
    U+200F RIGHT-TO-LEFT MARK
    U+2028 LINE SEPARATOR
    U+2029 PARAGRAPH SEPARATOR

=head2 Определённые пользователем имена символов с неожиданными пробелами

Определённые пользователем имена символов с завершающими или несколькими подряд
идущими пробелами с большой вероятностью являются опечатками.  Теперь такая
запись выдаёт предупреждение, на основании того, что его использование вряд ли
требует избыток пробелов.

=head2 Различные функции, вызываемые в XS программах теперь устарели

Все функции, использовавшиеся для классификации символов, будут удалены из
будущей версии Perl и не должны использоваться.  При помощи C компилятора
(например, gcc) сборка любого файла, которая использует любую из этих функций
будут выдавать предупреждение.  Они не были предназначены для публичного
использования; существуют эквивалентные более быстрые макросы для большинства из
них.

Смотрите L<perlapi/Character classes>.  Это полный список:

C<is_uni_alnum>, C<is_uni_alnumc>, C<is_uni_alnumc_lc>,
C<is_uni_alnum_lc>, C<is_uni_alpha>, C<is_uni_alpha_lc>,
C<is_uni_ascii>, C<is_uni_ascii_lc>, C<is_uni_blank>,
C<is_uni_blank_lc>, C<is_uni_cntrl>, C<is_uni_cntrl_lc>,
C<is_uni_digit>, C<is_uni_digit_lc>, C<is_uni_graph>,
C<is_uni_graph_lc>, C<is_uni_idfirst>, C<is_uni_idfirst_lc>,
C<is_uni_lower>, C<is_uni_lower_lc>, C<is_uni_print>,
C<is_uni_print_lc>, C<is_uni_punct>, C<is_uni_punct_lc>,
C<is_uni_space>, C<is_uni_space_lc>, C<is_uni_upper>,
C<is_uni_upper_lc>, C<is_uni_xdigit>, C<is_uni_xdigit_lc>,
C<is_utf8_alnum>, C<is_utf8_alnumc>, C<is_utf8_alpha>,
C<is_utf8_ascii>, C<is_utf8_blank>, C<is_utf8_char>,
C<is_utf8_cntrl>, C<is_utf8_digit>, C<is_utf8_graph>,
C<is_utf8_idcont>, C<is_utf8_idfirst>, C<is_utf8_lower>,
C<is_utf8_mark>, C<is_utf8_perl_space>, C<is_utf8_perl_word>,
C<is_utf8_posix_digit>, C<is_utf8_print>, C<is_utf8_punct>,
C<is_utf8_space>, C<is_utf8_upper>, C<is_utf8_xdigit>,
C<is_utf8_xidcont>, C<is_utf8_xidfirst>.

В дополнении к этому три функции, которые никогда не работали правильно теперь
объявлены устаревшими:
C<to_uni_lower_lc>, C<to_uni_title_lc> и C<to_uni_upper_lc>.

=head2 Определённые редкие случаи использования обратной косой черты внутри регулярных выражений теперь являются устаревшими

Существуют три пары символов, которые Perl распознаёт как метасимволы в
шаблонах регулярных выражений: C<{}>, C<[]> и C<()>.  Они могут использоваться
для разделения шаблонов, как например:

  m{foo}
  s(foo)(bar)

Поскольку они являются метасимволами, они имеют специальное значение в шаблонах
регулярных выражений и оказывается, что вы не можете отключить это специальное
значение при обычном использовании предшествующего символа обратной косой, если
вы используете их сдвоенными внутри шаблона, ограниченного ими же. Например:

  m{foo\{1,3\}}

обратная косая черта не изменяет поведение и это совпадает с S<C<"fo">> с
последующим одним или тремя включениями C<"o">.

Подобное использование, где они интерпретируются как метасимволы, крайне редкое;
мы полагаем, что такого нет, например, на всём CPAN.  Следовательно эта
устаревшая конструкция затронет очень немного кода.  Однако будет выдано
уведомление, что любой подобный код должен быть изменён, что в свою очередь даст
нам возможность изменить поведение будущих версий Perl так, что обратная косая
черта будет действовать без страха, что мы молча сломаем чей-то существующий
код.

=head2 Разделение символов C<(?> и C<(*> в регулярных выражениях

Теперь выводится предупреждение об устаревшей конструкции, если C<(> и C<?>
разделены пробелом или комментарием в шаблонах регулярного выражения C<(?...)>.
То же относится к случаю, если C<(> и C<*> разделены в конструкции
C<(*VERB...)>.

=head2 Пред-PerlIO реализации ввода/вывода

В теории вы можете собрать perl без PerlIO.  Вместо него вам придётся
использовать обёртку вокруг stdio и sfio.  На практике это не очень полезно.
Это не так хорошо протестировано, и без какой-либо поддержки для слоёв
ввода/вывода или (таким образом) Юникода это лишь небольшой кусок perl.
Возможность сборки без PerlIO скорее всего будет удалена в следующей версии
perl.

PerlIO поддерживает слой C<stdio>, если желательно использование stdio.  Точно
также слой sfio может быть создан в будущем, если будет нужен.

=head1 Устаревающий функционал

=over

=item *

Платформы без инфраструктурной поддержки

Обе платформы Windows CE и z/OS исторически поддерживались и на данный момент не
собираются успешно и нерегулярно тестируются.  Прилагаются усилия для изменения
ситуации, но не гарантируется, что платформы безопасны и поддерживаемы.  Если
они не начнут собираться и регулярно тестироваться, их поддержка может быть
удалена в будущих релизах.  Если у вас есть интерес к этим платформам и вы
можете потратить своё время, опыт или аппаратное обеспечение для помощи в
поддержке этих платформ, пожалуйста дайте знать разработчикам написав письмо в
C<perl5-porters@perl.org>.

Некоторые платформы, которые похоже окончательно мертвы, также в списке на
удаление к v5.20.0:

=over

=item DG/UX

=item NeXT

=back

Также мы думаем, что вероятно текущие версии Perl больше не собираются на
AmigaOS, DJGPP, NetWare (нативно), OS/2 и Plan 9.  Если вы используете Perl на
этих платформах и имеете интерес к обеспечению будущего Perl на них, пожалуйста
свяжитесь с нами.

Мы уверенны, что Perl уже долго не может быть собран на смешанных endian
архитектурах (такие как PDP-11) и намереваемся удалить весь оставшийся код их
поддержки. Также код поддержки давно неподдерживаемого GNU dld будет скоро
удалён, если никто не заявит о себе, как о заинтересованном пользователе.

=item *

Обмен $< и $>

Perl поддерживал идиому обмена $< и $> (а также $( и $)) для временного сброса
привилегий, начиная с 5.0, как например:

    ($<, $>) = ($>, $<);

Однако такая идиома, изменяющая реальный идентификатор пользователя/группы, и
которая может иметь нежелательные побочные эффекты, больше не является полезной
на любых платформах, поддерживаемых perl, и усложняет реализацию этих переменных
и присвоения списком в целом.

Как альтернатива, рекомендуется присваивать только C<< $> >>:

    local $> = $<;

Смотрите также: L<Setuid Demystified|http://www.cs.berkeley.edu/~daw/papers/setuid-usenix02.pdf>.

=item *

C<microperl> давно сломан и неясно его нынешнее предназначение, будет удалён.

=item *

Поправлена семантика C<< "\Q" >> в строках с двойными кавычками при комбинации с
другими экранирующими последовательностями.

Присутствовало несколько ошибок и противоречий, затрагивающие комбинацию C<\Q> и
экранированных записей C<\x>, C<\L> и т.п. внутри пары C<\Q...\E>.  Это требует
исправления, что это обязательно приведёт к изменению текущего поведения.  Эти
изменения пока ещё не устоялись.

=item *

Использование записи C<$x>, где C<x> представляет собой любой (непечатный)
контрольный символ, будет запрещено в будущей версии Perl.  Используйте вместо
этого C<${x}> (где снова C<x> означает управляющий символ), а ещё лучше, C<$^A>,
где C<^> - это знак вставки (CIRCUMFLEX ACCENT), а C<A> означает любой символ,
указанный в списке в конце L<perlebcdic/OPERATOR DIFFERENCES>.

=back

=head1 Увеличение производительности

=over 4

=item *

Списочное определение лексических переменных (C<my($x, $y)>) теперь
оптимизировано к одной операции и следовательно работает быстрее, чем раньше.

=item *

Была добавлена новая константа для C препроцессора C<NO_TAINT_SUPPORT>, которая,
если установлена, полностью отключает поддержку taint режима.  Использование
флагов -T или -t в командной строке приведёт к фатальной ошибке.  Будьте
осторожны, поскольку и базовые тесты и многие тесты CPAN дистрибутивов будут
провалены с этим изменением.  С другой стороны, предоставляется небольшое
повышение производительности, связанное с уменьшением ветвления кода.

B<Не устанавливайте эту константу, если вы точно не понимаете к чему это вас
приведёт>.


=item *

C<pack> с аргументом константой теперь вычисляется в константу в большинстве
случаев. [perl #113470].

=item *

Ускорение регулярных выражений при поиске совпадений с Юникод свойствами.
Наиболее заметное ускорение получено для C<\X>, "расширенный кластер графем"
Юникода.  Ускорение для него составляет где-то 35% - 40%.  Заключённые в скобки
классы символов, например, C<[0-9\x{100}]>, содержащие свыше 255 кодовых точек,
также стали быстрее.

=item *

На платформах, поддерживающие их, некоторые бывшие макросы теперь были
реализованы как статические встроенные (inline) функции.  Это должно ускорить
их значительно на не-GCC платформах.

=item *

Оптимизация хэшей в логическом контексте было расширенно и на случаи
C<scalar(%hash)>, C<%hash ? ... : ...> и C<sub { %hash || ... }>.

=item *

Операторы файловых тестов управляют стеком немного более эффективным способом.

=item *

Глобы, используемые в числовом контексте, теперь приводятся к числу в
большинстве случаев непосредственно, а не путём предварительного приведения к
строковому виду.

=item *

Оператор повторения C<x> теперь приводится к простой константе на этапе
компиляции, если вызывается в скалярном контексте с постоянным операндом и без
скобок вокруг левого операнда.

=back

=head1 Модули и Прагмы

=head2 Новые модули и прагмы

=over 4

=item *

Был добавлен модуль L<Config::Perl::V> версии 0.16 как "живущий в двух местах"
(dual-lifed) модуль.  Он предоставляет структурированную выборку данных из
вывода C<perl -V>, включая информацию известную только двоичному файлы perl и
недоступную через L<Config>.

=back

=head2 Обновлённые модули и прагмы

Для полного списка обновлений, запустите:

  $ corelist --diff 5.16.0 5.18.0

Вы также можете заменить нужную вам версию взамен C<5.16.0>.

=over

=item *

L<Archive::Extract> был обновлён до 0.68.

Обход проблемы в некоторых случаях на Linux с unzip из Busybox.

=item *

L<Archive::Tar> был обновлён до 1.90.

ptar теперь поддерживает опцию -T также, как и опцию без дефисов
[rt.cpan.org #75473], [rt.cpan.org #75475].

Авто-кодирование имён файлов, помеченных как UTF-8 [rt.cpan.org #75474].

Не используется C<tell> на дескрипторах L<IO::Zlib> [rt.cpan.org #64339].

Не пытается вызывать C<chown> на символических ссылках.

=item *

L<autodie> был обновлён до 2.13.

C<autodie> теперь играет по правилам с прагмой 'open'.

=item *

L<B> был обновлён до 1.42.

Был добавлен метод C<stashoff> для COPs.  Это даёт доступ к внутренним
свойствам, добавленным в perl 5.16 в сборках с поддержкой нитей [perl #113034].


C<B::COP::stashpv> теперь поддерживает UTF-8 имена пакетов и встроенные NUL'и.

Все C<CVf_*> и C<GVf_*>, и другие относящиеся к SV флаги теперь доступны как
константы в пространстве имён C<B::> и доступны для экспортирования.  Список
экспортируемых символов не изменился.

Теперь модуль может работать с новым pad API.

=item *

L<B::Concise> был обновлён до 0.95.

Была исправлена опция C<-nobanner>, а C<format> теперь может быть выведен.
Когда указывается имя подпрограммы для вывода делается также проверка является
ли это именем формата.  Если подпрограмма и формат имеют одно и тоже имя, то они
оба будут выведены.

Также была добавлена поддержка новых флагов C<OpMAYBE_TRUEBOOL> и
C<OPpTRUEBOOL>.

=item *

L<B::Debug> был обновлён до 1.18.

Была добавлена поддержка (экспериментальная) для C<B::PADLIST>, которая была
добавлена в Perl 5.17.4.

=item *

L<B::Deparse> был обновлён до 1.20.

Убраны предупреждения, если запускается под C<perl -w>.

Теперь он разбирает управляющие конструкции циклов в правильном порядке и
множественные операции в C<format> строке теперь также разбираются правильно.

В этом выпуске подавляются точки с запятой в конце записи формата.

В этом выпуске добавлена заглушка для разбора  лексических подпрограмм.

Он больше не падает при разборе C<sort> без аргументов.  Теперь он корректно
опускает запятые в C<system $prog @args> и C<exec $prog @args>.

=item *

L<bignum>, L<bigint> и L<bigrat> были обновлены до 0.33.

Переопределение для C<hex> и C<oct> было переписано, решая несколько проблем и
внося одно несовместимое изменение:

=over

=item *

Прежде, какой бы из модулей C<use bigint> или C<use bigrat> не был скомпилирован
позже, он брал приоритет над другими, приводя к тому, что C<hex> и C<oct> не
учитывали действие других прагм в данной области видимости.

=item *

Использование любых из этих трёх прагм приводило к тому, что C<hex> и C<oct> во
всех других местах программы обрабатывали свои аргументы в списочном контексте и
препятствовали работе с $_, когда вызывались без аргументов.

=item *

Использование любой из этих трёх прагм заставляло C<oct("1234")> возвращать 1234
(для любого числа, не начинающегося с 0) в любом месте программы.  Теперь "1234"
транслируются из восьмеричного к десятичному, независимо находится ли оно в
области видимости прагмы или нет.

=item *

Глобальное переопределение, которое устанавливает лексическое использование
C<hex> и C<oct>, теперь учитывает любые существующие переопределения, которые
действовали до включения нового переопределения, возвращая их вне действия
области действия C<use bignum>.

=item *

C<use bignum "hex">, C<use bignum "oct"> и подобные вызовы для bigint и bigrat
теперь экспортируют функции C<hex> или C<oct>, вместо создания глобального
переопределения.

=back

=item *

L<Carp> был обновлён до 1.29.

Carp больше не приходит в замешательство, если C<caller> возвращает undef для
пакета, который был удалён.

Функции C<longmess()> и C<shortmess()> теперь задокументированы.

=item *

L<CGI> был обновлён до 3.63.

Нераспознаваемые экранирующие последовательности HTML теперь обрабатываются
лучше, проблемные завершающие переводы строк больше не вставляются после тегов
E<lt>formE<gt> функциями C<startform()> или C<start_form()>, и ложное
предупреждение "Insecure Dependency" (небезопасная зависимость) на некоторых
версиях perl теперь обходится.

=item *

L<Class::Struct> был обновлён до 0.64.

Конструктор теперь учитывает переопределённый метод доступа [perl #29230].

=item *

L<Compress::Raw::Bzip2> был обновлён до 2.060.

Неправильное использование "магического" API Perl было исправлено.

=item *

L<Compress::Raw::Zlib> был обновлён до 2.060.

Была обновлена, поставляемый с модулем, библиотека zlib до версии 1.2.7

Были исправлены ошибки сборки на Irix, Solaris и Win32, а также сборка с
использованием C++ [rt.cpan.org #69985], [rt.cpan.org #77030],
[rt.cpan.org #75222].

Неправильное использование "магического" API Perl было исправлено.

C<compress()>, C<uncompress()>, C<memGzip()> и C<memGunzip()> были ускорены за
счёт более эффективной проверки параметров.

=item *

L<CPAN::Meta::Requirements> был обновлён до 2.122.

Обрабатываются undef зависимости в C<from_string_hash> как 0 (с предупреждением).

Добавлен метод C<requirements_for_module>.

=item *

L<CPANPLUS> был обновлён до 0.9135.

Разрешено добавлять F<blib/script> к PATH.

Сохраняется история между запусками командной строки.

Лучше поддерживаются множественные аргументы для C<makemakerargs> и
C<makeflags>.

Исправлены проблемы с SQLite движком.

=item *

L<Data::Dumper> был обновлён до 2.145.

Было оптимизировано создание хэша уже обработанных скаляров только при
необходимости, тем самым существенно повысив скорость сериализации.

Были добавлены дополнительные тесты для улучшения покрытия операторов, веток,
условий и подпрограмм.  По данным анализа покрытия, некоторые внутренности
Dumper.pm были переработаны.  Почти все методы теперь задокументированы.

=item *

L<DB_File> был обновлён до 1.827.

Основной Perl модуль больше не использует конструкцию C<"@_">.

=item *

L<Devel::Peek> был обновлён до 1.11.

Были исправлены возможность сборки компилятором C++ и работы с новым pad API.

=item *

L<Digest::MD5> был обновлён до 2.52.

Исправлен откат на C<Digest::Perl::MD5> в ОО-интерфейсе [rt.cpan.org #66634].

=item *

L<Digest::SHA> был обновлён до 5.84.

Исправлена ошибка с двойным освобождением памяти, которая могла приводить к
уязвимости в некоторых случаях.

=item *

L<DynaLoader> был обновлён до 1.18.

Сделано небольшое исправление в XS для VMS реализации.

Исправлено предупреждение об использовании секции C<CODE> без секции C<OUTPUT>. 

=item *

L<Encode> был обновлён до 2.49.

Был добавлен алиас x-mac-ce для Mac и исправлены ошибки в Encode::Unicode,
Encode::UTF7 и Encode::GSM0338.

=item *

L<Env> был обновлён до 1.04.

Его реализация SPLICE больше не ведёт себя неправильно в списочном контексте.

=item *

L<ExtUtils::CBuilder> был обновлён до 0.280210.

Файлы манифестов теперь корректно встраиваются для тех версий VC++, которые
используют их. [perl #111782, #111798].

Список экспортируемых символов может быть передан в C<link()> на Windows, так же
как и на других ОС [perl #115100].

=item *

L<ExtUtils::ParseXS> был обновлён до 3.18.

Генерируемый C код теперь избегает ненужного увеличения C<PL_amagic_generation>
на версиях Perl, где это делается автоматически (или на текущем Perl, где
переменная больше не существует).

Это устраняет ложное предупреждение об инициализированном XSUB без параметров
[perl #112776].

=item *

L<File::Copy> был обновлён до 2.26.

C<copy()> больше не обнуляет файлы при копировании в тот же каталог и теперь
завершается с ошибкой (как это было давно задокументировано), когда пытается
копировать файл в самого себя.

=item *

L<File::DosGlob> был обновлён до 1.10.

Внутренний кэш имён файлов, который он поддерживает для каждого вызывающего,
теперь освобождается, когда освобождается вызывающий код.  Это означает, что
в C<< use File::DosGlob 'glob'; eval 'scalar <*>' >> больше не утекает память.

=item *

L<File::Fetch> был обновлён до 0.38.

Добавлена опция 'file_default' для URL, которые не имеют файловой составляющей.

Используйте C<File::HomeDir>, если доступно, и выставляйте
C<PERL5_CPANPLUS_HOME> для замены автоопределения.

Всегда запрашивает F<CHECKSUMS>, если установлен C<fetchdir>.

=item *

L<File::Find> был обновлён до 1.23.

Была исправлена несовместимая обработка unix-путей на VMS.

Выборочные файлы теперь могут указываться в списках директорий для поиска
[perl #59750].

=item *

L<File::Glob> был обновлён до 1.20.

В File::Glob сделано то же исправление, что и в File::DosGlob.  Поскольку именно
его использует собственный оператор C<glob> (кроме VMS), это означает, что
в C<< eval 'scalar <*>' >> больше нет утечки.

Список разделённых пробелом шаблонов, возвращающий длинный список результатов
больше не приводит к повреждению памяти или аварийному завершению.  Эта проблема
появилась в Perl 5.16.0.  [perl #114984]

=item *

L<File::Spec::Unix> был обновлён до 3.40.

C<abs2rel> может вывести некорректный результат, если получает два относительных
пути, или две корневых директории [perl #111510].

=item *

L<File::stat> был обновлён до 1.07.

C<File::stat> игнорирует прагму L<filetest> и предупреждает, если используется в
комбинации с ней.  Но предупреждения не выдавалась при использовании C<-r>.  Это
было исправлено [perl #111640].

C<-p> теперь работает и не возвращает ложь для каналов [perl #111638].

Ранее перегруженные операторы C<-x> и C<-X> из C<File::stat> не давали
правильных результатов для директорий или исполнимых файлов, если были запущены
с правами root.  Они рассматривали право исполнения для root также как и для
всех других пользователей, выполняя проверку вхождения в группу, для файлов не
принадлежащих root.  Теперь они следуют правильному поведению в Unix - для
директорий они всегда истинны, а для файла, если любой из трёх битов разрешения
запуска установлен, они сообщают, что root может запустить файл.  Встроенные
операторы C<-x> и C<-X> всегда работали правильно.

=item *

L<File::Temp> был обновлён до 0.23

Исправлены различные ошибки, связанные с удалением директорий.  Откладывается
удаление временных файлов, если первоначальное удаление завершаются неудачей,
это исправляет проблемы на NFS.

=item *

L<GDBM_File> был обновлён до 1.15.

Недокументированный необязательный пятый параметр к C<TIEHASH> был удалён.  Он
задумывался для предоставления контроля над колбэком, используемым функциями
C<gdbm*> в случае фатальных ошибок (такие как проблемы файловой системы), но не
работал (и никогда не работал).  Ни один модуль на CPAN даже не предпринимал
попыток его использования.  Колбэк теперь всегда по умолчанию C<croak>.  Были
решены проблемы с тем, как на некоторых платформах вызывается C<C> функция
C<croak>.

=item *

L<Hash::Util> был обновлён до 0.15.

C<hash_unlocked> и C<hashref_unlocked> теперь возвращают истину, если хэш
разблокирован, вместо того, чтобы постоянно возвращать ложь [perl #112126].

C<hash_unlocked>, C<hashref_unlocked>, C<lock_hash_recurse> и
C<unlock_hash_recurse> теперь доступны для экспорта [perl #112126].

Были добавлены две новые функции: C<hash_locked> и C<hashref_locked>.
Как это ни странно, обе этих функции уже экспортировались, несмотря на то, что
они не существовали [perl #112126].

=item *

L<HTTP::Tiny> был обновлён до 0.025.

Добавлены возможности проверки SSL [github #6], [github #9].

Включается финальный URL в хэш-ссылку ответа.

Добавлена опция C<local_address>.

Улучшена поддержка SSL.

=item *

L<IO> был обновлён до 1.28.

C<sync()> теперь можно вызывать на доступных только на чтение файловых
дескрипторах [perl #64772].

L<IO::Socket> пытается лучше кэшировать или в противном случае получить
информацию из сокета.

=item *

L<IPC::Cmd> был обновлён до 0.80.

Используется C<POSIX::_exit> вместо C<exit> в C<run_forked> [rt.cpan.org #76901].

=item *

L<IPC::Open3> был обновлён до 1.13.

Функция C<open3()> больше не использует C<POSIX::close()> для закрытия файлового
дескриптора, так как это ломает подсчёт ссылок файловых дескрипторов, который
ведёт PerlIO в случаях если файловые дескрипторы разделены потоками PerlIO,
что приводит к попыткам закрытия файлового дескриптора во второй раз, когда
любой из подобных PerlIO потоков закрывается позже.

=item *

L<Locale::Codes> был обновлён до 3.25.

Он включает некоторые новые коды.

=item *

L<Memoize> был обновлён до 1.03.

Исправлена опция кэша C<MERGE>.

=item *

L<Module::Build> был обновлён до 0.4003.

Исправлена проблема, когда модули без C<$VERSION> могли иметь версию '0'
указанную в метаданных 'provides', которая будет отклоняться в PAUSE.

Исправлена проблема в PodParser для разрешения цифр в именах модулей.

Исправлена проблема, когда повторное указание аргументов приводит к тому, что
они становятся массивами, приводящее к тому, что пути установки превращались в
подобное F<ARRAY(0xdeadbeef)/lib/Foo.pm>.

Небольшая проблема была исправлена, позволяя использовать разметку вокруг
начального "Name" в строке POD "abstract", и было сделано несколько улучшений в
документации.

=item *

L<Module::CoreList> был обновлён до 2.90

Информация о версии теперь сохраняются в виде дельт, что значительно уменьшает
размер файла F<CoreList.pm>.

Восстановлена совместимость со старыми версиями perl и подчищены данные списка
базовых пакетов для различных модулей.

=item *

L<Module::Load::Conditional> был обновлён до 0.54.

Исправлено использование C<requires> для perl установленного в пути, содержащем
пробелы.

Различные улучшения, включая использование нового модуля Module::Metadata.

=item *

L<Module::Metadata> был обновлён до 1.000011.

Создание объекта Module::Metadata для типичного файла модуля ускорено примерно
на 40%, и некоторые ложные предупреждения о C<$VERSION> были подавлены.

=item *

L<Module::Pluggable> был обновлён до 4.7.

В ряду других изменений теперь разрешено использование триггеров на событиях,
которое даёт большие возможности по изменению поведения.

=item *

L<Net::Ping> был обновлён до 2.41.

Исправлено несколько падающих тестов на Windows.

=item *

L<Opcode> был обновлён до 1.25.

Отражено удаление опкода boolkeys и добавление опкодов clonecv, introcv и padcv.

=item *

L<overload> был обновлён до 1.22.

C<no overload> теперь предупреждает об ошибочных аргументах, как и
C<use overload>.

=item *

L<PerlIO::encoding> был обновлён до 0.16.

Это модуль, который реализует ":encoding(...)" слой ввода/вывода.  Он больше не
повреждает память и не падает, при кодирующий код повторно выделяет буфер или
возвращает typeglob или разделяемый скалярный ключ хэша.

=item *

L<PerlIO::scalar> был обновлён до 0.16.

Передаваемый скаляр буфера теперь может содержать только кодовые точки 0xFF или
ниже. [perl #109828]

=item *

L<Perl::OSType> был обновлён до 1.003.

Исправлена ошибка определения операционной системы VOS.

=item *

L<Pod::Html> был обновлён до 1.18.

Была восстановлена опция C<--libpods>.  Она устарела и её использование ничего
не делает, кроме выдачи предупреждения, что она не поддерживается.

Так как HTML файлы генерируются с помощью pod2html, который уверяет, что
использует кодировку UTF-8, запись файлов идёт с использованием UTF-8
[perl #111446].

=item *

L<Pod::Simple> был обновлён до 3.28.

Несколько улучшений было сделано в основном в Pod::Simple::XHTML, который также
имеет совместимое изменение: опция C<codes_in_verbatim> отключена по умолчанию.
Смотрите все детали в F<cpan/Pod-Simple/ChangeLog>.

=item *

L<re> был обновлён до 0.23

Односимвольные классы символов, как C</[s]/> или C</[s]/i> теперь
оптимизируются, как если бы они и не имели скобок, т.е. C</s/> или C</s/i>.

Смотрите замечания о C<op_comp> в секции L</Внутренние изменения> ниже.

=item *

L<Safe> был обновлён до 2.35.

Исправлено взаимодействие с C<Devel::Cover>.

Не выполняется eval кода при действии C<no strict>.

=item *

L<Scalar::Util> был обновлён до 1.27.

Исправлена проблема с C<sum>.

C<first> и C<reduce> теперь проверяет сначала колбэк (таким образом C<&first(1)>
теперь не позволяется).

Исправлен C<tainted> на магических значениях [rt.cpan.org #55763].

Исправлен C<sum> на ранее магических значениях [rt.cpan.org #61118].

Исправлено чтение за пределами фиксированного буфера [rt.cpan.org #72700].

=item *

L<Search::Dict> был обновлён до 1.07.

Больше не требуется C<stat> на файловых дескрипторах.

Используйте C<fc> для приведения к одному регистру.

=item *

L<Socket> был обновлён до 2.009.

Были добавлены константы и функции, требуемые для членства в исходных группах IP
мультискаста.

C<unpack_sockaddr_in()> и C<unpack_sockaddr_in6()> теперь возвращает только IP
адрес в скалярном контексте и C<inet_ntop()> теперь защищён от некорректной
длины скаляра, передаваемого ему.

Исправлено чтение неинициализированной памяти.

=item *

L<Storable> был обновлён до 2.41.

Изменяя C<$_[0]> внутри C<STORABLE_freeze> больше не приводит к краху
[perl #112358].

Объект, чей класс реализует C<STORABLE_attach>, теперь размораживается только
один раз, когда присутствуют несколько ссылок на него в структуре, которая
размораживается [perl #111918].

Ограниченные хэши не всегда размораживались корректно [perl #73972].

Storable будет выдавать ошибку при замораживании благословенной ссылки объекта с
методом C<STORABLE_freeze()> [perl #113880].

Теперь он может замораживать и размораживать корректно vstrings.  Это приводит к
незначительному несовместимому изменению в формату хранения, поэтому версия
формата была увеличена до 2.9.

Также содержаться различные исправления, включающие исправления совместимости с
ранними версиями Perl и обработки vstring.

=item *

L<Sys::Syslog> был обновлён до 0.32.

Содержится несколько исправлений ошибок, связанных с C<getservbyname()>,
C<setlogsock()> и уровнями логов в C<syslog()>, совместно с исправлениями для
Windows, Haiku-OS и GNU/kFreeBSD.  Смотрите все детали в
F<cpan/Sys-Syslog/Changes>

=item *

L<Term::ANSIColor> был обновлён до 4.02.

Добавлена поддержка для курсива.

Улучшена обработка ошибок.

=item *

L<Term::ReadLine> был обновлён до 1.10.

Было исправлено использование оболочек B<cpan> и B<cpanp> на Windows в случае,
если текущий диск содержит файл F<\dev\tty> .

=item *

L<Test::Harness> был обновлён до 3.26.

Исправлена семантика glob на Win32 [rt.cpan.org #49732].

Не используется C<Win32::GetShortPathName> при вызове perl [rt.cpan.org #47890].

Игнорируется -T при чтении шебанга [rt.cpan.org #64404].

Более элегантно обрабатывается случай, когда мы не знаем статуса wait теста.

Реализована возможность переопределения строчки отчёта теста 'ok', и изменение
её в плагине, чтобы сделать вывод prove неизменным.

Не запускаются файлы, доступные для записи для всех.

=item *

L<Text::Tabs> и  L<Text::Wrap> были обновлены до 2012.0818.

В оба была добавлена поддержка комбинированных символов Юникода.

=item *

L<threads::shared> был обновлён до 1.31.

Добавлена опция, которая предупреждает или игнорирует попытки клонировать
структуры, которые не могут быть клонированы, вместо безусловного падения в
таких случаях.

Добавлена поддержка переменных с двойным значением, создаваемые с помощью
L<Scalar::Util::dualvar|Scalar::Util/"dualvar NUM, STRING">.

=item *

L<Tie::StdHandle> был обновлён до 4.3.

C<READ> теперь учитывает аргумент отступа в C<read> [perl #112826].

=item *

L<Time::Local> был обновлён до 1.2300.

Значения секунд больше чем 59, но меньше чем 60 больше не приводят к ошибкам в
C<timegm()> и C<timelocal()>.

=item *

L<Unicode::UCD> был обновлён до 0.53.

Была добавлена функция L<all_casefolds()|Unicode::UCD/all_casefolds()>, которая
возвращает все случаи регистрового изменения.

=item *

L<Win32> был обновлён до 0.47.

Новые API были добавлены для получения и установки текущей кодовой страницы.

=back


=head2 Удалённые модули и прагмы

=over

=item *

L<Version::Requirements> был удалён из базового дистрибутива.  Теперь он
доступен под другим именем: L<CPAN::Meta::Requirements>.

=back

=head1 Документация

=head2 Изменения в существующей документации

=head3 L<perlcheat>

=over 4

=item *

L<perlcheat> был реорганизован и было добавлено несколько новых секций.

=back

=head3 L<perldata>

=over 4

=item *

Теперь явно документировано поведение инициализации хэша списком, который
содержит дублирующие ключи.

=back

=head3 L<perldiag>

=over 4

=item *

Объяснение почему символические ссылки запрещены при "strict refs" теперь не
предполагают, что читатель знаком, что представляют из себя символические
ссылки.

=back

=head3 L<perlfaq>

=over 4

=item *

L<perlfaq> было синхронизирован с версией 5.0150040 на CPAN.

=back

=head3 L<perlfunc>

=over 4

=item *

Возвращаемое значение C<pipe> теперь задокументировано.

=item *

Прояснена документация C<our>.

=back

=head3 L<perlop>

=over 4

=item *

Команды управления циклом (C<dump>, C<goto>, C<next>, C<last> и C<redo>) всегда
имели тот же приоритет, что и операторы присвоения, но это не было
задокументировано до этого времени.

=back

=head3 Диагностика

Следующие дополнения или изменения были сделаны в диагностическом выводе,
включая предупреждения или сообщения фатальных ошибок.  Для полного списка
диагностических изменений смотрите в L<perldiag>.

=head2 Новая диагностика

=head3 Новые ошибки

=over 4

=item *

L<Unterminated delimiter for here document|perldiag/"Unterminated delimiter for here document">

Это сообщение теперь появляется, когда метка встроенного документа имеет
начальный символ цитирования, но отсутствует завершающий.

Это замещает некорректное сообщение об ошибке, что не найдена сама метка
[perl #114104].

=item *

L<panic: child pseudo-process was never scheduled|perldiag/"panic: child pseudo-process was never scheduled">

Эта ошибка выводится, когда дочерний псевдо-процесс в ithreads реализации на
Windows не был запланирован за допустимый период времени и таким образом не смог
быть инициализирован корректно [perl #88840].

=item *

L<Group name must start with a non-digit word character in regex; marked by <-- HERE in mE<sol>%sE<sol>|perldiag/"Group name must start with a non-digit word character in regex; marked by <-- HERE in m/%s/">

Эта ошибка была добавлена для C<(?&0)>, которая некорректна. Раньше выводилось
непонятное сообщение об ошибке [perl #101666].

=item *

L<Can't use an undefined value as a subroutine reference|perldiag/"Can't use an undefined value as %s reference">

Вызов неопределённого значения как подпрограммы теперь выводит данное сообщение
об ошибке. Раньше оно присутствовало, но случайно было отключено сначала в Perl
5.004 для немагических переменных, затем в Perl v5.14 для магических (например,
связанных) переменных.  Теперь оно было восстановлено. На протяжении этого
времени undef рассматривался как пустая строка [perl #113576].

=item *

L<Experimental "%s" subs not enabled|perldiag/"Experimental "%s" subs not enabled">

Для использования лексических подпрограмм вы должны сначала включить их:

    no warnings 'experimental::lexical_subs';
    use feature 'lexical_subs';
    my sub foo { ... }

=back

=head3 Новые предупреждения

=over 4

=item *

L<'Strings with code points over 0xFF may not be mapped into in-memory file handles'|perldiag/"Strings with code points over 0xFF may not be mapped into in-memory file handles">

=item *

L<'%s' resolved to '\o{%s}%d'|perldiag/"'%s' resolved to '\o{%s}%d'">

=item *

L<'Trailing white-space in a charnames alias definition is deprecated'|perldiag/"Trailing white-space in a charnames alias definition is deprecated">

=item *

L<'A sequence of multiple spaces in a charnames alias definition is deprecated'|perldiag/"A sequence of multiple spaces in a charnames alias definition is deprecated">

=item *

L<'Passing malformed UTF-8 to "%s" is deprecated'|perldiag/"Passing malformed UTF-8 to "%s" is deprecated">

=item *

L<Subroutine "&%s" is not available|perldiag/"Subroutine "&%s" is not available">

(Категория closure) Во время компиляции внутренняя именованная подпрограмма или
eval пытаются использовать внешнюю лексическую подпрограмму, которая недоступна
в данный момент.  Это может происходить по двум причинам.  Во-первых,
лексическая подпрограмма могла быть объявлена во внешней анонимной подпрограмме,
которая ещё не была создана.  (Помните, что именованные подпрограммы создаются
на этапе компиляции, в то время как анонимные подпрограммы создаются во время
выполнения). Например:

    sub { my sub a {...} sub f { \&a } }

Ко времени, когда создаётся f она не может получить доступ к текущей
подпрограмме "a", так как анонимная подпрограмма ещё не была создана.  И
наоборот, следующее выражение не выдаст предупреждение, так как анонимная
подпрограмма уже была создана и доступна:

    sub { my sub a {...} eval 'sub f { \&a }' }->();

Вторая ситуация вызвана функцией eval, которая обращается к переменной, которая
уже ушла из области видимости, например:

    sub f {
        my sub a {...}
        sub { eval '\&a' }
    }
    f()->();

Здесь, когда '\&a' внутри eval компилируется, f() в данный момент не выполняется
и поэтому его &a не доступна.

=item *

L<"%s" subroutine &%s masks earlier declaration in same %s|perldiag/"%s" subroutine &%s masks earlier declaration in same %s>

(Категория misc) Подпрограмма "my" или "state" была повторно объявлена в текущей
области видимости или операторе, уничтожая доступ к предыдущему экземпляру.  Это
практически всегда опечатка.  Обратите внимание, что ранняя подпрограмма
по-прежнему будет существовать до завершения текущей области видимости или пока
все замыкания, ссылающиеся на неё, не будут уничтожены.

=item *

L<The %s feature is experimental|perldiag/"The %s feature is experimental">

(Категория experimental) Это предупреждение выводится, когда вы подключаете
экспериментальные возможности, с помощью C<use feature>.  Просто подавляйте
предупреждение, если вы хотите использовать эту возможность, но делая так вы
берёте на себя риски использования экспериментальной возможности, которая может
измениться или будет удалена в будущей версии Perl:

    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";

=item *

L<sleep(%u) too large|perldiag/"sleep(%u) too large">

(Категория overflow) Вы вызвали C<sleep> с числом, которое больше, чем он может
надёжно принять и C<sleep> вероятно будет спать меньшее время, чем было
запрошено.

=item *

L<Wide character in setenv|perldiag/"Wide character in %s">

Попытки поместить широкие символы в переменные окружения через C<%ENV> теперь
выдают подобное предупреждение.

=item *

"L<Invalid negative number (%s) in chr|perldiag/"Invalid negative number (%s) in chr">"

C<chr()> теперь предупреждает, когда ему передаётся отрицательное значение
[perl #83048].

=item *

"L<Integer overflow in srand|perldiag/"Integer overflow in srand">"

C<srand()> теперь предупреждает, если переданное значение не помещается в C<UV>
(так как значение будет обрезано и не произойдёт переполнения) [perl #40605].

=item *

"L<-i used with no filenames on the command line, reading from STDIN|perldiag/"-i used with no filenames on the command line, reading from STDIN">"

Запуск perl с ключом C<-i> теперь выводит предупреждение, если не было указано
ни одного входного файла в командной строке [perl #113410].

=back

=head2 Изменения в существующией диагностике

=over 4

=item *

L<$* is no longer supported|perldiag/"$* is no longer supported">

Предупреждение о том, что использование C<$*> и C<$#> больше не поддерживается
теперь выводится для каждого участка кода, который ссылается на них. Раньше оно
не выводилось, если другая переменная, использовавшая такой же typeglob
обнаруживалась раньше (например, C<@*> перед C<$*>), а также не выводилось
второй и последующих записей.  (Достаточно трудно исправить ошибку вывода
предупреждения вообще, без того, чтобы не выводить это предупреждение каждый
раз, и предупреждение каждый раз согласуется с предупреждением, которое
выводится для C<$[>).

=item *

Были добавлены предупреждения для C<\b{> и C<\B{>.  Это предупреждения об
устаревших конструкциях, которые должны отключаться по выключению данной
категории.  Теперь не требуется также выключать предупреждения регулярных
выражений, чтобы добиться их отключения.

=item *

L<Constant(%s): Call to &{$^H{%s}} did not return a defined value|perldiag/Constant(%s): Call to &{$^H{%s}} did not return a defined value>

Перегрузка константы, которая возвращает C<undef> приводит к подобному сообщению
об ошибке.  Для числовых констант раньше выводилось "Constant(undef)".  "undef"
был заменён на само число.

=item *

Ошибка, которая выводится когда модуль не может быть загружен, теперь включает
подсказку какой модуль требуется к установке: "Can't locate hopping.pm in @INC
(you may need to install the hopping module) (@INC contains: ...)"

=item *

L<vector argument not supported with alpha versions|perldiag/vector argument not supported with alpha versions>

Это предупреждение не подавлялось даже при помощи C<no warnings>.  Теперь его
можно подавить и оно было перемещено из категории "internal" в категорию
"printf".

=item *

C<< Can't do {n,m} with n > m in regex; marked by <-- HERE in m/%s/ >>

Эта фатальная ошибка была превращена в предупреждение, которое читается так:

L<< Quantifier {n,m} with n > m can't match in regex | perldiag/Quantifier {n,m} with n > m can't match in regex >>

(Категория regexp) Минимальное значение должно быть меньше или равно
максимальному.  Если вы действительно хотите получить совпадение 0 раз, просто
задайте {0}.

=item *

Предупреждение о "Runaway prototype", которое возникает в редких ситуациях было
удалено из-за бесполезности и противоречивости.

=item *

Ошибка "Not a format reference" была удалена так как единственный случай, в
котором она выводилось являлось внутренней ошибкой.

=item *

Ошибка "Unable to create sub named %s" была удалена по той же причине

=item *

Ошибка 'Can't use "my %s" in sort comparison' была понижена до предупреждения
'"my %s" used in sort comparison' (со 'state' вместо 'my' для случая переменных
состояния).  В дополнении, эвристика для угадывания, какая из лексических $a или
$b были неправильно использованы, была улучшена для снижения количества ложных
срабатываний.  Лексические $a и $b больше не запрещены, если они вне блока sort.
Также именованный унарный или списочный оператор внутри блока sort больше не
приводит к игнорированию $a или $b [perl #86136].

=back

=head1 Изменения в утилитах

=head3 L<h2xs>

=over 4

=item *

F<h2xs> больше не выдаёт неправильный код для пустых определений [perl #20636]

=back

=head1 Конфигурация и компиляция

=over 4

=item *

Добавлена опция C<useversionedarchname> в Configure

Если она установлена, то в 'archname' включается значение 'api_versionstring'.
Например, x86_64-linux-5.13.6-thread-multi.  Она выключена по умолчанию.

Эта возможность была запрошена Тимом Бансом (Tim Bunce), который заметил, что
C<INSTALL_BASE> создаёт структуру библиотеки, которая не зависит от версии perl.
Вместо этого, он помещает архитектурно-зависимые файлы в
"$install_base/lib/perl5/$archname".  Это затрудняет использование общего
C<INSTALL_BASE> пути библиотеки с разными версиями perl.

Устанавливая C<-Duseversionedarchname>, $archname будет отличаться по
архитектуре I<and> по версии API, позволяя смешанное использование
C<INSTALL_BASE>.

=item *

Добавлена опция C<PERL_NO_INLINE_FUNCTIONS>.

Если определена C<PERL_NO_INLINE_FUNCTIONS>, то не включается заголовок
"inline.h".

Это позволяет создавать код, включающий perl заголовки для определений, без
создания зависимости на библиотеку perl при компановке (которая ещё может не
существовать).

=item *

Configure учитывает внешнюю переменную окружения C<MAILDOMAIN>, если она
установлена.

=item *

C<installman> больше не игнорирует опцию тишины

=item *

Оба файла C<META.yml> и C<META.json> теперь включаются в дистрибутив.

=item *

F<Configure> теперь корректно определяет C<isblank()> при сборке с помощтю
компилятора C++.

=item *

Обнаружение утилиты постраничного вывода в F<Configure> было улучшено и
позволяет указывать опции после имени программы, например, B</usr/bin/less -R>,
если пользователь принимает значение по умолчанию.  Это позволяет B<perldoc> при
обработке ANSI экранирования [perl #72156].

=back

=head1 Тестирование

=over 4

=item *

Тестовый набор теперь содержит секцию тестов, которые требуют очень большого
количества памяти.  Эти тесты не запускаются по умолчанию; они могут быть
включены установкой переменной окружения C<PERL_TEST_MEMORY> со значением
количества гибибайт памяти, которое может быть безопасно использовано.

=back

=head1 Поддержка платформ

=head2 Более неподдерживаемые платформы

=over 4

=item BeOS

BeOS была операционной системой для персональных компьютеров, разрабатываемой Be
Inc, первоначально для их аппаратной платформы BeBox.  ОС Haiku была создана как
замена с открытыми исходниками для продолжения развития BeOS и его perl порт на
данный момент активно поддерживается.

=item UTS Global

Поддерживающий код, относящийся к UTS global был удалён.  UTS являлся версией
System V для мейнфреймов, созданной Amdahl, а затем проданной UTS Global.  К
порту не притрагивались начиная с Perl v5.8.0 и UTS Global на текущий момент не
функционирует.

=item VM/ESA

Поддержка для VM/ESA была удалена.  Порт был протестирован на 2.3.0, который
перестал поддерживаться IBM с марта 2002. Для 2.4.0 завершилось обслуживание в
июне 2003 и было заменено на Z/VM.  Текущая версия Z/VM V6.2.0 и запланирована к
окончанию поддержки к 2015/04/30.

=item MPE/IX

Поддержка для MPE/IX была удалена.

=item EPOC

Поддерживающий код для EPOC был удалён.  EPOC являлся семейством операционных
систем, разрабатываемых в Psion для мобильных устройств.  Он являлся
предшественником Symbian.  Порт последний раз был обновлён в апреле 2002.

=item Rhapsody

Поддержка для Rhapsody была удалена.

=back

=head2 Платформо-специфичные замечания

=head3 AIX

Configure теперь всегда добавляет C<-qlanglvl=extc99> в CC флаги на AIX, если
используется xlC.  Это позволяет упростить сборку XS модулей, которые
предполагают C99 [perl #113778].

=head3 clang++

Теперь присутствует обходное решение для ошибки в компиляторе, которая
препятствовала сборке с использованием clang++ начиная с Perl v5.15.7
[perl #112786].

=head3 C++

При сборке ядра Perl как C++ (что лишь частично поддерживается), математические
функции компилируются как C<extern "C">, для гарантированной бинарной
совместимости.  (Однако, бинарная совместимость в общем случае не гарантируется
в любом случае в ситуациях, где бы это имело значение).

=head3 Darwin

Убрано жёстко-заданное выравнивание к 8 байтовым границам для исправления сборки
с использованием -Dusemorebits.

=head3 Haiku

Perl теперь должен работать из коробки на Haiku R1 Alpha 4.

=head3 MidnightBSD

C<libc_r> был удалён в последних версиях MidnightBSD, а поздние версии лучше
работают с C<pthread>.  Многопоточноть теперь включается с использованием
C<pthread>, что исправляет сборочные ошибки при сборке с включённой
многопоточностью на 0.4-CURRENT.

=head3 Solaris

Configure избегает запуска команды sed с флагами, которые не поддерживаются на
Solaris.

=head3 VMS

=over

=item *

Где возможно, регистр имён файлов и аргументов командной строки теперь
сохраняется за счёт включения возможностей CRTL C<DECC$EFS_CASE_PRESERVE> и
C<DECC$ARGV_PARSE_STYLE> при запуске.  Последний действует только если
расширенный разбор включён в процессе из которого запускается Perl.

=item *

Набор символов для Расширенного Файлового Синтаксиса (EFS) теперь включается по
умолчанию на VMS.  Среди прочего это даёт лучшую обработку точек в именах
директорий, нескольких точек в именах файлов и пробелах в файловых именах.
Чтобы получить старое поведение установите логическое имя C<DECC$EFS_CHARSET> в
значение C<DISABLE>.

=item *

Исправлена компоновка на сборках, сконфигурированных с C<-Dusemymalloc=y>.

=item *

Экспериментальная поддержка сборки Perl с помощью компилятора HP C++ доступна
при конфигурации с C<-Dusecxx>.

=item *

Все заголовочные файлы C из верхней директории дистрибутива теперь
устанавливаются на VMS, согласованно с устоявшейся практикой на других
платформах.  Ранее устанавливалась только часть, что ломало сборку внешних
расширений для расширений, которые зависят на потерянные заголовочные файлы.

=item *

Цитирование удалено из командных слов (но не из параметров) для команд,
вызываемых через C<system>, обратные кавычки или C<open> с перенаправлением.
Раньше кавычки на командах пропускались через DCL, который мог не узнать
команду. Также если команда это в действительности путь к образу или командной
процедуре на томе ODS-5, цитирование теперь позволяет использовать пути,
содержащие пробелы.

=item *

Сборка B<a2p> была исправлена для компилятора HP C++ на OpenVMS.

=back

=head3 Win32

=over

=item *

Perl теперь может быть собран с использованием компилятора Visual C++ 2012
Microsoft при указании CCTYPE=MSVC110 (или MSVC110FREE, если вы используете
бесплатную Express версию для десктопа Windows) в F<win32/Makefile>.


=item *

Опция для сборки без C<USE_SOCKETS_AS_HANDLES> была удалена.

=item *

Исправлена проблема, когда perl мог упасть при очистке нитей (включая главную
нить) в сборках с многопоточностью и отладочными символами на Win32 и возможно
на других платформах [perl #114496].

=item *

Редкая ситуация гонки, которая приводит к тому, что L<sleep|perlfunc/sleep>
занимает больше времени, чем запрошено и возможно даже зависает, теперь была
исправлена [perl #33096].

=item *

C<link> на Win32 теперь пытается установить C<$!> более уместное значение,
основанное на коде ошибки Win32 API [perl #112272].

Perl больше не портит блок окружения, например при запуске нового суб-процесса,
когда окружение содержит не-ASCII символы.  Однако,  известные проблемы
по-прежнему остаются, если окружение содержит символы вне текущей кодовой
таблицы ANSI (например, смотрите блок по Юникоду в C<%ENV> в
L<http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/todo.pod>).
[perl #113536]

=item *

Сборка perl некоторыми Windows компиляторами раньше завершалась ошибкой из-за
проблем с оператором C<glob> в miniperl (который использует программу
C<perlglob>), удалявший переменную окружения PATH [perl #113798].

=item *

Была добавлена новая опция для Windows makefile'ов C<USE_64_BIT_INT>.
Установите её в значение "define" при сборке 32-битного perl, если вы хотите,
чтобы он использовал 64-битные целые.

Уменьшение размера машинного кода, которое уже было выполнено для DLL XS модулей
в Perl v5.17.2, теперь было расширенно и на DLL самого perl.

Сборка с помощью VC++ 6.0 была нечаянно сломана в Perl v5.17.2, но теперь была
восстановлена.

=back

=head3 WinCE

Сборка на WinCE теперь снова стала возможна, однако больше работы требуется для
полного восстановления чистой сборки.

=head1 Внутренние изменения

=over

=item *

Были созданы синонимы для вводящего в заблуждения имени C<av_len()>:
C<av_top_index()> и C<av_tindex>.  Все три возвращают самый старший индекс в
массиве, а не число элементов, который он содержит.

=item *

SvUPGRADE() больше не является выражением.  Изначально этот макрос (и
используемая в нём функция sv_upgrade()) был задокументирован как логический,
хотя в реальности они всегда падали на ошибках и никогда не возвращали ложное
значение.  В 2005 документация была обновлена с указанием, что возвращается
пустое значение, но для обратной совместимости SvUPGRADE() всегда возвращал 1.
Теперь это было удалено и SvUPGRADE() теперь является оператором, который не
возвращает никакого значения.

Таким образом это теперь синтаксическая ошибка:

    if (!SvUPGRADE(sv)) { croak(...); }

Если у вас есть подобный код, просто замените его на

    SvUPGRADE(sv);

или для избежания предупреждения компилятора со старыми версиями perl возможно

    (void)SvUPGRADE(sv);

=item *

Perl имеет новый механизм копирование-при-записи, который позволяет любым SvPOK
скалярам быть улучшенным до скаляра копируемого-при-записи.  Число ссылок на
буфер строки сохраняется в самом буфере строки.  Эта возможность не B<включена
по умолчанию>.

Он может быть включён в сборке perl при помощи запуска F<Configure> с флагом
B<-Accflags=-DPERL_NEW_COPY_ON_WRITE>, и мы призываем XS авторов попробовать
свой код на perl, собранным подобном образом, и отправить свои отзывы. К
сожалению, пока нет хорошего руководства для обновления XS кода для работы с
COW.  Пока такой документ недоступен, обращайтесь за консультациями в почтовый
список рассылки perl5-porters.

Он ломает некоторые XS модули, позволяя скалярам копируемым-при-записи
появляться в коде, где никто раньше не ожидал их видеть.

=item *

Копирование-при-записи больше не использует флаги SvFAKE и SvREADONLY.
Следовательно SvREADONLY теперь показывает по-настоящему доступные только на
чтение SV.

Используйте SvIsCOW макрос (как и раньше) для идентификации скаляров
копируемых-при-записи.

=item *

C<PL_glob_index> исчез.

=item *

Приватный Perl_croak_no_modify лишился параметра своего контекста.  Теперь у
него пустой прототип.  Пользователи публичного API croak_no_modify остаются
незатронутыми.

=item *

Копируемый-при-записи (разделяемый ключ хэша) скаляры больше не помечаются как
доступные только для чтения. C<SvREADONLY> возвращает ложь на подобных SV, но
C<SvIsCOW> по-прежнему возвращает истину.

=item *

Появился новый тип операций C<OP_PADRANGE>.  Оптимизатор perl, где возможно,
заменит на одиночную операцию padrange операцию pushmark с последующей одной или
несколькими pad операциями, и, возможно, пропуская операции list и nextstate.  В
дополнении операция может взять задачу, связанную с RHS присвоения C<< my(...) =
@_ >>, чтобы эти операции также могли быть оптимизированы.

=item *

Регистро-независимое сравнение внутри заключённых в скобки символьных классов с
многосимвольной формой больше не исключает одну из возможностей в случаях, когда
оно используется именно для этого [perl #89774].

=item *

C<PL_formfeed> был удалён.

=item *

Движок регулярных выражений больше не читает один байт после конца целевой
строки.  Для всех внутренне корректно сформированных скаляров это никогда не
было проблемой, это изменение упрощает применение хитрых трюков с буферами строк
в CPAN модулях [perl #73542].

=item *

Внутри блока BEGIN, C<PL_compcv> теперь указывает на компилируемую в данный
момент подпрограмму, а не на сам блок BEGIN.

=item *

C<mg_length> устарела.

=item *

C<sv_len> теперь всегда возвращает число байт, а C<sv_len_utf8> число символов.
Ранее C<sv_len> и C<sv_len_utf8> оба были сломанными и иногда возвращали число
байт, а иногда число символов.  C<sv_len_utf8> больше не считает, что её
аргумент в кодировке UTF-8.  Никто из них больше не создаёт UTF-8 кэши для
связанных или перегруженных значений или для не-PV.

=item *

C<sv_mortalcopy> теперь копирует строковые буферы скаляров разделяемых ключей
хэша, когда вызывается из XS модулей [perl #79824].

=item *

C<RXf_SPLIT> и C<RXf_SKIPWHITE> больше не используются. Сейчас они определены
как 0.

=item *

Новый флаг C<RXf_MODIFIES_VARS> может быть установлен в произвольном движке
регулярных выражений для указания, что запуск регулярного выражения может
привести у изменению переменных.  Это позволяет C<s///> знать, когда нужно
пропускать определённые оптимизации.  Собственный движок регулярных выражений
устанавливает этот флаг для специальных команд прохода с возвратом, которые
устанавливают $REGMARK и $REGERROR.

=item *

API для доступа к лексическим pad'ам было существенно изменено.

C<PADLIST> больше не является C<AV>, а имеет свой собственный тип. C<PADLIST>
теперь содержит C<PAD> и C<PADNAMELIST> состоит из C<PADNAME>, а не C<AV> для
pad и списка pad имён.  C<PAD>, C<PADNAMELIST> и C<PADNAME> доступны
соответственно через появившееся новое pad API, вместо прямого C<AV> и C<SV>
API. Смотрите L<perlapi> для подробностей.

=item *

В API регулярных выражений функции-колбэки пронумерованных захватов передают
индекс, указывающий к какой переменной осуществлён доступ.  Существуют
специальные индексные значения для переменных C<$`, $&, $&>.  Раньше такие же
три значения использовались также для получения C<${^PREMATCH}, ${^MATCH},
${^POSTMATCH}>, но они теперь получили три отдельных значения.  Смотрите
L<perlreapi/Numbered capture callbacks>.

=item *

C<PL_sawampersand> раньше был логическим значением, которое указывало, что любые
из C<$`, $&, $&> были видимы; теперь он содержит три однобитных флага,
указывающих на наличие любой из переменных индивидуально.

=item *

C<CV *> typemap теперь поддерживает C<&{}> перегрузку и typeglob'ы, также как и
C<&{...}> [perl #96872].

=item *

Флаг C<SVf_AMAGIC>, указывающий на перегрузку теперь в стэше, а не в объекте.
Теперь он устанавливается автоматически при изменении метода или @ISA, так что
его смысл теперь изменился также.  Теперь он означает "потенциально перегружен".
Когда рассчитывается таблица перегрузок, флаг автоматически выключается, если
отсутствует перегрузка, поэтому заметного замедления нет.

Устаревание таблицы перегрузок теперь проверяется, когда вызывается
перегруженный метод, а не во время C<bless>.

Магический "A" исчез.  Изменения в обработке флага C<SVf_AMAGIC> устранили
необходимость в нём.

C<PL_amagic_generation> был удалён и больше не нужен.  Для XS модулей это теперь
макрос псевдоним к C<PL_na>.

Установка откат перегрузки теперь сохраняется в записи стэша отдельно от самой
перегруженности.

=item *

Код обработки символов был местами подчищен.  Изменения должны быть невидимы на
практике.

=item *

Функция C<study> была сделана бездейственной в v5.16.  Она была попросту
выключена вставкой оператора C<return>; код же оставался на месте.  Теперь
поддерживающий код, который использовался в C<study> полностью был удалён.

=item *

В perl с поддержкой нитей больше нет отдельного PV выделенного для каждого COP
для хранения его имени пакета (C<< cop->stashpv >>).  Вместо этого есть смещение
(C<< cop->stashoff >>) в новый массив C<PL_stashpad>, который хранит указатели
стэша.

=item *

В расширяемом API регулярных выражений структура C<regexp_engine> получила новое
поле C<op_comp>, которое в данный момент используется только для внутренних
целей perl и должно быть инициализировано в NULL другими модулями расширения
регулярных выражений.

=item *

Новая функция C<alloccopstash> была добавлена в API, но она рассматривается как
экспериментальная.  Смотрите L<perlapi>.

=item *

Раньше в Perl было реализовано получение магии способом иногда скрывавшим ошибки
в коде, который мог вызывать mg_get() слишком много раз на магические значения.
Такого сокрытия ошибок больше не происходит, так что давние ошибки теперь могут
стать заметными.  Если вы видите относящиеся к магии ошибки в XS-коде,
проверьте, чтобы быть уверенными, вместе с другими Perl API функциями, которые
его используют, что вызовы mg_get() происходят только один раз на SvGMAGICAL()
значения.

=item *

Выделение OP для CV теперь использует slab выделение.  Это упрощает управление
памятью для OP выделенных для CV, поэтому очистка после ошибок компиляции проще
и более безопасна [perl #111462][perl #112312].

=item *

C<PERL_DEBUG_READONLY_OPS> был переписан для работы с новым slab
распределителем, позволяя захватывать больше нарушений, чем раньше.

=item *

Старый slab распределитель для OP, который только включался для
C<PERL_IMPLICIT_SYS> и C<PERL_DEBUG_READONLY_OPS> был удалён.

=back

=head1 Выборочные исправления ошибок

=over 4

=item *

Ограничители встроенной документации больше не требуют звершающего символа новой
строки, если находятся в конце файла. Это уже было так в конце строки,
выполняемой через eval [perl #65838].

=item *

Сборка с C<-DPERL_GLOBAL_STRUCT> теперь освобождает глобальную структуру
B<после> того, как закончит использовать её.

=item *

Завершающий '/' в путях в @INC больше не дополняется ещё одним '/'.

=item *

Слой C<:crlf> теперь работает, когда возвращаемые данные не вмещаются в свой
собственный буфер [perl #112244].

=item *

C<ungetc()> теперь поддерживает данные, кодированные в UTF-8 [perl #116322].

=item *

Ошибка в базовых typemap привела к тому, что любые C типы, которые соответствуют
базовому T_BOOL typemap элементу не устанавливаются, не обновляются и не
модифицируются, когда T_BOOL переменная используется в OUTPUT: секции с
исключением для RETVAL.  T_BOOL в INPUT: секции не затронут.  Использование
возвращаемого типа T_BOOL в XSUB (RETVAL) не было затронуто.  Побочным эффектом
исправления этой ошибки стало то, что если T_BOOL указан в секции OUTPUT: (что
раньше ничего не меняло для SV) и передаётся доступный только для чтения SV
(литерал) в XSUB, происходит ошибка вида Modification of a read-only value
attempted" [perl #115796].

=item *

На многих платформах указание имени директории как имени скрипта приводило к
тому, что perl ни делал ничего и сообщал об успешном запуске.  Сейчас он всегда
должен сообщать об ошибке и завершаться с ненулевым кодом возврата
[perl #61362].

=item *

C<sort {undef} ...> при действии фатальных предупреждений больше не падает. Он
начал падать в Perl v5.16.

=item *

Стэши благословлённые друг в другу (C<bless \%Foo::, 'Bar'; bless \%Bar::,
'Foo'>) больше не приводят к двойному освобождению.  Эта проблема стала
возникать в Perl v5.16.

=item *

Несколько утечек памяти было исправлено, большая часть затрагивает фатальные
предупреждения и синтаксические ошибки.

=item *

Некоторые несовпавшие регулярные выражения, такие как C<'f' =~ /../g> не
сбрасывали C<pos>.  Кроме того "совпавшие-лишь-раз" шаблоны (C<m?...?g>) не
сбрасывали его также, когда вызывались второй раз [perl #23180].

=item *

Несколько ошибок, включающие C<local *ISA> и C<local *Foo::>, приводившие к
устареванию MRO кэшей, были исправлены.

=item *

Определение подпрограммы, когда для её typeglob был задан псевдоним больше не
приводит к устареванию кэшей методов.  Эта ошибка появилась в Perl v5.10.

=item *

Локализация typeglob'а, содержащего подпрограмму, когда пакет typeglob'а был
удалён из своего родительского стэша больше не приводит к ошибке.  Эта ошибка
появилась в Perl v5.14.

=item *

В некоторых ситуациях C<local *method=...> мог не сбросить кэши методов при
выходе из области видимости.

=item *

C</[.foo.]/> больше не является ошибкой, но выводит предупреждение (как и
раньше) и рассматривается как C</[.fo]/> [perl #115818].

=item *

C<goto $tied_var> теперь вызывает FETCH перед тем как решит какого типа этот
goto (подпрограмма или метка).

=item *

Переименование пакетов через присвоение glob
(C<*Foo:: = *Bar::; *Bar:: = *Baz::>) в комбинации с C<m?...?> и C<reset> больше
не приводит к падению сборки с поддержкой нитей.

=item *

Некоторое число ошибок, относящиеся к присвоению списка хэшу было исправлено.
Многие их них включают списки из повторяющихся ключей вида C<(1, 1, 1, 1)>.

=over 4

=item *

Выражение C<scalar(%h = (1, 1, 1, 1))> теперь возвращает C<4>, а не C<2>.

=item *

Возвращаемое значение C<%h = (1, 1, 1)> в списочном контексте было неправильным.
Раньше возвращало C<(1, undef, 1)>, теперь возвращает C<(1, undef)>.

=item *

Теперь Perl выдаёт такое же предупреждение для C<($s, %h) = (1, {})>, какое он
выдаёт для C<(%h) = ({})>, "Reference found where even-sized list expected"
("Найдена ссылка там, где ожидался список с чётным числом элементов").

=item *

Несколько дополнительных краевых случаев в присвоении списков хэшу было
исправлено.  Для дополнительных деталей смотрите коммит 23b7025ebc.

=back

=item *

С атрибутами, присвоенными лексическим переменным, больше не утекает память
[perl #114764].

=item *

C<dump>, C<goto>, C<last>, C<next>, C<redo> или C<require> с последующим
тривиальным словом (bareword) или версией и далее идущим инфиксным оператором
больше не является синтаксической ошибкой.  Раньше так было для некоторых
инфиксных операторов (вроде C<+>), которые имеют другое понимание где ожидается
элемент [perl #105924].

=item *

C<require a::b . 1> и C<require a::b + 1> больше не выдаёт ошибочное
предупреждение об двусмысленности [perl #107002].

=item *

Вызов метода класса теперь разрешается для любой строки, а не только строки,
начинающейся с буквенно-цифрового символа [perl #105922].

=item *

Пустой шаблон созданный с помощью C<qr//>, используемый в C<m///> больше не
вызывает поведения "пустой шаблон повторно использует последний шаблон"
[perl #96230].

=item *

Связывая хэш во время итерации больше не приводит к утечкам памяти.

=item *

Освобождение связанного хэша во время итерации больше не приводит к утечкам
памяти.

=item *

Присвоение списка связанному массиву или хэшу, который умирает при операции
STORE, больше не приводит к утечке памяти.

=item *

Если хинт-хэш (C<%^H>) является связанным, элемент области видимости во время
компиляции (который копирует хинт-хэш) больше не теряет память если умирает
вызов FETCH [perl #107000].

=item *

Вычисление констант больше не вызывает неуместное специальное поведение
C<split " "> [perl #94490].

=item *

C<defined scalar(@array)>, C<defined do { &foo }> и схожие конструкции теперь
рассматривают аргумент к C<defined> как простой скаляр [perl #97466].

=item *

Запуск отладчика, который не определяет глоб C<*DB::DB> или не предоставляет
подпрограмму заглушку для C<&DB::DB> больше не приводит к краху, а выдаёт
сообщение об ошибке [perl #114990].

=item *

C<reset ""> теперь соответствует своей документации. C<reset> сбрасывает только
шаблон C<m?...?> при запуске без аргумента.  Пустая строка в аргументе теперь ни
делает ничего. (Раньше это рассматривалось как отсутствие аргумента)
[perl #97958].

=item *

C<printf> с аргументом, возвращающий пустой список больше не читает дальше конца
стека, приводившего к ошибочному поведению [perl #77094].

=item *

C<--subname> больше не выдаёт ошибочных неясных предупреждений [perl #77240].

=item *

C<v10> теперь доступна как метка или имя пакета.  Это было нечаянно сломано,
когда v-строки были добавлены в Perl v5.6 [perl #56880].

=item *

C<length>, C<pos>, C<substr> и C<sprintf> могут быть сбиты с толку связываниями,
ссылками и typeglob'ами если привидение их к строковому виду меняет внутреннее
представление в или из UTF-8 [perl #114410].

=item *

utf8::encode теперь вызывает FETCH и STORE на связанных переменных.
utf8::decode теперь вызывает STORE (FETCH уже был вызван).

=item *

C<$tied =~ s/$non_utf8/$utf8/> больше не зацикливается в бесконечный цикл, если
связанная переменная возвращает Latin-1 строку, разделяемый скаляр ключа хэша,
или ссылку, или typeglob, который приводится к строковому виду как ASCII или
Latin-1.  Это была регрессия, начиная с v5.12.

=item *

C<s///> без /e теперь лучше определяет когда необходимо отказаться от
определённых оптимизаций, исправляя некоторые ошибочные ситуации:

=over

=item *

Совпадение с переменными в определённых конструкциях  (C<&&>, C<||>, C<..> и
другие) в части замены; например, C<s/(.)/$l{$a||$1}/g>.  [perl #26986]

=item *

Псевдонимы при поиске соответствия переменным в части замещения.

=item *

C<$REGERROR> или C<$REGMARK> в замещении [perl #49190].

=item *

Пустой шаблон (C<s//$foo/>), который приводит к тому, что используется последний
успешно совпавший шаблон, в случае если шаблон содержит кодовый блок, который
изменяет переменные в замещении.

=back

=item *

Заражённость замещаемой строки больше не влияет на заражённость возвращаемого
значения C<s///e>.

=item *

Переменная автоматического сброса буферов C<$|> создаётся на лету при
необходимости.  Если это происходило (например, если она была упомянута в модуле
или в eval) когда текущий выбранный файловый дескриптор был typeglob с пустым IO
слотом, раньше это приводило к краху [perl #115206].

=item *

Номера строк в конце eval строки больше не удлиняются на единицу [perl #114658].

=item *

Фильтры @INC (подпрограммы возвращаемые подпрограммами в @INC), которые
устанавливают $_ в копируемый-при-записи скаляр, больше не заставляют парсер
модифицировать этот строковой буфер на месте.

=item *

C<length($object)> больше не возвращает неопределённое значение, если объект
имеет перегрузку строки, которая возвращает undef [perl #115260].

=item *

Было восстановлено использование C<PL_stashcache>, кэша стэша используемого для
поиска имён для вызова методов.

Коммит da6b625f78f5f133 в августе 2011 нечаянно сломал код, который получал
значения в C<PL_stashcache>.  Так как это только кэш, всё корректно работало и
без него.

=item *

Ошибка "Can't localize through a reference" ("Не могу локализовать через
ссылку") исчезла в v5.16.0, когда C<local %$ref> появлялось на последней строке
lvalue подпрограммы.  Эта ошибка исчезла для C<\local %$ref> в perl v5.8.1.
Сейчас она была восстановлена,

=item *

Разбор встроенной документации был существенно улучшен, исправляя несколько
ошибок разбора, падений и одной утечки памяти, а также корректируя неверную
последовательность номеров строк при определённых условиях.

=item *

Внутри eval сообщение об ошибке для нетерминированных встроенных документах
больше не имеет переноса строка в середине [perl #70836].

=item *

Замещение внутри замещающего шаблона (C<s/${s|||}//>) больше не смущает парсер.

=item *

Возможно не очень правильное место для разрешения комментариев, но
C<s//"" # hello/e> всегда работало, I<только> если не было null символа перед
первым #.  Теперь это работает даже при наличии null.

=item *

Неправильный диапазон в C<tr///> или C<y///> больше не приводит к утечке памяти.

=item *

Строковой eval больше не рассматривает оператор цитирования с точкой запятой в
качестве ограничителя в конце строки (C<eval 'q;;'>) как синтаксическую ошибку.

=item *

C<< warn {$_ => 1} + 1 >> больше не является синтаксической ошибкой.  Раньше
парсер сбивался при определённых списочных операторах с последующим анонимным
хэшем и далее идущим инфиксным оператором, который разделяет свою форму с
унарным оператором.

=item *

C<(caller $n)[6]> (который возвращает текст из eval) раньше возвращал актуальный
буфер парсера.  Изменение которого могло привести к краху.  Теперь он всегда
возвращает копию.  Возвращаемая строка больше не содержит "\n;" прикреплённый к
концу.  Возвращаемый текст также включает встроенную документацию, которая
раньше пропускалась.

=item *

Кэш позиции UTF-8 теперь сбрасывается, при доступе к магическим переменным для
избежания рассинхронизации строкового буфера и кэша позиции UTF-8
[perl #114410].

=item *

Были исправлены различные случаи двухкратного получения магии для магических
UTF-8 строк.

=item *

Этот код (когда отсутствует C<$&>)

    $_ = 'x' x 1_000_000;
    1 while /(.)/;

раньше пропускал копирование буфера по причине производительности, но страдал
этим при изменении C<$1>, если оригинальная строка менялась.  Теперь это было
исправлено.

=item *

Perl теперь больше не использует PerlIO для сообщения об отсутствии памяти, так
как PerlIO может попытаться выделить ещё памяти.

=item *

В регулярных выражениях, если что-либо подсчитывается с помощью C<{n,m}>, где
C<S<n E<gt> m>>, не может привести к совпадению.  Раньше это приводило к
фатальной ошибке, но сейчас это просто предупреждение (что нечто не сможет
совпасть) [perl #82954].

=item *

Раньше была возможность для форматов, определённых в подпрограммах, которые
затем становились неопределёнными и снова определялись, закрываться в переменных в
неправильном pad (вновь определённая окружающая подпрограмма), что приводило к
краху или ошибкам "Странная копия".

=item *

Переопределение XSUB во время работы могло выводить предупреждение с
неправильным номером строки.

=item *

Формат %vd sprintf не поддерживает объект версии для альфа версий.  Раньше он
выводил сам формат (%vd), когда принимал альфа версию и также выдавал
предупреждение "Invalid conversion in printf" ("Неверный перевод в printf").
Больше этого не происходит, но выдаёт пустую строку на выходе.  Также он больше
не теряет память в этом случае.

=item *

Вызов C<< $obj->SUPER::method >> в главном пакет может не удаться если SUPER
пакет уже был вызван другими средствами.

=item *

Создание псевдонима стэша (C<< *foo:: = *bar:: >>) больше не приводит к тому,
что вызов SUPER игнорирует изменения в методах, или @ISA, или в использует
неверный пакет.

=item *

Вызов метода в пакетах, имена которых заканчиваются на ::SUPER больше не
рассматриваются как вызов метода SUPER, что приводило к ошибкам поиска метода.
Кроме того, определение подпрограмм в подобных пакетах больше не приводит к их
поиску вызовом метода SUPER на содержащий их пакета [perl #114924].

=item *

C<\w> теперь совпадает с кодами U+200C (ZERO WIDTH NON-JOINER) и U+200D (ZERO
WIDTH JOINER).  C<\W> больше не совпадает с ними.  Это изменение связано с
коррекцией в определении Юникода, с чем должен совпадать C<\w>.

=item *

C<dump LABEL> больше не приводит к утечке этой метки.

=item *

Вычисление констант больше не меняет поведение функций C<stat()> и
C<truncate()>, которые могут работать как с именами файлов, так из дескрипторами
файлов.  C<stat 1 ? foo : bar> теперь рассматривает свой аргумент как имя файла
(так как это произвольное выражение), а не как дескриптор "foo".

=item *

C<truncate FOO, $len> больше не откатывается к рассмотрению "FOO" как имя файла,
если файловый дескриптор был удалён.  Это было сломано в Perl v5.16.0.

=item *

Переопределение подпрограммы после присвоения подпрограммы в глоб и глоб в глоб
больше не приводит к двойному освобождению памяти или паническим сообщениям.

=item *

C<s///> теперь превращает v-строки в обычные строки, когда делает подстановку,
даже если результирующая строка та же самая (C<s/a/a/>).

=item *

Предупреждение об несовпадающем прототипе больше не рассматривает подпрограммы
константы как не имеющие прототипа, тогда как они на самом деле имеют "".

=item *

Подпрограммы константы и упреждающая декларация больше не препятствует
предупреждениям об несовпадающем прототипе опускать имя подпрограммы.

=item *

C<undef> на подпрограмму теперь очищает проверку вызова.

=item *

Оператор C<ref> стал терять память на благословенных объектах в Perl v5.16.0.
Это было исправлено [perl #114340].

=item *

C<use> больше не пытается разбирать свои аргументы как оператор, делая
C<use constant { () };> синтаксической ошибкой [perl #114222].

=item *

В сборках с отладочными символами, предупреждения "неинициализированности"
внутри форматов больше не приводят к ошибкам утверждения.

=item *

В сборках с отладочными символами, подпрограммы вложенные внутри форматов больше
не приводят к ошибкам утверждения [perl #78550].

=item * 

Форматы и операторы C<use> теперь разрешены внутри форматов.

=item *

C<print $x> и C<sub { print $x }-E<gt>()>  теперь всегда выдают одинаковый
вывод.  Для последнего было возможен отказ в замыкании $x, если переменная была
неактивна; т.е. если она была определена вне текущей запущенной именованной
подпрограммы.

=item *

Точно также C<print $x> и C<print eval '$x'> теперь выводят одинаковый вывод.
Это также позволяет видеть "my $x if 0" переменные в отладчике [perl
#114018].

=item *

Форматы, вызываемые рекурсивно, не затрагивают своих лексических переменных, а
каждый рекурсивный вызов имеет свой собственный набор лексических переменных.

=item *

Попытка освободить текущий формат или дескриптор, связанный с ним, больше не
приводит к краху.

=item *

Разбор формата больше не сбивается на фигурных скобках, точках с запятой и
низко-приоритетных операторах.  Раньше было возможно использовать скобки как
разделители формата (вместо C<=> и C<.>), но только иногда.  Точка с запятой и
низко-приоритетные операторы в аргументах строк формата больше не заставляют
парсер игнорировать возвращаемое значение строки.  В строках аргумента формата
фигурные скобки могут быть использованы для анонимных хэшей, вместо того, чтобы
всегда восприниматься как C<do> блоки.

=item *

Форматы могут быть теперь вложенными внутри кодовых блоков регулярных выражений
и других цитирующих конструкций (C</(?{...})/> и C<qq/${...}/>) [perl #114040].

=item *

Форматы больше не создаются после ошибок компиляции.

=item *

В сборках с отладочными символами, опция командной строки B<-DA> приводила к
краху Perl, начиная с v5.16.0.  Это было исправлено [perl #114368].

=item *

Потенциальный сценарий взаимной блокировки, включающий преждевременное
уничтожение дочернего процесса, запущенного через псевдо-fork в сборках на
Windows с поддержкой нитей, был исправлен.  Это решает общую проблему зависания
теста F<t/op/fork.t> на Windows [perl #88840].

=item *

Код, который генерирует ошибки от C<require()> потенциально мог читать один или
два байта до старта имени файла для файловых имён длиной менее трёх байт и
завершающихся на C</\.p?\z/>.  Теперь это было исправлено.  Обратите внимание,
что это в любом случае никогда не происходило с именами модулей, переданных в
C<use()> или C<require()>.

=item *

Обработка путей модулей, переданных в C<require()> стала безопасна в
многопоточных приложениях на VMS.

=item *

Неблокирующиеся сокеты исправлены на VMS.

=item *

Документация POD теперь может находиться внутри кода, расположенного в
цитированной конструкции вне строки eval.  Это работает только внутри eval строк
[perl #114040].

=item *

C<goto ''> теперь проверяет на пустые метки, выдавая сообщение об ошибке "goto
must have label" ("goto должен иметь метку"), вместо выхода из программы
[perl #111794].

=item *

C<goto "\0"> теперь умирает с сообщением "Can't find label" ("Не могу найти
метку"), вместо "goto must have label" ("goto должен иметь метку").

=item *

C функция C<hv_store> раньше приводила к краху, когда использовалась на C<%^H>
[perl #111000].

=item *

Проверяющий код вызова, привязанный к прототипу замыкания через
C<cv_set_call_checker> теперь копируется в замыкание, склонированное из него.
Таким образом, C<cv_set_call_checker> теперь работает внутри обработчика
атрибута замыкания.

=item *

Запись в C<$^N> раньше не имела никакого эффекта.  Теперь по умолчанию
происходит ошибка "Modification of a read-only value" ("Изменение значения
доступного только для чтения"), но это может быть переопределено в специальном
движке регулярных выражений, как и с C<$1> [perl #112184].

=item *

C<undef> на глоб управляющего символа (C<undef *^H>) больше не выдаёт ошибочного
предупреждения о неопределённости [perl #112456].

=item *

Ради эффективности многие операторы и встроенные функции возвращают один и тот
же скаляр каждый раз.  Lvalue подпрограммы и подпрограммы в пространстве имён
CORE:: в подобной детали реализации допускали сквозную утечку.  Подобное
происходило с lvalue подпрограммами, возвращающими значение C<uc>.  Теперь
значение копируется в подобных ситуациях.

=item *

C<method {}> синтаксис с пустым блоком или блоком, возвращающим пустой список
раньше приводил к краху или использовал случайное значение в стэке вызывавшего.
Теперь он выдаёт ошибку.

=item *

C<vec> теперь работает с экстремальными отступами (E<gt>2 GB) [perl #111730].

=item *

Изменения для перегрузки настроек теперь начинают действовать немедленно, как
и начинают действовать изменения в наследовании, которые затрагивают перегрузку.
Раньше они начинали действовать только после C<bless>.

Объекты, которые были созданы до того как класс имел какую-либо перегрузку,
оставались раньше неперегруженными  даже если классы получали перегрузку через C<use
overload> или изменение в @ISA, и даже после C<bless>.  Это было исправлено 
[perl #112708].

=item *

Классы с перегрузкой могут теперь наследовать значения отката.

=item *

Перегрузка не учитывала значение отката 0, если перегруженные объекты были на
обоих сторонах оператора присвоения, как например C<+=> [perl #111856].

=item *

C<pos> теперь завершается с ошибкой с хэшем или массивом в качестве аргумента,
вместо вывода ошибочного предупреждения.

=item *

C<while(each %h)> теперь подразумевает C<while(defined($_ = each %h))>, как
C<readline> и C<readdir>.

=item *

Подпрограммы в пространстве имён CORE:: больше не падают после C<undef *_>,
когда вызываются без списка аргументов (C<&CORE::time> без скобок).

=item *

C<unpack> больше не выдаёт ошибку "'/' must follow a numeric type in unpack"
("'/' должен следовать за числовым типом в unpack"), когда причина в данных,
которые некорректны [perl #60204].

=item *

C<join> и C<"@array"> теперь вызывают FETCH только однажды при связанном C<$">
[perl #8931].

=item *

Некоторые вызовы подпрограмм сгенерированные компиляцией базовых операций
затронутые переопределением C<CORE::GLOBAL> делают проверку операций дважды.
Проверка всегда неизменна для чистого Perl кода, но двойная проверка может иметь
значение, когда затронуты определённые пользователем проверки вызовов.

=item *

Условие гонки присутствовало раньше в fork, которое могло привести к отправке
сигнала в родитель и обработано и в родителе и в дочернем процессе.  Сигналы
теперь кратковременно блокируются вокруг fork, чтобы предотвратить это
[perl #82580].

=item *

Реализация блоков кода в регулярных выражениях, таких как C<(?{})> и C<(??{})>,
была сильно переработана для удаления целого болота ошибок.  Основные заметные
пользователю изменения:

=over 4

=item *

Блоки кода внутри шаблонов теперь разбираются в тот же проход, что и окружающий
код; особо надо отметить, что больше не требуется балансировать скобки - теперь
это работает:

    /(?{  $x='{'  })/

Это означает, что это сообщение об ошибке больше не выводится:

    Sequence (?{...}) not terminated or not {}-balanced in regex
    (Последовательность (?{...}) нетерминированна или несбалансированы {} в
    регулярном выражении)

но можно увидеть новую ошибку:

    Sequence (?{...}) not terminated with ')'
    (Последовательность (?{...}) нетерминированна символом ')' )

Также литеральные блоки кода внутри шаблонов во время выполнения компилируются
только один раз при компиляции perl-кода:

    for my $p (...) {
        # этот блок кода 'FOO' компилируется только один раз,
        # в то же время, что и окружающий цикл 'for'
        /$p{(?{FOO;})/;
    }

=item *

Лексические переменные теперь нормальные в плане поведения в области видимости, рекурсии
и замыканиях.  В частности, C</A(?{B})C/> ведёт себя (с точки зрения
замыкания) в точности как C</A/ && do { B } && /C/>, в то время как
C<qr/A(?{B})C/> такой же как C<sub {/A/ && do { B } && /C/}>.  Таким образом,
данный код работает так как вы ожидаете, создавая три регулярных выражения,
которые совпадают с 0, 1 и 2:

    for my $i (0..2) {
        push @r, qr/^(??{$i})$/;
    }
    "1" =~ $r[1]; # совпадает

=item *

Прагма C<use re 'eval'> теперь требуется только для блоков кода, определённых во
время исполнения; в частности в следующем, текст шаблона C<$r> по прежнему
интерпретируется в новом шаблоне и перекомпилируется, но индивидуальные
скомпилированные блоки кода внутри C<$r> используются повторно, вместо повторной
компиляции и C<use re 'eval'> больше не требуется:

    my $r = qr/abc(?{....})def/;
    /xyz$r/;

=item *

Операторы управления хода выполнения кода больше не приводят к краху.  Каждый блок кода
запускается в новой динамической области видимости, поэтому C<next> и т.д. не
видят любой внешний цикл.  C<return> возвращает значение из блока кода, а не
окружающей подпрограммы.

=item *

Perl обычно кэширует компиляцию шаблонов времени выполнения и не
перекомпилирует, если шаблон не меняется, но это теперь отключается, если
это требуется для корректного поведения в замыканиях.  Например:

    my $code = '(??{$x})';
    for my $x (1..3) {
	# перекомпиляция, чтобы видеть свежее значение $x каждый раз
        $x =~ /$code/;
    }

=item *

C</msix> и C<(?msix)> и прочие флаги теперь применяются в возвращаемое значение
из C<(??{})>; теперь это работает:

    "AB" =~ /a(??{'b'})/i;

=item *

Предупреждения и ошибки будут появляться из окружающего кода (или, для блоков
кода времени выполнения, из eval), а не из C<re_eval>:

    use re 'eval'; $c = '(?{ warn "foo" })'; /$c/;
    /(?{ warn "foo" })/;

раньше выдавало:

    foo at (re_eval 1) line 1.
    foo at (re_eval 2) line 1.

а теперь выдаёт:

    foo at (eval 1) line 1.
    foo at /some/prog line 2.

=back

=item *

Perl теперь может быть собран с использованием любой версии Юникода.  В v5.16,
это работало для Юникода 6.0 и 6.1, но существовали различные ошибки, если
использовались более ранние выпуски; и чем старше выпуск тем больше было
проблем.

=item *

C<vec> больше не выводит предупреждений об "неинициализированности" в lvalue
контексте [perl #9423].

=item *

Оптимизация, включающая фиксированные строки в регулярных выражениях, могла
вызывать некоторое ухудшение производительности в краевых условиях.  Это было
исправлено [perl #76546].

=item *

В некоторых случаях, включение пустых субшаблонов внутри регулярного выражения
(такие как C<(?:)> или C<(?:|)> могут отключить определённые оптимизации.  Это
было исправлено.

=item *

Сообщение "Can't find an opnumber" ("Не могу найти номер операции"), которое
выдаёт C<prototype>, когда передана строка вида "CORE::nonexistent_keyword",
теперь пропускает UTF-8 и встроенные NUL без изменений [perl #97478].

=item *

C<prototype> теперь обрабатывает магические переменные такие как C<$1> также, как и
немагические переменные, при проверке префикса CORE::, а не рассматривает их как
имена подпрограмм.

=item *

В сборках perl с поддержкой нитей, блок кода, исполняющийся в регулярном
выражении, мог портить имя пакета, сохранённое в дереве операций, приводя к
ошибочному чтению в C<caller> и возможно к краху [perl #113060]. 

=item *

Ссылка на прототип замыкания (C<\&{$_[1]}> в обработчике атрибута для замыкания)
больше не приводит к копированию подпрограммы (или ошибкам утверждения на
сборках с отладочной информацией).

=item *

C<eval '__PACKAGE__'> теперь возвращает правильный ответ на сборках с поддержкой
нитей, если текущий пакет был переименован (как в C<*ThisPackage:: =
*ThatPackage::>) [perl #78742].

=item *

Если пакет удалён кодом, который он вызвал, возможно, что C<caller> увидит
стековый фрейм, принадлежащий удалённому пакету.  C<caller> может упасть, если
адрес памяти стэша стала использоваться скаляром, а замена происходила в том же
скаляре [perl #113486].

=item *

C<UNIVERSAL::can> больше не рассматривает свой первый аргумент по-разному, в
зависимости строка или номер он внутренне.

=item *

C<open> с C<< <& >> используется для проверки режима, является ли третий
аргумент числом, чтобы решить, рассматривать ли его как файловый дескриптор или
как имя дескриптора.  Магические переменные, такие как C<$1>, всегда проваливали
проверку на число и рассматривались как имена дескрипторов.

=item *

Обработка в C<warn> магических переменных (C<$1>, связывания) претерпела
несколько исправлений. C<FETCH> вызывается только один раз сейчас для связанного
аргумента или связанной C<$@> [perl #97480].  Связанные переменные, возвращающие
объекты, которые имеют строковое представление "", больше не игнорируются.
Связанная C<$@>, которая возвращала ссылку при предыдущем использовании, больше
не игнорируется.

=item *

C<warn ""> теперь рассматривает C<$@> с числом внутри также, независимо от того
как оно задано C<$@=3> или C<$@="3">.  Раньше игнорировался первый вариант.
Теперь он добавляет "\t...caught", как это всегда было с C<$@="3">.

=item *

Числовые операторы на магических переменных (например, S<C<$1 + 1>>) раньше
использовали операции с плавающей запятой, даже если целочисленные операции были
более подходящими, приводя к потери точности на 64-битных платформах [perl
#109542].

=item *

Унарное отрицание больше не рассматривает строку как число, если строка
используется как число в определённый момент.  Поэтому, если C<$x> содержит
строку "dogs", то C<-$x> вернёт "-dogs", даже если будет записано как
C<$y=0+$x>.

=item *

В Perl v5.14, C<-'-10'> было исправлено возвращать "10", а не "+10".  Но
магические переменные (C<$1>, связанные) не были исправлены до текущего момента
[perl #57706].

=item *

Унарное отрицание теперь рассматривает строки согласованно, независимо от
внутреннего флага C<UTF8>.

=item *

Была исправлена регрессия, появившаяся в Perl v5.16.0, затрагивающая
C<tr/I<СПИСОКПОИСКА>/I<СПИСОКЗАМЕНЫ>/>.  Только первый экземпляр имел смысл,
если символ появлялся более одного раза в C<I<СПИСОКПОИСКА>>.  В некоторых
случаях, последний экземпляр переопределял все предыдущие [perl #113584].

=item *

Регулярные выражения, такие как C<qr/\87/>, раньше молча вставляли NUL символ,
так как если бы оно было записано как C<qr/\00087/>.  Теперь оно будет
выполнять поиск, как если бы было записано как C<qr/87/>, с сообщением о том,
что последовательность C<"\8"> не распознаётся.

=item *

C<__SUB__> теперь работает в специальных блоках (C<BEGIN>, C<END> и т.д.).

=item *

Создание нитей на Windows могло теоретически приводить к краху, если выполнялось
внутри блока C<BEGIN>.  Оно по прежнему не работает правильно, но по крайне мере
не падает [perl #111610].

=item *

C<\&{''}> (с пустой строкой) теперь автоматически создаёт заглушку, как и для
любого другого имени подпрограммы, и больше не выводит ошибку "Unable to create
sub" ("Не могу создать подпрограмму") [perl #94476].

=item *

В v5.14.0 появилась регрессия, которая была сейчас исправлена, в которой
некоторые вызовы модуля C<re> приводили к порче содержимого C<$_> [perl
#113750].

=item *

C<do FILE> теперь всегда устанавливает или очищает C<$@>, даже если файл не
может быть прочтён.  Это гарантирует, что первоначальное тестирование C<$@> (как
и рекомендуется в документации) всегда возвращает корректные результаты.

=item *

Итерация по массиву, используемая для конструкции C<each @array> теперь
корректно сбрасывается, когда C<@array> очищается [perl #75596].  Это
происходит, например, когда массив глобально присваивается, как в C<@array =
(...)>, а не когда его B<значениям> происходит присваивание.  В определениях XS
API это означает, что C<av_clear()> теперь сбрасывает итератор.

Это копирует поведение итератора хэша, когда хэш очищается.

=item *

C<< $class->can >>, C<< $class->isa >> и C<< $class->DOES >> теперь возвращают
корректные результаты, независимо от того, существует ли пакет, на который
ссылается C<$class> [perl #47113].

=item *

Приходящие сигналы больше не очищают C<$@> [perl #45173].

=item *

Разрешено определение C<my ()> с пустым списком переменных [perl #113554].

=item *

При разборе синтаксиса, подпрограммы определённые после ошибок больше не
оставляют заглушек [perl #113712].

=item *

Замыкания, не содержащие строковых eval больше не зависают в содержащихся в них
подпрограммах, позволяя переменным, замкнутых в них из внешних подпрограмм,
быть освобождёнными, когда внешняя подпрограмма освобождается, даже если
внутренняя подпрограмма по-прежнему существует [perl #89544].

=item *

Удвоение дескрипторов файлов, находящихся в оперативной памяти, с помошью
режимов открытия "<&=" или ">&=" перестало работать правильно в v5.16.0.  Оно
приводило к созданию нового дескриптора ссылающегося на другую скалярную
переменную.  Это было исправлено [perl #113764].

=item *

Выражения C<qr//> больше не падают с теми движками регулярных выражений, которые
не устанавливают C<offs> во время компиляции регулярного выражения [perl
#112962].

=item *

C<delete local> больше не приводит к краху с определёнными магическими массивами
и хэшами [perl #112966].

=item *

C<local> на элементы определённых магических массивов и хэшей раньше не приводил
в порядок удалённые элементы при выходе из области видимости, даже если элементы
не существовали до C<local>.

=item *

C<scalar(write)> больше не возвращает несколько элементов [perl #73690].

=item *

Конвертация строк в значения с плавающей запятой, больше не разбирает
неправильно некоторые строки при действии C<use locale> [perl #109318].

=item *

Фильтры C<@INC>, которые умирают, больше не приводят к утечкам памяти [perl
#92252].

=item *

Реализация перегруженных операций теперь вызывается в правильном контексте.
Это, помимо прочего, позволяет корректно переопределять C<< <> >> [perl #47119].

=item *

Указание только C<fallback> ключа, при вызове C<use overload> теперь ведёт себя
правильно [perl #113010].

=item *

C<< sub foo { my $a = 0; while ($a) { ... } } >> и
C<< sub foo { while (0) { ... } } >> теперь возвращают одно и тоже [perl
#73618].

=item *

Отрицание строки ведёт себя также при действии C<use integer;>, как и без неё
[perl #113012].

=item *

C<chr> теперь возвращает символ Юникода замена символа (U+FFFD) для -1,
независимо от внутреннего представления.  -1 раньше скрывался, если аргумент
являлся связанным или был представлен внутренне строкой.

=item *

Использование C<format> после того, как включающая его подпрограмма была
освобождена, приводило к краху, начиная с perl v5.12.0, если на формат ссылалась
лексическая переменная из внешней подпрограммы.

=item *

Использование C<format> после того, как включающей его подпрограмме было
присвоено неопределённое значение, приводило к краху, начиная с perl v5.10.0,
если на формат ссылалась лексическая переменная из внешней подпрограммы.

=item *

Использование C<format> определённого внутри замыкания, на который ссылаются
лексические переменные из вне, никогда реально не работало, если только вызов
C<write> не находился внутри замыкания.  В 5.10.0 это даже начало приводить к
краху.  Теперь копия этого замыкания рядом с самым верхом стека вызовов теперь
используется для поиска этих переменных.

=item *

Форматы, которые замыкают переменные в специальных блоках больше не приводят к
краху, если существует заглушка, с тем же именем, что и у специального блока до
того как специальный блок скомпилирован.

=item *

Парсер больше не путается, рассматривая C<eval foo ()> как синтаксическую
ошибку, если ей предшествовала запись C<print;> [perl #16249].

=item *

Возвращаемое C<syscall> значение больше не обрезается на 64-битных платформах
[perl #113980].

=item *

Вычисление констант больше не приводит к тому, что C<print 1 ? FOO : BAR>
печатает в файловый дескриптор FOO [perl #78064].

=item *

C<do subname> теперь вызывает именованную подпрограмму и использует имя файла,
которое она возвращает, вместо открытия файла с именем "subname".

=item *

Поиск подпрограмм с помощью проверочных хуков rv2cv (зарегистрированных XS
модулем) теперь учитываются при определении является ли C<foo bar> вызовом
подпрограммы C<foo(bar)> или вызовом метода C<< "bar"->foo >>.

=item *

C<CORE::foo::bar> больше не обрабатывается специально, допуская прямой вызов
глобального переопределения через C<CORE::GLOBAL::uc(...)> [perl #113016].

=item *

Вызов неопределённой подпрограмму, чей typeglob был установлен в неопределённое
значение теперь теперь выдаёт привычную ошибку "Undefined subroutine called"
("Вызвана неопределённая подпрограмма"), вместо "Not a CODE reference" ("Не
кодовая ссылка").

=item *

Две ошибки, затрагивающие @ISA, были исправлены.  C<*ISA = *glob_without_array>
и C<undef *ISA; @{*ISA}> предотвратят будущие изменения в @ISA от обновления
внутреннего кэша, используемого для поиска методов. Случай с *glob_without_array
являлся регрессией с Perl v5.12.

=item *

Оптимизация регулярных выражений иногда приводит к тому, что C<$> с C</m> не
совпадает или даёт неверные совпадения [perl #114068].
=item *

C<__SUB__> теперь работает в блоке C<sort>, когда включающая его подпрограмма
предекларирована с помощью синтаксиса C<sub foo;> [perl #113710].

=item *

Свойства Юникода применяются только к кодам Юникода, что приводит к некоторым
тонкостям, когда регулярное выражение совпадает с такими кодовыми точками.
Генерируется предупреждение, чтобы привлечь ваше внимание к этому факту. Однако,
это предупреждение иногда оказывается неуместным, как при синтаксическом анализе
программы. Не Юникодные сравнения, такие как C<\w> и C<[:word:]> не должны
выводить предупреждения, так как их определение не ограничивает их применение
только к кодам Юникода.  Теперь сообщение генерируется только, когда происходит
сравнение с C<\p{}> и C<\P{}>.  Пока остаётся проблема [perl #114148], для очень
небольшого числа свойств Юникода, которые совпадают только с одной кодовой
точкой.  Предупреждение не генерируется, если они совпадают с такой кодовой
точкой Юникода.

=item *
Предупреждения о неинициализированности, упоминающие элементы хэша, будут
упоминать только имя элемента, если он находится не в первой цепочке хэша, из-за
ошибки превышения/занижения на единицу (off-by-one).

=item *

Ошибка в оптимизаторе регулярного выражения может приводить к многострочному "^"
вести себя некорректно в присутствии переносов строк, в таком выражении
C<"/\n\n" =~ m#\A(?:^/$)#im>, которое не совпадёт [perl #115242].

=item *

Неудавшийся C<fork> в списочном контексте больше не приводит к повреждению
стека. C<@a = (1, 2, fork, 3)> раньше поглощал 2 и присваивал C<(1, undef, 3)>,
если вызов C<fork> завершался неудачно.

=item *

Различные утечки памяти были исправлены, в основном затрагивающие связанные
переменные, которые умирают, классы символов регулярных выражений и блоков кода,
а также синтаксические ошибки.

=item *

Присвоение регулярного выражения (C<${qr//}>) переменной, которая содержит число
с плавающей точкой, больше не вызывает ошибок утверждения на сборках с
отладочной информацией.

=item *

Присвоение регулярного выражения скаляру, содержащему число, больше не вызывает
последующего приведения к числовому значению, создающему произвольное число.

=item *

Присвоение регулярного выражения магической переменной больше не стирает магию.
Это являлось регрессией, начиная с v5.10.

=item *

Присвоение регулярного выражения благословлённому скаляру больше не приводит к
краху.  Это также являлось регрессией с v5.10.

=item *

Регулярное выражение может теперь быть присвоено связанному хэшу и элементу
массив с привидением к строковому виду.

=item *

Приведение регулярного выражения к числу больше не приводит к выводу
предупреждения о неинициализированном значении.

=item *

Отрицательные индексы массива больше не приводят к тому, что методы EXISTS
связанной переменной игнорировались.  Это являлось регрессией с v5.12.

=item *

Отрицательные индексы массива больше не приводят к краху на массивах, связанными
с не-объектами.

=item *

C<$byte_overload .= $utf8> больше не приводит к двойному кодированию UTF-8, если
скаляр с левой стороны создал UTF-8 строку при последнем вызове операции
перегрузки.

=item *

C<goto &sub> теперь использует текущее значение @_, вместо использования
массива, с которым первоначально была вызвана подпрограмма.  Это означает, что
C<local @_ = (...); goto &sub> теперь работает [perl #43077].

=item *

Если отладчик вызывается рекурсивно, то он больше не портит свои собственные
лексические переменные. Раньше при рекурсии все вызовы разделяли одинаковый
набор лексических переменных [perl #115742].

=item *

C<*_{ARRAY}> возвращённый из подпрограммы больше не становится самопроизвольно
пустым.

=back

=head1 Известные проблемы

=over 4

=item *

Строки с UTF8 флагом в C<%ENV> на HP-UX 11.00 глючат.

Взаимодействие строк с UTF-8 флагом и C<%ENV> на HP-UX 11.00 на данный момент
очень хитрое в некоторых не до конца диагностированных случаях.  Ожидаемы ошибки
в тесте F<t/op/magic.t>, с непредсказуемым поведением при сохранении широких
символов в переменных окружения.

=back

=head1 Некролог

Ходжанг Юн (Hojung Yoon) (AMORETTE), 24 года, Сеул, Южная Корея, отправился в
свой последний путь 8 мая 2013 со статуэткой ламы и карточкой, подписанной
TIMTOADY.  Это был прекрасный молодой Perl 5 и 6 хакер и преданный участник
Seoul.pm.  Он программировал на Perl, говорил о Perl, ел Perl и любил Perl.  Мы
верим, что он по-прежнему где-то программирует на Perl на своём сломанном IBM
ноутбуке.  Его будет не хватать нам.

=head1 Acknowledgements


Perl v5.18.0 представляет собой примерно 12 месяцев разработки, начиная с
Perl v5.16.0, и содержит примерно 400,000 изменённых строк среди 2,100
файлов от 113 авторов.

Perl продолжает бурно развиваться в своей третьей декаде благодаря
активному сообществу пользователей и разработчиков.  Известно, что
следующие люди содействовали в улучшении того, что стало Perl 5.18.0:

Aaron Crane, Aaron Trevena, Abhijit Menon-Sen, Adrian M. Enache, Alan
Haggai Alavi, Alexandr Ciornii, Andrew Tam, Andy Dougherty, Anton Nikishaev,
Aristotle Pagaltzis, Augustina Blair, Bob Ernst, Brad Gilbert, Breno G. de
Oliveira, Brian Carlson, Brian Fraser, Charlie Gonzalez, Chip Salzenberg, Chris
'BinGOs' Williams, Christian Hansen, Colin Kuskie, Craig A. Berry, Dagfinn
Ilmari Mannsåker, Daniel Dragan, Daniel Perrett, Darin McBride, Dave Rolsky,
David Golden, David Leadbeater, David Mitchell, David Nicol, Dominic
Hargreaves, E. Choroba, Eric Brine, Evan Miller, Father Chrysostomos, Florian
Ragwitz, François Perrad, George Greer, Goro Fuji, H.Merijn Brand, Herbert
Breunung, Hugo van der Sanden, Igor Zaytsev, James E Keenan, Jan Dubois,
Jasmine Ahuja, Jerry D. Hedden, Jess Robinson, Jesse Luehrs, Joaquin Ferrero,
Joel Berger, John Goodyear, John Peacock, Karen Etheridge, Karl Williamson,
Karthik Rajagopalan, Kent Fredric, Leon Timmermans, Lucas Holt, Lukas Mai,
Marcus Holland-Moritz, Markus Jansen, Martin Hasch, Matthew Horsfall, Max
Maischein, Michael G Schwern, Michael Schroeder, Moritz Lenz, Nicholas Clark,
Niko Tyni, Oleg Nesterov, Patrik Hägglund, Paul Green, Paul Johnson, Paul
Marquess, Peter Martini, Rafael Garcia-Suarez, Reini Urban, Renee Baecker,
Rhesa Rozendaal, Ricardo Signes, Robin Barker, Ronald J. Kimball, Ruslan
Zakirov, Salvador Fandiño, Sawyer X, Scott Lanning, Sergey Alekseev, Shawn M
Moore, Shirakata Kentaro, Shlomi Fish, Sisyphus, Smylers, Steffen Müller,
Steve Hay, Steve Peters, Steven Schubiger, Sullivan Beck, Sven Strickroth,
Sébastien Aperghis-Tramoni, Thomas Sibley, Tobias Leich, Tom Wyant, Tony Cook,
Vadim Konovalov, Vincent Pit, Volker Schatz, Walt Mankowski, Yves Orton,
Zefram.

Список выше конечно неполон, так как был автоматически сгенерирован из истории
системы контроля версий.  В частности, он не включает имена (очень высоко
ценимых) помощников, которые сообщали о проблемах в Perl баг-трекер.

Множество изменений, включённых в этой версии, идут от CPAN модулей, включённых
в ядро Perl.  Мы благодарны всему CPAN сообществу за помощь в развитии Perl.

Полный список всех принимавших участие в разработке в истории Perl смотрите
пожалуйста в файле F<AUTHORS> в дистрибутиве исходного кода Perl.

=head1 Сообщения об ошибках

Если вы найдёте то, что как вы считаете является ошибкой, вы можете проверить
ранее опубликованные статьи в новостной группе comp.lang.perl.misc и базе ошибок
perl на L<http://rt.perl.org/perlbug/>.  Также может быть информация на
L<http://www.perl.org/>, домашней странице Perl.

Если вы уверены, что у вас ещё ни кем не сообщённая ошибка, пожалуйста запустите
программу L<perlbug>, включённую в ваш релиз.  Убедитесь, что вы привели
максимально краткий, но достаточный пример, для воспроизведения проблемы.  Ваш
отчёт по ошибке, вместе с выводом C<perl -V>, будет отправлен на адрес
perlbug@perl.org для анализа командой портирования Perl.

Если ошибка, о котором вы сообщаете, имеет отношение к безопасности, что делает
его неуместным для отправки в публичную архивируемую почтовую рассылку,
пожалуйста отправьте его на perl5-security-report@perl.org.  Это неархивируемая
почтовая рассылка с закрытой подпиской,  которая включает всех главных
коммитеров, и позволит скоординировать выпуск патча для смягчения или
исправления проблемы на всех платформах, на которых поддерживается Perl.
Пожалуйста используйте этот адрес только для проблем безопасности в базовом
Perl, а не для модулей, которые распространяются на CPAN.

=head1 Смотрите также

Файл F<Changes> для просмотра исчерпывающей информации о том, что изменилось.

Файл F<INSTALL> о том, как собирать Perl.

Файл F<README> для общей информации.

Файлы F<Artistic> и F<Copying> для информации по правам.

=cut
